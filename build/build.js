/*! For license information please see build.js.LICENSE.txt */
!function(t,c){for(var n in c)t[n]=c[n]}(this,function(t){var c={};function n(l){if(c[l])return c[l].exports;var d=c[l]={i:l,l:!1,exports:{}};return t[l].call(d.exports,d,d.exports,n),d.l=!0,d.exports}return n.m=t,n.c=c,n.d=function(t,c,l){n.o(t,c)||Object.defineProperty(t,c,{enumerable:!0,get:l})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,c){if(1&c&&(t=n(t)),8&c)return t;if(4&c&&"object"==typeof t&&t&&t.__esModule)return t;var l=Object.create(null);if(n.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:t}),2&c&&"string"!=typeof t)for(var d in t)n.d(l,d,function(c){return t[c]}.bind(null,d));return l},n.n=function(t){var c=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(c,"a",c),c},n.o=function(t,c){return Object.prototype.hasOwnProperty.call(t,c)},n.p="",n(n.s="./app.js")}({"../node_modules/apollo-fetch/dist/apollo-fetch.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"constructDefaultOptions\", function() { return constructDefaultOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createApolloFetch\", function() { return createApolloFetch; });\n/* harmony import */ var cross_fetch_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cross-fetch/polyfill */ \"../node_modules/cross-fetch/dist/browser-polyfill.js\");\n/* harmony import */ var cross_fetch_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cross_fetch_polyfill__WEBPACK_IMPORTED_MODULE_0__);\nvar __assign = (undefined && undefined.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\nfunction buildWareStack(funcs, modifiedObject, resolve) {\n    var _this = this;\n    var next = function () {\n        if (funcs.length > 0) {\n            var f = funcs.shift();\n            if (f) {\n                f.apply(_this, [modifiedObject, next]);\n            }\n        }\n        else {\n            resolve(modifiedObject);\n        }\n    };\n    next();\n}\nfunction constructDefaultOptions(requestOrRequests, options) {\n    var body;\n    try {\n        body = JSON.stringify(requestOrRequests);\n    }\n    catch (e) {\n        throw new Error(\"Network request failed. Payload is not serializable: \" + e.message);\n    }\n    return __assign({ body: body, method: 'POST' }, options, { headers: __assign({ Accept: '*/*', 'Content-Type': 'application/json' }, options.headers || []) });\n}\nfunction throwHttpError(response, error) {\n    var httpError;\n    if (response && response.status >= 300) {\n        httpError = new Error(\"Network request failed with status \" + response.status + \" - \\\"\" + response.statusText + \"\\\"\");\n    }\n    else {\n        httpError = new Error(\"Network request failed to return valid JSON\");\n    }\n    httpError.response = response;\n    httpError.parseError = error;\n    throw httpError;\n}\nfunction throwBatchError(response) {\n    var httpError = new Error(\"A batched Operation of responses for \");\n    httpError.response = response;\n    throw httpError;\n}\nfunction createApolloFetch(params) {\n    if (params === void 0) { params = {}; }\n    var constructOptions = params.constructOptions, customFetch = params.customFetch;\n    var _uri = params.uri || '/graphql';\n    var middlewares = [];\n    var batchedMiddlewares = [];\n    var afterwares = [];\n    var batchedAfterwares = [];\n    var applyMiddlewares = function (requestAndOptions, batched) {\n        return new Promise(function (resolve, reject) {\n            if (batched) {\n                buildWareStack(batchedMiddlewares.slice(), requestAndOptions, resolve);\n            }\n            else {\n                buildWareStack(middlewares.slice(), requestAndOptions, resolve);\n            }\n        });\n    };\n    var applyAfterwares = function (responseObject, batched) {\n        return new Promise(function (resolve, reject) {\n            if (batched) {\n                buildWareStack(batchedAfterwares.slice(), responseObject, resolve);\n            }\n            else {\n                buildWareStack(afterwares.slice(), responseObject, resolve);\n            }\n        });\n    };\n    var apolloFetch = function (request) {\n        var options = {};\n        var parseError;\n        var batched = Array.isArray(request);\n        var requestObject = (batched\n            ? {\n                requests: request,\n                options: options,\n            }\n            : {\n                request: request,\n                options: options,\n            });\n        return applyMiddlewares(requestObject, batched)\n            .then(function (reqOpts) {\n            var construct = constructOptions || constructDefaultOptions;\n            var requestOrRequests = reqOpts.request ||\n                reqOpts.requests;\n            return construct(requestOrRequests, reqOpts.options);\n        })\n            .then(function (opts) {\n            options = __assign({}, opts);\n            return (customFetch || fetch)(_uri, options);\n        })\n            .then(function (response) {\n            return response.text().then(function (raw) {\n                try {\n                    var parsed = JSON.parse(raw);\n                    response.raw = raw;\n                    response.parsed = parsed;\n                    return response;\n                }\n                catch (e) {\n                    parseError = e;\n                    response.raw = raw;\n                    return response;\n                }\n            });\n        })\n            .then(function (response) {\n            return applyAfterwares({\n                response: response,\n                options: options,\n            }, batched);\n        })\n            .then(function (_a) {\n            var response = _a.response;\n            if (response.parsed) {\n                if (batched) {\n                    if (Array.isArray(response.parsed)) {\n                        return response.parsed;\n                    }\n                    else {\n                        throwBatchError(response);\n                    }\n                }\n                else {\n                    return __assign({}, response.parsed);\n                }\n            }\n            else {\n                throwHttpError(response, parseError);\n            }\n        });\n    };\n    apolloFetch.use = function (middleware) {\n        if (typeof middleware === 'function') {\n            middlewares.push(middleware);\n        }\n        else {\n            throw new Error('Middleware must be a function');\n        }\n        return apolloFetch;\n    };\n    apolloFetch.useAfter = function (afterware) {\n        if (typeof afterware === 'function') {\n            afterwares.push(afterware);\n        }\n        else {\n            throw new Error('Afterware must be a function');\n        }\n        return apolloFetch;\n    };\n    apolloFetch.batchUse = function (middleware) {\n        if (typeof middleware === 'function') {\n            batchedMiddlewares.push(middleware);\n        }\n        else {\n            throw new Error('Middleware must be a function');\n        }\n        return apolloFetch;\n    };\n    apolloFetch.batchUseAfter = function (afterware) {\n        if (typeof afterware === 'function') {\n            batchedAfterwares.push(afterware);\n        }\n        else {\n            throw new Error('Afterware must be a function');\n        }\n        return apolloFetch;\n    };\n    return apolloFetch;\n}\n//# sourceMappingURL=apollo-fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2Fwb2xsby1mZXRjaC9kaXN0L2Fwb2xsby1mZXRjaC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXBvbGxvLWZldGNoL2Rpc3QvYXBvbGxvLWZldGNoLmpzPzAyNTciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5pbXBvcnQgJ2Nyb3NzLWZldGNoL3BvbHlmaWxsJztcbmZ1bmN0aW9uIGJ1aWxkV2FyZVN0YWNrKGZ1bmNzLCBtb2RpZmllZE9iamVjdCwgcmVzb2x2ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChmdW5jcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZ1bmNzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoZikge1xuICAgICAgICAgICAgICAgIGYuYXBwbHkoX3RoaXMsIFttb2RpZmllZE9iamVjdCwgbmV4dF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShtb2RpZmllZE9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIG5leHQoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3REZWZhdWx0T3B0aW9ucyhyZXF1ZXN0T3JSZXF1ZXN0cywgb3B0aW9ucykge1xuICAgIHZhciBib2R5O1xuICAgIHRyeSB7XG4gICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0T3JSZXF1ZXN0cyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWQuIFBheWxvYWQgaXMgbm90IHNlcmlhbGl6YWJsZTogXCIgKyBlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gX19hc3NpZ24oeyBib2R5OiBib2R5LCBtZXRob2Q6ICdQT1NUJyB9LCBvcHRpb25zLCB7IGhlYWRlcnM6IF9fYXNzaWduKHsgQWNjZXB0OiAnKi8qJywgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LCBvcHRpb25zLmhlYWRlcnMgfHwgW10pIH0pO1xufVxuZnVuY3Rpb24gdGhyb3dIdHRwRXJyb3IocmVzcG9uc2UsIGVycm9yKSB7XG4gICAgdmFyIGh0dHBFcnJvcjtcbiAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2Uuc3RhdHVzID49IDMwMCkge1xuICAgICAgICBodHRwRXJyb3IgPSBuZXcgRXJyb3IoXCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIFwiICsgcmVzcG9uc2Uuc3RhdHVzICsgXCIgLSBcXFwiXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0ICsgXCJcXFwiXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaHR0cEVycm9yID0gbmV3IEVycm9yKFwiTmV0d29yayByZXF1ZXN0IGZhaWxlZCB0byByZXR1cm4gdmFsaWQgSlNPTlwiKTtcbiAgICB9XG4gICAgaHR0cEVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgaHR0cEVycm9yLnBhcnNlRXJyb3IgPSBlcnJvcjtcbiAgICB0aHJvdyBodHRwRXJyb3I7XG59XG5mdW5jdGlvbiB0aHJvd0JhdGNoRXJyb3IocmVzcG9uc2UpIHtcbiAgICB2YXIgaHR0cEVycm9yID0gbmV3IEVycm9yKFwiQSBiYXRjaGVkIE9wZXJhdGlvbiBvZiByZXNwb25zZXMgZm9yIFwiKTtcbiAgICBodHRwRXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aHJvdyBodHRwRXJyb3I7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXBvbGxvRmV0Y2gocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XG4gICAgdmFyIGNvbnN0cnVjdE9wdGlvbnMgPSBwYXJhbXMuY29uc3RydWN0T3B0aW9ucywgY3VzdG9tRmV0Y2ggPSBwYXJhbXMuY3VzdG9tRmV0Y2g7XG4gICAgdmFyIF91cmkgPSBwYXJhbXMudXJpIHx8ICcvZ3JhcGhxbCc7XG4gICAgdmFyIG1pZGRsZXdhcmVzID0gW107XG4gICAgdmFyIGJhdGNoZWRNaWRkbGV3YXJlcyA9IFtdO1xuICAgIHZhciBhZnRlcndhcmVzID0gW107XG4gICAgdmFyIGJhdGNoZWRBZnRlcndhcmVzID0gW107XG4gICAgdmFyIGFwcGx5TWlkZGxld2FyZXMgPSBmdW5jdGlvbiAocmVxdWVzdEFuZE9wdGlvbnMsIGJhdGNoZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmIChiYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgYnVpbGRXYXJlU3RhY2soYmF0Y2hlZE1pZGRsZXdhcmVzLnNsaWNlKCksIHJlcXVlc3RBbmRPcHRpb25zLCByZXNvbHZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1aWxkV2FyZVN0YWNrKG1pZGRsZXdhcmVzLnNsaWNlKCksIHJlcXVlc3RBbmRPcHRpb25zLCByZXNvbHZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgYXBwbHlBZnRlcndhcmVzID0gZnVuY3Rpb24gKHJlc3BvbnNlT2JqZWN0LCBiYXRjaGVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoYmF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIGJ1aWxkV2FyZVN0YWNrKGJhdGNoZWRBZnRlcndhcmVzLnNsaWNlKCksIHJlc3BvbnNlT2JqZWN0LCByZXNvbHZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1aWxkV2FyZVN0YWNrKGFmdGVyd2FyZXMuc2xpY2UoKSwgcmVzcG9uc2VPYmplY3QsIHJlc29sdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBhcG9sbG9GZXRjaCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBwYXJzZUVycm9yO1xuICAgICAgICB2YXIgYmF0Y2hlZCA9IEFycmF5LmlzQXJyYXkocmVxdWVzdCk7XG4gICAgICAgIHZhciByZXF1ZXN0T2JqZWN0ID0gKGJhdGNoZWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RzOiByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFwcGx5TWlkZGxld2FyZXMocmVxdWVzdE9iamVjdCwgYmF0Y2hlZClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXFPcHRzKSB7XG4gICAgICAgICAgICB2YXIgY29uc3RydWN0ID0gY29uc3RydWN0T3B0aW9ucyB8fCBjb25zdHJ1Y3REZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIHZhciByZXF1ZXN0T3JSZXF1ZXN0cyA9IHJlcU9wdHMucmVxdWVzdCB8fFxuICAgICAgICAgICAgICAgIHJlcU9wdHMucmVxdWVzdHM7XG4gICAgICAgICAgICByZXR1cm4gY29uc3RydWN0KHJlcXVlc3RPclJlcXVlc3RzLCByZXFPcHRzLm9wdGlvbnMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfX2Fzc2lnbih7fSwgb3B0cyk7XG4gICAgICAgICAgICByZXR1cm4gKGN1c3RvbUZldGNoIHx8IGZldGNoKShfdXJpLCBvcHRpb25zKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKS50aGVuKGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gSlNPTi5wYXJzZShyYXcpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5yYXcgPSByYXc7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUVycm9yID0gZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucmF3ID0gcmF3O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseUFmdGVyd2FyZXMoe1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgfSwgYmF0Y2hlZCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IF9hLnJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnBhcnNlZCkge1xuICAgICAgICAgICAgICAgIGlmIChiYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlLnBhcnNlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5wYXJzZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0JhdGNoRXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIHJlc3BvbnNlLnBhcnNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3dIdHRwRXJyb3IocmVzcG9uc2UsIHBhcnNlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFwb2xsb0ZldGNoLnVzZSA9IGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWlkZGxld2FyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbWlkZGxld2FyZXMucHVzaChtaWRkbGV3YXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlkZGxld2FyZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBvbGxvRmV0Y2g7XG4gICAgfTtcbiAgICBhcG9sbG9GZXRjaC51c2VBZnRlciA9IGZ1bmN0aW9uIChhZnRlcndhcmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhZnRlcndhcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFmdGVyd2FyZXMucHVzaChhZnRlcndhcmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZnRlcndhcmUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwb2xsb0ZldGNoO1xuICAgIH07XG4gICAgYXBvbGxvRmV0Y2guYmF0Y2hVc2UgPSBmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgICAgICBpZiAodHlwZW9mIG1pZGRsZXdhcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGJhdGNoZWRNaWRkbGV3YXJlcy5wdXNoKG1pZGRsZXdhcmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaWRkbGV3YXJlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcG9sbG9GZXRjaDtcbiAgICB9O1xuICAgIGFwb2xsb0ZldGNoLmJhdGNoVXNlQWZ0ZXIgPSBmdW5jdGlvbiAoYWZ0ZXJ3YXJlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWZ0ZXJ3YXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBiYXRjaGVkQWZ0ZXJ3YXJlcy5wdXNoKGFmdGVyd2FyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FmdGVyd2FyZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBvbGxvRmV0Y2g7XG4gICAgfTtcbiAgICByZXR1cm4gYXBvbGxvRmV0Y2g7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcG9sbG8tZmV0Y2guanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/apollo-fetch/dist/apollo-fetch.js\n")},"../node_modules/apollo-fetch/dist/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _apollo_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./apollo-fetch */ "../node_modules/apollo-fetch/dist/apollo-fetch.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "constructDefaultOptions", function() { return _apollo_fetch__WEBPACK_IMPORTED_MODULE_0__["constructDefaultOptions"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createApolloFetch", function() { return _apollo_fetch__WEBPACK_IMPORTED_MODULE_0__["createApolloFetch"]; });\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2Fwb2xsby1mZXRjaC9kaXN0L2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9hcG9sbG8tZmV0Y2gvZGlzdC9pbmRleC5qcz83YzM1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vYXBvbGxvLWZldGNoJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/apollo-fetch/dist/index.js\n')},"../node_modules/cross-fetch/dist/browser-polyfill.js":function(module,exports){eval("(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob();\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    };\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue+','+value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) { items.push(name); });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) { items.push(value); });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) { items.push([name, value]); });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=');\n        var name = split.shift().replace(/\\+/g, ' ');\n        var value = split.join('=').replace(/\\+/g, ' ');\n        form.append(decodeURIComponent(name), decodeURIComponent(value));\n      }\n    });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = 'status' in options ? options.status : 200;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n      var xhr = new XMLHttpRequest();\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  };\n  self.fetch.polyfill = true;\n})(typeof self !== 'undefined' ? self : this);\n\n/*\n * Rollup wraps up the whatwg-fetch code on ponyfill mode in\n * order to prevent it from adding fetch to the global object.\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWZldGNoL2Rpc3QvYnJvd3Nlci1wb2x5ZmlsbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY3Jvc3MtZmV0Y2gvZGlzdC9icm93c2VyLXBvbHlmaWxsLmpzPzZiNzEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHNlbGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmIChzZWxmLmZldGNoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gc2VsZlxuICB9O1xuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXTtcblxuICAgIHZhciBpc0RhdGFWaWV3ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbiAgICB9O1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID0gQXJyYXlCdWZmZXIuaXNWaWV3IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLlxcXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbiAgZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcmF0b3JcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge307XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdO1xuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSsnLCcrdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChuYW1lKTsgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkgeyBpdGVtcy5wdXNoKHZhbHVlKTsgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKTsgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIEJvZHlJbml0IHR5cGUnKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gY29uc3VtZWQodGhpcykgfHwgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gKG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xKSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0O1xuICAgICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdvbWl0JztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5yZWZlcnJlciA9IG51bGw7XG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpO1xuICB9XG5cbiAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywgeyBib2R5OiB0aGlzLl9ib2R5SW5pdCB9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpO1xuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZm9ybVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgcmF3SGVhZGVycy5zcGxpdCgvXFxyP1xcbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpO1xuICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpO1xuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9ICdkZWZhdWx0JztcbiAgICB0aGlzLnN0YXR1cyA9ICdzdGF0dXMnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1cyA6IDIwMDtcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9ICdzdGF0dXNUZXh0JyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogJ09LJztcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJyc7XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpO1xuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSk7XG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfTtcblxuICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pO1xuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InO1xuICAgIHJldHVybiByZXNwb25zZVxuICB9O1xuXG4gIHZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XTtcblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9O1xuXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnM7XG4gIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcblxuICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KTtcbiAgICB9KVxuICB9O1xuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKTtcblxuLypcbiAqIFJvbGx1cCB3cmFwcyB1cCB0aGUgd2hhdHdnLWZldGNoIGNvZGUgb24gcG9ueWZpbGwgbW9kZSBpblxuICogb3JkZXIgdG8gcHJldmVudCBpdCBmcm9tIGFkZGluZyBmZXRjaCB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAqL1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/cross-fetch/dist/browser-polyfill.js\n")},"../node_modules/css-loader/index.js?!../node_modules/jquery-ui/themes/base/core.css":function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(/*! ../../../css-loader/lib/css-base.js */ "../node_modules/css-loader/lib/css-base.js")(false);\n// imports\n\n\n// module\nexports.push([module.i, "/*!\\n * jQuery UI CSS Framework 1.13.2\\n * http://jqueryui.com\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license.\\n * http://jquery.org/license\\n *\\n * http://api.jqueryui.com/category/theming/\\n */\\n\\n/* Layout helpers\\n----------------------------------*/\\n.ui-helper-hidden {\\n\\tdisplay: none;\\n}\\n.ui-helper-hidden-accessible {\\n\\tborder: 0;\\n\\tclip: rect(0 0 0 0);\\n\\theight: 1px;\\n\\tmargin: -1px;\\n\\toverflow: hidden;\\n\\tpadding: 0;\\n\\tposition: absolute;\\n\\twidth: 1px;\\n}\\n.ui-helper-reset {\\n\\tmargin: 0;\\n\\tpadding: 0;\\n\\tborder: 0;\\n\\toutline: 0;\\n\\tline-height: 1.3;\\n\\ttext-decoration: none;\\n\\tfont-size: 100%;\\n\\tlist-style: none;\\n}\\n.ui-helper-clearfix:before,\\n.ui-helper-clearfix:after {\\n\\tcontent: \\"\\";\\n\\tdisplay: table;\\n\\tborder-collapse: collapse;\\n}\\n.ui-helper-clearfix:after {\\n\\tclear: both;\\n}\\n.ui-helper-zfix {\\n\\twidth: 100%;\\n\\theight: 100%;\\n\\ttop: 0;\\n\\tleft: 0;\\n\\tposition: absolute;\\n\\topacity: 0;\\n\\t-ms-filter: \\"alpha(opacity=0)\\"; /* support: IE8 */\\n}\\n\\n.ui-front {\\n\\tz-index: 100;\\n}\\n\\n\\n/* Interaction Cues\\n----------------------------------*/\\n.ui-state-disabled {\\n\\tcursor: default !important;\\n\\tpointer-events: none;\\n}\\n\\n\\n/* Icons\\n----------------------------------*/\\n.ui-icon {\\n\\tdisplay: inline-block;\\n\\tvertical-align: middle;\\n\\tmargin-top: -.25em;\\n\\tposition: relative;\\n\\ttext-indent: -99999px;\\n\\toverflow: hidden;\\n\\tbackground-repeat: no-repeat;\\n}\\n\\n.ui-widget-icon-block {\\n\\tleft: 50%;\\n\\tmargin-left: -8px;\\n\\tdisplay: block;\\n}\\n\\n/* Misc visuals\\n----------------------------------*/\\n\\n/* Overlays */\\n.ui-widget-overlay {\\n\\tposition: fixed;\\n\\ttop: 0;\\n\\tleft: 0;\\n\\twidth: 100%;\\n\\theight: 100%;\\n}\\n", ""]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/IS4uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdGhlbWVzL2Jhc2UvY29yZS5jc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS90aGVtZXMvYmFzZS9jb3JlLmNzcz83MWRhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiFcXG4gKiBqUXVlcnkgVUkgQ1NTIEZyYW1ld29yayAxLjEzLjJcXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICpcXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICpcXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9jYXRlZ29yeS90aGVtaW5nL1xcbiAqL1xcblxcbi8qIExheW91dCBoZWxwZXJzXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLnVpLWhlbHBlci1oaWRkZW4ge1xcblxcdGRpc3BsYXk6IG5vbmU7XFxufVxcbi51aS1oZWxwZXItaGlkZGVuLWFjY2Vzc2libGUge1xcblxcdGJvcmRlcjogMDtcXG5cXHRjbGlwOiByZWN0KDAgMCAwIDApO1xcblxcdGhlaWdodDogMXB4O1xcblxcdG1hcmdpbjogLTFweDtcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcblxcdHBhZGRpbmc6IDA7XFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcblxcdHdpZHRoOiAxcHg7XFxufVxcbi51aS1oZWxwZXItcmVzZXQge1xcblxcdG1hcmdpbjogMDtcXG5cXHRwYWRkaW5nOiAwO1xcblxcdGJvcmRlcjogMDtcXG5cXHRvdXRsaW5lOiAwO1xcblxcdGxpbmUtaGVpZ2h0OiAxLjM7XFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcblxcdGZvbnQtc2l6ZTogMTAwJTtcXG5cXHRsaXN0LXN0eWxlOiBub25lO1xcbn1cXG4udWktaGVscGVyLWNsZWFyZml4OmJlZm9yZSxcXG4udWktaGVscGVyLWNsZWFyZml4OmFmdGVyIHtcXG5cXHRjb250ZW50OiBcXFwiXFxcIjtcXG5cXHRkaXNwbGF5OiB0YWJsZTtcXG5cXHRib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG4udWktaGVscGVyLWNsZWFyZml4OmFmdGVyIHtcXG5cXHRjbGVhcjogYm90aDtcXG59XFxuLnVpLWhlbHBlci16Zml4IHtcXG5cXHR3aWR0aDogMTAwJTtcXG5cXHRoZWlnaHQ6IDEwMCU7XFxuXFx0dG9wOiAwO1xcblxcdGxlZnQ6IDA7XFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcblxcdG9wYWNpdHk6IDA7XFxuXFx0LW1zLWZpbHRlcjogXFxcImFscGhhKG9wYWNpdHk9MClcXFwiOyAvKiBzdXBwb3J0OiBJRTggKi9cXG59XFxuXFxuLnVpLWZyb250IHtcXG5cXHR6LWluZGV4OiAxMDA7XFxufVxcblxcblxcbi8qIEludGVyYWN0aW9uIEN1ZXNcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4udWktc3RhdGUtZGlzYWJsZWQge1xcblxcdGN1cnNvcjogZGVmYXVsdCAhaW1wb3J0YW50O1xcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG5cXG4vKiBJY29uc1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi51aS1pY29uIHtcXG5cXHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuXFx0dmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG5cXHRtYXJnaW4tdG9wOiAtLjI1ZW07XFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcblxcdHRleHQtaW5kZW50OiAtOTk5OTlweDtcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcblxcdGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbi51aS13aWRnZXQtaWNvbi1ibG9jayB7XFxuXFx0bGVmdDogNTAlO1xcblxcdG1hcmdpbi1sZWZ0OiAtOHB4O1xcblxcdGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG4vKiBNaXNjIHZpc3VhbHNcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG4vKiBPdmVybGF5cyAqL1xcbi51aS13aWRnZXQtb3ZlcmxheSB7XFxuXFx0cG9zaXRpb246IGZpeGVkO1xcblxcdHRvcDogMDtcXG5cXHRsZWZ0OiAwO1xcblxcdHdpZHRoOiAxMDAlO1xcblxcdGhlaWdodDogMTAwJTtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/css-loader/index.js?!../node_modules/jquery-ui/themes/base/core.css\n')},"../node_modules/css-loader/index.js?!../node_modules/jquery-ui/themes/base/tabs.css":function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(/*! ../../../css-loader/lib/css-base.js */ "../node_modules/css-loader/lib/css-base.js")(false);\n// imports\n\n\n// module\nexports.push([module.i, "/*!\\n * jQuery UI Tabs 1.13.2\\n * http://jqueryui.com\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license.\\n * http://jquery.org/license\\n *\\n * http://api.jqueryui.com/tabs/#theming\\n */\\n.ui-tabs {\\n\\tposition: relative;/* position: relative prevents IE scroll bug (element with position: relative inside container with overflow: auto appear as \\"fixed\\") */\\n\\tpadding: .2em;\\n}\\n.ui-tabs .ui-tabs-nav {\\n\\tmargin: 0;\\n\\tpadding: .2em .2em 0;\\n}\\n.ui-tabs .ui-tabs-nav li {\\n\\tlist-style: none;\\n\\tfloat: left;\\n\\tposition: relative;\\n\\ttop: 0;\\n\\tmargin: 1px .2em 0 0;\\n\\tborder-bottom-width: 0;\\n\\tpadding: 0;\\n\\twhite-space: nowrap;\\n}\\n.ui-tabs .ui-tabs-nav .ui-tabs-anchor {\\n\\tfloat: left;\\n\\tpadding: .5em 1em;\\n\\ttext-decoration: none;\\n}\\n.ui-tabs .ui-tabs-nav li.ui-tabs-active {\\n\\tmargin-bottom: -1px;\\n\\tpadding-bottom: 1px;\\n}\\n.ui-tabs .ui-tabs-nav li.ui-tabs-active .ui-tabs-anchor,\\n.ui-tabs .ui-tabs-nav li.ui-state-disabled .ui-tabs-anchor,\\n.ui-tabs .ui-tabs-nav li.ui-tabs-loading .ui-tabs-anchor {\\n\\tcursor: text;\\n}\\n.ui-tabs-collapsible .ui-tabs-nav li.ui-tabs-active .ui-tabs-anchor {\\n\\tcursor: pointer;\\n}\\n.ui-tabs .ui-tabs-panel {\\n\\tdisplay: block;\\n\\tborder-width: 0;\\n\\tpadding: 1em 1.4em;\\n\\tbackground: none;\\n}\\n", ""]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/IS4uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdGhlbWVzL2Jhc2UvdGFicy5jc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS90aGVtZXMvYmFzZS90YWJzLmNzcz81MmVkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiFcXG4gKiBqUXVlcnkgVUkgVGFicyAxLjEzLjJcXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICpcXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICpcXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS90YWJzLyN0aGVtaW5nXFxuICovXFxuLnVpLXRhYnMge1xcblxcdHBvc2l0aW9uOiByZWxhdGl2ZTsvKiBwb3NpdGlvbjogcmVsYXRpdmUgcHJldmVudHMgSUUgc2Nyb2xsIGJ1ZyAoZWxlbWVudCB3aXRoIHBvc2l0aW9uOiByZWxhdGl2ZSBpbnNpZGUgY29udGFpbmVyIHdpdGggb3ZlcmZsb3c6IGF1dG8gYXBwZWFyIGFzIFxcXCJmaXhlZFxcXCIpICovXFxuXFx0cGFkZGluZzogLjJlbTtcXG59XFxuLnVpLXRhYnMgLnVpLXRhYnMtbmF2IHtcXG5cXHRtYXJnaW46IDA7XFxuXFx0cGFkZGluZzogLjJlbSAuMmVtIDA7XFxufVxcbi51aS10YWJzIC51aS10YWJzLW5hdiBsaSB7XFxuXFx0bGlzdC1zdHlsZTogbm9uZTtcXG5cXHRmbG9hdDogbGVmdDtcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxuXFx0dG9wOiAwO1xcblxcdG1hcmdpbjogMXB4IC4yZW0gMCAwO1xcblxcdGJvcmRlci1ib3R0b20td2lkdGg6IDA7XFxuXFx0cGFkZGluZzogMDtcXG5cXHR3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG4udWktdGFicyAudWktdGFicy1uYXYgLnVpLXRhYnMtYW5jaG9yIHtcXG5cXHRmbG9hdDogbGVmdDtcXG5cXHRwYWRkaW5nOiAuNWVtIDFlbTtcXG5cXHR0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxufVxcbi51aS10YWJzIC51aS10YWJzLW5hdiBsaS51aS10YWJzLWFjdGl2ZSB7XFxuXFx0bWFyZ2luLWJvdHRvbTogLTFweDtcXG5cXHRwYWRkaW5nLWJvdHRvbTogMXB4O1xcbn1cXG4udWktdGFicyAudWktdGFicy1uYXYgbGkudWktdGFicy1hY3RpdmUgLnVpLXRhYnMtYW5jaG9yLFxcbi51aS10YWJzIC51aS10YWJzLW5hdiBsaS51aS1zdGF0ZS1kaXNhYmxlZCAudWktdGFicy1hbmNob3IsXFxuLnVpLXRhYnMgLnVpLXRhYnMtbmF2IGxpLnVpLXRhYnMtbG9hZGluZyAudWktdGFicy1hbmNob3Ige1xcblxcdGN1cnNvcjogdGV4dDtcXG59XFxuLnVpLXRhYnMtY29sbGFwc2libGUgLnVpLXRhYnMtbmF2IGxpLnVpLXRhYnMtYWN0aXZlIC51aS10YWJzLWFuY2hvciB7XFxuXFx0Y3Vyc29yOiBwb2ludGVyO1xcbn1cXG4udWktdGFicyAudWktdGFicy1wYW5lbCB7XFxuXFx0ZGlzcGxheTogYmxvY2s7XFxuXFx0Ym9yZGVyLXdpZHRoOiAwO1xcblxcdHBhZGRpbmc6IDFlbSAxLjRlbTtcXG5cXHRiYWNrZ3JvdW5kOiBub25lO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/css-loader/index.js?!../node_modules/jquery-ui/themes/base/tabs.css\n')},"../node_modules/css-loader/index.js?!../node_modules/jquery-ui/themes/base/theme.css":function(module,exports,__webpack_require__){eval('var escape = __webpack_require__(/*! ../../../css-loader/lib/url/escape.js */ "../node_modules/css-loader/lib/url/escape.js");\nexports = module.exports = __webpack_require__(/*! ../../../css-loader/lib/css-base.js */ "../node_modules/css-loader/lib/css-base.js")(false);\n// imports\n\n\n// module\nexports.push([module.i, "/*!\\n * jQuery UI CSS Framework 1.13.2\\n * http://jqueryui.com\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license.\\n * http://jquery.org/license\\n *\\n * http://api.jqueryui.com/category/theming/\\n *\\n * To view and modify this theme, visit http://jqueryui.com/themeroller/\\n */\\n\\n\\n/* Component containers\\n----------------------------------*/\\n.ui-widget {\\n\\tfont-family: Arial,Helvetica,sans-serif/*{ffDefault}*/;\\n\\tfont-size: 1em/*{fsDefault}*/;\\n}\\n.ui-widget .ui-widget {\\n\\tfont-size: 1em;\\n}\\n.ui-widget input,\\n.ui-widget select,\\n.ui-widget textarea,\\n.ui-widget button {\\n\\tfont-family: Arial,Helvetica,sans-serif/*{ffDefault}*/;\\n\\tfont-size: 1em;\\n}\\n.ui-widget.ui-widget-content {\\n\\tborder: 1px solid #c5c5c5/*{borderColorDefault}*/;\\n}\\n.ui-widget-content {\\n\\tborder: 1px solid #dddddd/*{borderColorContent}*/;\\n\\tbackground: #ffffff/*{bgColorContent}*/ /*{bgImgUrlContent}*/ /*{bgContentXPos}*/ /*{bgContentYPos}*/ /*{bgContentRepeat}*/;\\n\\tcolor: #333333/*{fcContent}*/;\\n}\\n.ui-widget-content a {\\n\\tcolor: #333333/*{fcContent}*/;\\n}\\n.ui-widget-header {\\n\\tborder: 1px solid #dddddd/*{borderColorHeader}*/;\\n\\tbackground: #e9e9e9/*{bgColorHeader}*/ /*{bgImgUrlHeader}*/ /*{bgHeaderXPos}*/ /*{bgHeaderYPos}*/ /*{bgHeaderRepeat}*/;\\n\\tcolor: #333333/*{fcHeader}*/;\\n\\tfont-weight: bold;\\n}\\n.ui-widget-header a {\\n\\tcolor: #333333/*{fcHeader}*/;\\n}\\n\\n/* Interaction states\\n----------------------------------*/\\n.ui-state-default,\\n.ui-widget-content .ui-state-default,\\n.ui-widget-header .ui-state-default,\\n.ui-button,\\n\\n/* We use html here because we need a greater specificity to make sure disabled\\nworks properly when clicked or hovered */\\nhtml .ui-button.ui-state-disabled:hover,\\nhtml .ui-button.ui-state-disabled:active {\\n\\tborder: 1px solid #c5c5c5/*{borderColorDefault}*/;\\n\\tbackground: #f6f6f6/*{bgColorDefault}*/ /*{bgImgUrlDefault}*/ /*{bgDefaultXPos}*/ /*{bgDefaultYPos}*/ /*{bgDefaultRepeat}*/;\\n\\tfont-weight: normal/*{fwDefault}*/;\\n\\tcolor: #454545/*{fcDefault}*/;\\n}\\n.ui-state-default a,\\n.ui-state-default a:link,\\n.ui-state-default a:visited,\\na.ui-button,\\na:link.ui-button,\\na:visited.ui-button,\\n.ui-button {\\n\\tcolor: #454545/*{fcDefault}*/;\\n\\ttext-decoration: none;\\n}\\n.ui-state-hover,\\n.ui-widget-content .ui-state-hover,\\n.ui-widget-header .ui-state-hover,\\n.ui-state-focus,\\n.ui-widget-content .ui-state-focus,\\n.ui-widget-header .ui-state-focus,\\n.ui-button:hover,\\n.ui-button:focus {\\n\\tborder: 1px solid #cccccc/*{borderColorHover}*/;\\n\\tbackground: #ededed/*{bgColorHover}*/ /*{bgImgUrlHover}*/ /*{bgHoverXPos}*/ /*{bgHoverYPos}*/ /*{bgHoverRepeat}*/;\\n\\tfont-weight: normal/*{fwDefault}*/;\\n\\tcolor: #2b2b2b/*{fcHover}*/;\\n}\\n.ui-state-hover a,\\n.ui-state-hover a:hover,\\n.ui-state-hover a:link,\\n.ui-state-hover a:visited,\\n.ui-state-focus a,\\n.ui-state-focus a:hover,\\n.ui-state-focus a:link,\\n.ui-state-focus a:visited,\\na.ui-button:hover,\\na.ui-button:focus {\\n\\tcolor: #2b2b2b/*{fcHover}*/;\\n\\ttext-decoration: none;\\n}\\n\\n.ui-visual-focus {\\n\\tbox-shadow: 0 0 3px 1px rgb(94, 158, 214);\\n}\\n.ui-state-active,\\n.ui-widget-content .ui-state-active,\\n.ui-widget-header .ui-state-active,\\na.ui-button:active,\\n.ui-button:active,\\n.ui-button.ui-state-active:hover {\\n\\tborder: 1px solid #003eff/*{borderColorActive}*/;\\n\\tbackground: #007fff/*{bgColorActive}*/ /*{bgImgUrlActive}*/ /*{bgActiveXPos}*/ /*{bgActiveYPos}*/ /*{bgActiveRepeat}*/;\\n\\tfont-weight: normal/*{fwDefault}*/;\\n\\tcolor: #ffffff/*{fcActive}*/;\\n}\\n.ui-icon-background,\\n.ui-state-active .ui-icon-background {\\n\\tborder: #003eff/*{borderColorActive}*/;\\n\\tbackground-color: #ffffff/*{fcActive}*/;\\n}\\n.ui-state-active a,\\n.ui-state-active a:link,\\n.ui-state-active a:visited {\\n\\tcolor: #ffffff/*{fcActive}*/;\\n\\ttext-decoration: none;\\n}\\n\\n/* Interaction Cues\\n----------------------------------*/\\n.ui-state-highlight,\\n.ui-widget-content .ui-state-highlight,\\n.ui-widget-header .ui-state-highlight {\\n\\tborder: 1px solid #dad55e/*{borderColorHighlight}*/;\\n\\tbackground: #fffa90/*{bgColorHighlight}*/ /*{bgImgUrlHighlight}*/ /*{bgHighlightXPos}*/ /*{bgHighlightYPos}*/ /*{bgHighlightRepeat}*/;\\n\\tcolor: #777620/*{fcHighlight}*/;\\n}\\n.ui-state-checked {\\n\\tborder: 1px solid #dad55e/*{borderColorHighlight}*/;\\n\\tbackground: #fffa90/*{bgColorHighlight}*/;\\n}\\n.ui-state-highlight a,\\n.ui-widget-content .ui-state-highlight a,\\n.ui-widget-header .ui-state-highlight a {\\n\\tcolor: #777620/*{fcHighlight}*/;\\n}\\n.ui-state-error,\\n.ui-widget-content .ui-state-error,\\n.ui-widget-header .ui-state-error {\\n\\tborder: 1px solid #f1a899/*{borderColorError}*/;\\n\\tbackground: #fddfdf/*{bgColorError}*/ /*{bgImgUrlError}*/ /*{bgErrorXPos}*/ /*{bgErrorYPos}*/ /*{bgErrorRepeat}*/;\\n\\tcolor: #5f3f3f/*{fcError}*/;\\n}\\n.ui-state-error a,\\n.ui-widget-content .ui-state-error a,\\n.ui-widget-header .ui-state-error a {\\n\\tcolor: #5f3f3f/*{fcError}*/;\\n}\\n.ui-state-error-text,\\n.ui-widget-content .ui-state-error-text,\\n.ui-widget-header .ui-state-error-text {\\n\\tcolor: #5f3f3f/*{fcError}*/;\\n}\\n.ui-priority-primary,\\n.ui-widget-content .ui-priority-primary,\\n.ui-widget-header .ui-priority-primary {\\n\\tfont-weight: bold;\\n}\\n.ui-priority-secondary,\\n.ui-widget-content .ui-priority-secondary,\\n.ui-widget-header .ui-priority-secondary {\\n\\topacity: .7;\\n\\t-ms-filter: \\"alpha(opacity=70)\\"; /* support: IE8 */\\n\\tfont-weight: normal;\\n}\\n.ui-state-disabled,\\n.ui-widget-content .ui-state-disabled,\\n.ui-widget-header .ui-state-disabled {\\n\\topacity: .35;\\n\\t-ms-filter: \\"alpha(opacity=35)\\"; /* support: IE8 */\\n\\tbackground-image: none;\\n}\\n.ui-state-disabled .ui-icon {\\n\\t-ms-filter: \\"alpha(opacity=35)\\"; /* support: IE8 - See #6059 */\\n}\\n\\n/* Icons\\n----------------------------------*/\\n\\n/* states and images */\\n.ui-icon {\\n\\twidth: 16px;\\n\\theight: 16px;\\n}\\n.ui-icon,\\n.ui-widget-content .ui-icon {\\n\\tbackground-image: url(" + escape(__webpack_require__(/*! ./images/ui-icons_444444_256x240.png */ "../node_modules/jquery-ui/themes/base/images/ui-icons_444444_256x240.png")) + ");\\n}\\n.ui-widget-header .ui-icon {\\n\\tbackground-image: url(" + escape(__webpack_require__(/*! ./images/ui-icons_444444_256x240.png */ "../node_modules/jquery-ui/themes/base/images/ui-icons_444444_256x240.png")) + ");\\n}\\n.ui-state-hover .ui-icon,\\n.ui-state-focus .ui-icon,\\n.ui-button:hover .ui-icon,\\n.ui-button:focus .ui-icon {\\n\\tbackground-image: url(" + escape(__webpack_require__(/*! ./images/ui-icons_555555_256x240.png */ "../node_modules/jquery-ui/themes/base/images/ui-icons_555555_256x240.png")) + ");\\n}\\n.ui-state-active .ui-icon,\\n.ui-button:active .ui-icon {\\n\\tbackground-image: url(" + escape(__webpack_require__(/*! ./images/ui-icons_ffffff_256x240.png */ "../node_modules/jquery-ui/themes/base/images/ui-icons_ffffff_256x240.png")) + ");\\n}\\n.ui-state-highlight .ui-icon,\\n.ui-button .ui-state-highlight.ui-icon {\\n\\tbackground-image: url(" + escape(__webpack_require__(/*! ./images/ui-icons_777620_256x240.png */ "../node_modules/jquery-ui/themes/base/images/ui-icons_777620_256x240.png")) + ");\\n}\\n.ui-state-error .ui-icon,\\n.ui-state-error-text .ui-icon {\\n\\tbackground-image: url(" + escape(__webpack_require__(/*! ./images/ui-icons_cc0000_256x240.png */ "../node_modules/jquery-ui/themes/base/images/ui-icons_cc0000_256x240.png")) + ");\\n}\\n.ui-button .ui-icon {\\n\\tbackground-image: url(" + escape(__webpack_require__(/*! ./images/ui-icons_777777_256x240.png */ "../node_modules/jquery-ui/themes/base/images/ui-icons_777777_256x240.png")) + ");\\n}\\n\\n/* positioning */\\n/* Three classes needed to override `.ui-button:hover .ui-icon` */\\n.ui-icon-blank.ui-icon-blank.ui-icon-blank {\\n\\tbackground-image: none;\\n}\\n.ui-icon-caret-1-n { background-position: 0 0; }\\n.ui-icon-caret-1-ne { background-position: -16px 0; }\\n.ui-icon-caret-1-e { background-position: -32px 0; }\\n.ui-icon-caret-1-se { background-position: -48px 0; }\\n.ui-icon-caret-1-s { background-position: -65px 0; }\\n.ui-icon-caret-1-sw { background-position: -80px 0; }\\n.ui-icon-caret-1-w { background-position: -96px 0; }\\n.ui-icon-caret-1-nw { background-position: -112px 0; }\\n.ui-icon-caret-2-n-s { background-position: -128px 0; }\\n.ui-icon-caret-2-e-w { background-position: -144px 0; }\\n.ui-icon-triangle-1-n { background-position: 0 -16px; }\\n.ui-icon-triangle-1-ne { background-position: -16px -16px; }\\n.ui-icon-triangle-1-e { background-position: -32px -16px; }\\n.ui-icon-triangle-1-se { background-position: -48px -16px; }\\n.ui-icon-triangle-1-s { background-position: -65px -16px; }\\n.ui-icon-triangle-1-sw { background-position: -80px -16px; }\\n.ui-icon-triangle-1-w { background-position: -96px -16px; }\\n.ui-icon-triangle-1-nw { background-position: -112px -16px; }\\n.ui-icon-triangle-2-n-s { background-position: -128px -16px; }\\n.ui-icon-triangle-2-e-w { background-position: -144px -16px; }\\n.ui-icon-arrow-1-n { background-position: 0 -32px; }\\n.ui-icon-arrow-1-ne { background-position: -16px -32px; }\\n.ui-icon-arrow-1-e { background-position: -32px -32px; }\\n.ui-icon-arrow-1-se { background-position: -48px -32px; }\\n.ui-icon-arrow-1-s { background-position: -65px -32px; }\\n.ui-icon-arrow-1-sw { background-position: -80px -32px; }\\n.ui-icon-arrow-1-w { background-position: -96px -32px; }\\n.ui-icon-arrow-1-nw { background-position: -112px -32px; }\\n.ui-icon-arrow-2-n-s { background-position: -128px -32px; }\\n.ui-icon-arrow-2-ne-sw { background-position: -144px -32px; }\\n.ui-icon-arrow-2-e-w { background-position: -160px -32px; }\\n.ui-icon-arrow-2-se-nw { background-position: -176px -32px; }\\n.ui-icon-arrowstop-1-n { background-position: -192px -32px; }\\n.ui-icon-arrowstop-1-e { background-position: -208px -32px; }\\n.ui-icon-arrowstop-1-s { background-position: -224px -32px; }\\n.ui-icon-arrowstop-1-w { background-position: -240px -32px; }\\n.ui-icon-arrowthick-1-n { background-position: 1px -48px; }\\n.ui-icon-arrowthick-1-ne { background-position: -16px -48px; }\\n.ui-icon-arrowthick-1-e { background-position: -32px -48px; }\\n.ui-icon-arrowthick-1-se { background-position: -48px -48px; }\\n.ui-icon-arrowthick-1-s { background-position: -64px -48px; }\\n.ui-icon-arrowthick-1-sw { background-position: -80px -48px; }\\n.ui-icon-arrowthick-1-w { background-position: -96px -48px; }\\n.ui-icon-arrowthick-1-nw { background-position: -112px -48px; }\\n.ui-icon-arrowthick-2-n-s { background-position: -128px -48px; }\\n.ui-icon-arrowthick-2-ne-sw { background-position: -144px -48px; }\\n.ui-icon-arrowthick-2-e-w { background-position: -160px -48px; }\\n.ui-icon-arrowthick-2-se-nw { background-position: -176px -48px; }\\n.ui-icon-arrowthickstop-1-n { background-position: -192px -48px; }\\n.ui-icon-arrowthickstop-1-e { background-position: -208px -48px; }\\n.ui-icon-arrowthickstop-1-s { background-position: -224px -48px; }\\n.ui-icon-arrowthickstop-1-w { background-position: -240px -48px; }\\n.ui-icon-arrowreturnthick-1-w { background-position: 0 -64px; }\\n.ui-icon-arrowreturnthick-1-n { background-position: -16px -64px; }\\n.ui-icon-arrowreturnthick-1-e { background-position: -32px -64px; }\\n.ui-icon-arrowreturnthick-1-s { background-position: -48px -64px; }\\n.ui-icon-arrowreturn-1-w { background-position: -64px -64px; }\\n.ui-icon-arrowreturn-1-n { background-position: -80px -64px; }\\n.ui-icon-arrowreturn-1-e { background-position: -96px -64px; }\\n.ui-icon-arrowreturn-1-s { background-position: -112px -64px; }\\n.ui-icon-arrowrefresh-1-w { background-position: -128px -64px; }\\n.ui-icon-arrowrefresh-1-n { background-position: -144px -64px; }\\n.ui-icon-arrowrefresh-1-e { background-position: -160px -64px; }\\n.ui-icon-arrowrefresh-1-s { background-position: -176px -64px; }\\n.ui-icon-arrow-4 { background-position: 0 -80px; }\\n.ui-icon-arrow-4-diag { background-position: -16px -80px; }\\n.ui-icon-extlink { background-position: -32px -80px; }\\n.ui-icon-newwin { background-position: -48px -80px; }\\n.ui-icon-refresh { background-position: -64px -80px; }\\n.ui-icon-shuffle { background-position: -80px -80px; }\\n.ui-icon-transfer-e-w { background-position: -96px -80px; }\\n.ui-icon-transferthick-e-w { background-position: -112px -80px; }\\n.ui-icon-folder-collapsed { background-position: 0 -96px; }\\n.ui-icon-folder-open { background-position: -16px -96px; }\\n.ui-icon-document { background-position: -32px -96px; }\\n.ui-icon-document-b { background-position: -48px -96px; }\\n.ui-icon-note { background-position: -64px -96px; }\\n.ui-icon-mail-closed { background-position: -80px -96px; }\\n.ui-icon-mail-open { background-position: -96px -96px; }\\n.ui-icon-suitcase { background-position: -112px -96px; }\\n.ui-icon-comment { background-position: -128px -96px; }\\n.ui-icon-person { background-position: -144px -96px; }\\n.ui-icon-print { background-position: -160px -96px; }\\n.ui-icon-trash { background-position: -176px -96px; }\\n.ui-icon-locked { background-position: -192px -96px; }\\n.ui-icon-unlocked { background-position: -208px -96px; }\\n.ui-icon-bookmark { background-position: -224px -96px; }\\n.ui-icon-tag { background-position: -240px -96px; }\\n.ui-icon-home { background-position: 0 -112px; }\\n.ui-icon-flag { background-position: -16px -112px; }\\n.ui-icon-calendar { background-position: -32px -112px; }\\n.ui-icon-cart { background-position: -48px -112px; }\\n.ui-icon-pencil { background-position: -64px -112px; }\\n.ui-icon-clock { background-position: -80px -112px; }\\n.ui-icon-disk { background-position: -96px -112px; }\\n.ui-icon-calculator { background-position: -112px -112px; }\\n.ui-icon-zoomin { background-position: -128px -112px; }\\n.ui-icon-zoomout { background-position: -144px -112px; }\\n.ui-icon-search { background-position: -160px -112px; }\\n.ui-icon-wrench { background-position: -176px -112px; }\\n.ui-icon-gear { background-position: -192px -112px; }\\n.ui-icon-heart { background-position: -208px -112px; }\\n.ui-icon-star { background-position: -224px -112px; }\\n.ui-icon-link { background-position: -240px -112px; }\\n.ui-icon-cancel { background-position: 0 -128px; }\\n.ui-icon-plus { background-position: -16px -128px; }\\n.ui-icon-plusthick { background-position: -32px -128px; }\\n.ui-icon-minus { background-position: -48px -128px; }\\n.ui-icon-minusthick { background-position: -64px -128px; }\\n.ui-icon-close { background-position: -80px -128px; }\\n.ui-icon-closethick { background-position: -96px -128px; }\\n.ui-icon-key { background-position: -112px -128px; }\\n.ui-icon-lightbulb { background-position: -128px -128px; }\\n.ui-icon-scissors { background-position: -144px -128px; }\\n.ui-icon-clipboard { background-position: -160px -128px; }\\n.ui-icon-copy { background-position: -176px -128px; }\\n.ui-icon-contact { background-position: -192px -128px; }\\n.ui-icon-image { background-position: -208px -128px; }\\n.ui-icon-video { background-position: -224px -128px; }\\n.ui-icon-script { background-position: -240px -128px; }\\n.ui-icon-alert { background-position: 0 -144px; }\\n.ui-icon-info { background-position: -16px -144px; }\\n.ui-icon-notice { background-position: -32px -144px; }\\n.ui-icon-help { background-position: -48px -144px; }\\n.ui-icon-check { background-position: -64px -144px; }\\n.ui-icon-bullet { background-position: -80px -144px; }\\n.ui-icon-radio-on { background-position: -96px -144px; }\\n.ui-icon-radio-off { background-position: -112px -144px; }\\n.ui-icon-pin-w { background-position: -128px -144px; }\\n.ui-icon-pin-s { background-position: -144px -144px; }\\n.ui-icon-play { background-position: 0 -160px; }\\n.ui-icon-pause { background-position: -16px -160px; }\\n.ui-icon-seek-next { background-position: -32px -160px; }\\n.ui-icon-seek-prev { background-position: -48px -160px; }\\n.ui-icon-seek-end { background-position: -64px -160px; }\\n.ui-icon-seek-start { background-position: -80px -160px; }\\n/* ui-icon-seek-first is deprecated, use ui-icon-seek-start instead */\\n.ui-icon-seek-first { background-position: -80px -160px; }\\n.ui-icon-stop { background-position: -96px -160px; }\\n.ui-icon-eject { background-position: -112px -160px; }\\n.ui-icon-volume-off { background-position: -128px -160px; }\\n.ui-icon-volume-on { background-position: -144px -160px; }\\n.ui-icon-power { background-position: 0 -176px; }\\n.ui-icon-signal-diag { background-position: -16px -176px; }\\n.ui-icon-signal { background-position: -32px -176px; }\\n.ui-icon-battery-0 { background-position: -48px -176px; }\\n.ui-icon-battery-1 { background-position: -64px -176px; }\\n.ui-icon-battery-2 { background-position: -80px -176px; }\\n.ui-icon-battery-3 { background-position: -96px -176px; }\\n.ui-icon-circle-plus { background-position: 0 -192px; }\\n.ui-icon-circle-minus { background-position: -16px -192px; }\\n.ui-icon-circle-close { background-position: -32px -192px; }\\n.ui-icon-circle-triangle-e { background-position: -48px -192px; }\\n.ui-icon-circle-triangle-s { background-position: -64px -192px; }\\n.ui-icon-circle-triangle-w { background-position: -80px -192px; }\\n.ui-icon-circle-triangle-n { background-position: -96px -192px; }\\n.ui-icon-circle-arrow-e { background-position: -112px -192px; }\\n.ui-icon-circle-arrow-s { background-position: -128px -192px; }\\n.ui-icon-circle-arrow-w { background-position: -144px -192px; }\\n.ui-icon-circle-arrow-n { background-position: -160px -192px; }\\n.ui-icon-circle-zoomin { background-position: -176px -192px; }\\n.ui-icon-circle-zoomout { background-position: -192px -192px; }\\n.ui-icon-circle-check { background-position: -208px -192px; }\\n.ui-icon-circlesmall-plus { background-position: 0 -208px; }\\n.ui-icon-circlesmall-minus { background-position: -16px -208px; }\\n.ui-icon-circlesmall-close { background-position: -32px -208px; }\\n.ui-icon-squaresmall-plus { background-position: -48px -208px; }\\n.ui-icon-squaresmall-minus { background-position: -64px -208px; }\\n.ui-icon-squaresmall-close { background-position: -80px -208px; }\\n.ui-icon-grip-dotted-vertical { background-position: 0 -224px; }\\n.ui-icon-grip-dotted-horizontal { background-position: -16px -224px; }\\n.ui-icon-grip-solid-vertical { background-position: -32px -224px; }\\n.ui-icon-grip-solid-horizontal { background-position: -48px -224px; }\\n.ui-icon-gripsmall-diagonal-se { background-position: -64px -224px; }\\n.ui-icon-grip-diagonal-se { background-position: -80px -224px; }\\n\\n\\n/* Misc visuals\\n----------------------------------*/\\n\\n/* Corner radius */\\n.ui-corner-all,\\n.ui-corner-top,\\n.ui-corner-left,\\n.ui-corner-tl {\\n\\tborder-top-left-radius: 3px/*{cornerRadius}*/;\\n}\\n.ui-corner-all,\\n.ui-corner-top,\\n.ui-corner-right,\\n.ui-corner-tr {\\n\\tborder-top-right-radius: 3px/*{cornerRadius}*/;\\n}\\n.ui-corner-all,\\n.ui-corner-bottom,\\n.ui-corner-left,\\n.ui-corner-bl {\\n\\tborder-bottom-left-radius: 3px/*{cornerRadius}*/;\\n}\\n.ui-corner-all,\\n.ui-corner-bottom,\\n.ui-corner-right,\\n.ui-corner-br {\\n\\tborder-bottom-right-radius: 3px/*{cornerRadius}*/;\\n}\\n\\n/* Overlays */\\n.ui-widget-overlay {\\n\\tbackground: #aaaaaa/*{bgColorOverlay}*/ /*{bgImgUrlOverlay}*/ /*{bgOverlayXPos}*/ /*{bgOverlayYPos}*/ /*{bgOverlayRepeat}*/;\\n\\topacity: .3/*{opacityOverlay}*/;\\n\\t-ms-filter: \\"alpha(opacity=30)\\"/*{opacityFilterOverlay}*/; /* support: IE8 */\\n}\\n.ui-widget-shadow {\\n\\t-webkit-box-shadow: 0/*{offsetLeftShadow}*/ 0/*{offsetTopShadow}*/ 5px/*{thicknessShadow}*/ #666666/*{bgColorShadow}*/;\\n\\tbox-shadow: 0/*{offsetLeftShadow}*/ 0/*{offsetTopShadow}*/ 5px/*{thicknessShadow}*/ #666666/*{bgColorShadow}*/;\\n}\\n", ""]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/IS4uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdGhlbWVzL2Jhc2UvdGhlbWUuY3NzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdGhlbWVzL2Jhc2UvdGhlbWUuY3NzPzU5MzIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGVzY2FwZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi91cmwvZXNjYXBlLmpzXCIpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIVxcbiAqIGpRdWVyeSBVSSBDU1MgRnJhbWV3b3JrIDEuMTMuMlxcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gKlxcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gKlxcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2NhdGVnb3J5L3RoZW1pbmcvXFxuICpcXG4gKiBUbyB2aWV3IGFuZCBtb2RpZnkgdGhpcyB0aGVtZSwgdmlzaXQgaHR0cDovL2pxdWVyeXVpLmNvbS90aGVtZXJvbGxlci9cXG4gKi9cXG5cXG5cXG4vKiBDb21wb25lbnQgY29udGFpbmVyc1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi51aS13aWRnZXQge1xcblxcdGZvbnQtZmFtaWx5OiBBcmlhbCxIZWx2ZXRpY2Esc2Fucy1zZXJpZi8qe2ZmRGVmYXVsdH0qLztcXG5cXHRmb250LXNpemU6IDFlbS8qe2ZzRGVmYXVsdH0qLztcXG59XFxuLnVpLXdpZGdldCAudWktd2lkZ2V0IHtcXG5cXHRmb250LXNpemU6IDFlbTtcXG59XFxuLnVpLXdpZGdldCBpbnB1dCxcXG4udWktd2lkZ2V0IHNlbGVjdCxcXG4udWktd2lkZ2V0IHRleHRhcmVhLFxcbi51aS13aWRnZXQgYnV0dG9uIHtcXG5cXHRmb250LWZhbWlseTogQXJpYWwsSGVsdmV0aWNhLHNhbnMtc2VyaWYvKntmZkRlZmF1bHR9Ki87XFxuXFx0Zm9udC1zaXplOiAxZW07XFxufVxcbi51aS13aWRnZXQudWktd2lkZ2V0LWNvbnRlbnQge1xcblxcdGJvcmRlcjogMXB4IHNvbGlkICNjNWM1YzUvKntib3JkZXJDb2xvckRlZmF1bHR9Ki87XFxufVxcbi51aS13aWRnZXQtY29udGVudCB7XFxuXFx0Ym9yZGVyOiAxcHggc29saWQgI2RkZGRkZC8qe2JvcmRlckNvbG9yQ29udGVudH0qLztcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmZmZmLyp7YmdDb2xvckNvbnRlbnR9Ki8gLyp7YmdJbWdVcmxDb250ZW50fSovIC8qe2JnQ29udGVudFhQb3N9Ki8gLyp7YmdDb250ZW50WVBvc30qLyAvKntiZ0NvbnRlbnRSZXBlYXR9Ki87XFxuXFx0Y29sb3I6ICMzMzMzMzMvKntmY0NvbnRlbnR9Ki87XFxufVxcbi51aS13aWRnZXQtY29udGVudCBhIHtcXG5cXHRjb2xvcjogIzMzMzMzMy8qe2ZjQ29udGVudH0qLztcXG59XFxuLnVpLXdpZGdldC1oZWFkZXIge1xcblxcdGJvcmRlcjogMXB4IHNvbGlkICNkZGRkZGQvKntib3JkZXJDb2xvckhlYWRlcn0qLztcXG5cXHRiYWNrZ3JvdW5kOiAjZTllOWU5Lyp7YmdDb2xvckhlYWRlcn0qLyAvKntiZ0ltZ1VybEhlYWRlcn0qLyAvKntiZ0hlYWRlclhQb3N9Ki8gLyp7YmdIZWFkZXJZUG9zfSovIC8qe2JnSGVhZGVyUmVwZWF0fSovO1xcblxcdGNvbG9yOiAjMzMzMzMzLyp7ZmNIZWFkZXJ9Ki87XFxuXFx0Zm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcbi51aS13aWRnZXQtaGVhZGVyIGEge1xcblxcdGNvbG9yOiAjMzMzMzMzLyp7ZmNIZWFkZXJ9Ki87XFxufVxcblxcbi8qIEludGVyYWN0aW9uIHN0YXRlc1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi51aS1zdGF0ZS1kZWZhdWx0LFxcbi51aS13aWRnZXQtY29udGVudCAudWktc3RhdGUtZGVmYXVsdCxcXG4udWktd2lkZ2V0LWhlYWRlciAudWktc3RhdGUtZGVmYXVsdCxcXG4udWktYnV0dG9uLFxcblxcbi8qIFdlIHVzZSBodG1sIGhlcmUgYmVjYXVzZSB3ZSBuZWVkIGEgZ3JlYXRlciBzcGVjaWZpY2l0eSB0byBtYWtlIHN1cmUgZGlzYWJsZWRcXG53b3JrcyBwcm9wZXJseSB3aGVuIGNsaWNrZWQgb3IgaG92ZXJlZCAqL1xcbmh0bWwgLnVpLWJ1dHRvbi51aS1zdGF0ZS1kaXNhYmxlZDpob3ZlcixcXG5odG1sIC51aS1idXR0b24udWktc3RhdGUtZGlzYWJsZWQ6YWN0aXZlIHtcXG5cXHRib3JkZXI6IDFweCBzb2xpZCAjYzVjNWM1Lyp7Ym9yZGVyQ29sb3JEZWZhdWx0fSovO1xcblxcdGJhY2tncm91bmQ6ICNmNmY2ZjYvKntiZ0NvbG9yRGVmYXVsdH0qLyAvKntiZ0ltZ1VybERlZmF1bHR9Ki8gLyp7YmdEZWZhdWx0WFBvc30qLyAvKntiZ0RlZmF1bHRZUG9zfSovIC8qe2JnRGVmYXVsdFJlcGVhdH0qLztcXG5cXHRmb250LXdlaWdodDogbm9ybWFsLyp7ZndEZWZhdWx0fSovO1xcblxcdGNvbG9yOiAjNDU0NTQ1Lyp7ZmNEZWZhdWx0fSovO1xcbn1cXG4udWktc3RhdGUtZGVmYXVsdCBhLFxcbi51aS1zdGF0ZS1kZWZhdWx0IGE6bGluayxcXG4udWktc3RhdGUtZGVmYXVsdCBhOnZpc2l0ZWQsXFxuYS51aS1idXR0b24sXFxuYTpsaW5rLnVpLWJ1dHRvbixcXG5hOnZpc2l0ZWQudWktYnV0dG9uLFxcbi51aS1idXR0b24ge1xcblxcdGNvbG9yOiAjNDU0NTQ1Lyp7ZmNEZWZhdWx0fSovO1xcblxcdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuLnVpLXN0YXRlLWhvdmVyLFxcbi51aS13aWRnZXQtY29udGVudCAudWktc3RhdGUtaG92ZXIsXFxuLnVpLXdpZGdldC1oZWFkZXIgLnVpLXN0YXRlLWhvdmVyLFxcbi51aS1zdGF0ZS1mb2N1cyxcXG4udWktd2lkZ2V0LWNvbnRlbnQgLnVpLXN0YXRlLWZvY3VzLFxcbi51aS13aWRnZXQtaGVhZGVyIC51aS1zdGF0ZS1mb2N1cyxcXG4udWktYnV0dG9uOmhvdmVyLFxcbi51aS1idXR0b246Zm9jdXMge1xcblxcdGJvcmRlcjogMXB4IHNvbGlkICNjY2NjY2MvKntib3JkZXJDb2xvckhvdmVyfSovO1xcblxcdGJhY2tncm91bmQ6ICNlZGVkZWQvKntiZ0NvbG9ySG92ZXJ9Ki8gLyp7YmdJbWdVcmxIb3Zlcn0qLyAvKntiZ0hvdmVyWFBvc30qLyAvKntiZ0hvdmVyWVBvc30qLyAvKntiZ0hvdmVyUmVwZWF0fSovO1xcblxcdGZvbnQtd2VpZ2h0OiBub3JtYWwvKntmd0RlZmF1bHR9Ki87XFxuXFx0Y29sb3I6ICMyYjJiMmIvKntmY0hvdmVyfSovO1xcbn1cXG4udWktc3RhdGUtaG92ZXIgYSxcXG4udWktc3RhdGUtaG92ZXIgYTpob3ZlcixcXG4udWktc3RhdGUtaG92ZXIgYTpsaW5rLFxcbi51aS1zdGF0ZS1ob3ZlciBhOnZpc2l0ZWQsXFxuLnVpLXN0YXRlLWZvY3VzIGEsXFxuLnVpLXN0YXRlLWZvY3VzIGE6aG92ZXIsXFxuLnVpLXN0YXRlLWZvY3VzIGE6bGluayxcXG4udWktc3RhdGUtZm9jdXMgYTp2aXNpdGVkLFxcbmEudWktYnV0dG9uOmhvdmVyLFxcbmEudWktYnV0dG9uOmZvY3VzIHtcXG5cXHRjb2xvcjogIzJiMmIyYi8qe2ZjSG92ZXJ9Ki87XFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbn1cXG5cXG4udWktdmlzdWFsLWZvY3VzIHtcXG5cXHRib3gtc2hhZG93OiAwIDAgM3B4IDFweCByZ2IoOTQsIDE1OCwgMjE0KTtcXG59XFxuLnVpLXN0YXRlLWFjdGl2ZSxcXG4udWktd2lkZ2V0LWNvbnRlbnQgLnVpLXN0YXRlLWFjdGl2ZSxcXG4udWktd2lkZ2V0LWhlYWRlciAudWktc3RhdGUtYWN0aXZlLFxcbmEudWktYnV0dG9uOmFjdGl2ZSxcXG4udWktYnV0dG9uOmFjdGl2ZSxcXG4udWktYnV0dG9uLnVpLXN0YXRlLWFjdGl2ZTpob3ZlciB7XFxuXFx0Ym9yZGVyOiAxcHggc29saWQgIzAwM2VmZi8qe2JvcmRlckNvbG9yQWN0aXZlfSovO1xcblxcdGJhY2tncm91bmQ6ICMwMDdmZmYvKntiZ0NvbG9yQWN0aXZlfSovIC8qe2JnSW1nVXJsQWN0aXZlfSovIC8qe2JnQWN0aXZlWFBvc30qLyAvKntiZ0FjdGl2ZVlQb3N9Ki8gLyp7YmdBY3RpdmVSZXBlYXR9Ki87XFxuXFx0Zm9udC13ZWlnaHQ6IG5vcm1hbC8qe2Z3RGVmYXVsdH0qLztcXG5cXHRjb2xvcjogI2ZmZmZmZi8qe2ZjQWN0aXZlfSovO1xcbn1cXG4udWktaWNvbi1iYWNrZ3JvdW5kLFxcbi51aS1zdGF0ZS1hY3RpdmUgLnVpLWljb24tYmFja2dyb3VuZCB7XFxuXFx0Ym9yZGVyOiAjMDAzZWZmLyp7Ym9yZGVyQ29sb3JBY3RpdmV9Ki87XFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZi8qe2ZjQWN0aXZlfSovO1xcbn1cXG4udWktc3RhdGUtYWN0aXZlIGEsXFxuLnVpLXN0YXRlLWFjdGl2ZSBhOmxpbmssXFxuLnVpLXN0YXRlLWFjdGl2ZSBhOnZpc2l0ZWQge1xcblxcdGNvbG9yOiAjZmZmZmZmLyp7ZmNBY3RpdmV9Ki87XFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbn1cXG5cXG4vKiBJbnRlcmFjdGlvbiBDdWVzXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLnVpLXN0YXRlLWhpZ2hsaWdodCxcXG4udWktd2lkZ2V0LWNvbnRlbnQgLnVpLXN0YXRlLWhpZ2hsaWdodCxcXG4udWktd2lkZ2V0LWhlYWRlciAudWktc3RhdGUtaGlnaGxpZ2h0IHtcXG5cXHRib3JkZXI6IDFweCBzb2xpZCAjZGFkNTVlLyp7Ym9yZGVyQ29sb3JIaWdobGlnaHR9Ki87XFxuXFx0YmFja2dyb3VuZDogI2ZmZmE5MC8qe2JnQ29sb3JIaWdobGlnaHR9Ki8gLyp7YmdJbWdVcmxIaWdobGlnaHR9Ki8gLyp7YmdIaWdobGlnaHRYUG9zfSovIC8qe2JnSGlnaGxpZ2h0WVBvc30qLyAvKntiZ0hpZ2hsaWdodFJlcGVhdH0qLztcXG5cXHRjb2xvcjogIzc3NzYyMC8qe2ZjSGlnaGxpZ2h0fSovO1xcbn1cXG4udWktc3RhdGUtY2hlY2tlZCB7XFxuXFx0Ym9yZGVyOiAxcHggc29saWQgI2RhZDU1ZS8qe2JvcmRlckNvbG9ySGlnaGxpZ2h0fSovO1xcblxcdGJhY2tncm91bmQ6ICNmZmZhOTAvKntiZ0NvbG9ySGlnaGxpZ2h0fSovO1xcbn1cXG4udWktc3RhdGUtaGlnaGxpZ2h0IGEsXFxuLnVpLXdpZGdldC1jb250ZW50IC51aS1zdGF0ZS1oaWdobGlnaHQgYSxcXG4udWktd2lkZ2V0LWhlYWRlciAudWktc3RhdGUtaGlnaGxpZ2h0IGEge1xcblxcdGNvbG9yOiAjNzc3NjIwLyp7ZmNIaWdobGlnaHR9Ki87XFxufVxcbi51aS1zdGF0ZS1lcnJvcixcXG4udWktd2lkZ2V0LWNvbnRlbnQgLnVpLXN0YXRlLWVycm9yLFxcbi51aS13aWRnZXQtaGVhZGVyIC51aS1zdGF0ZS1lcnJvciB7XFxuXFx0Ym9yZGVyOiAxcHggc29saWQgI2YxYTg5OS8qe2JvcmRlckNvbG9yRXJyb3J9Ki87XFxuXFx0YmFja2dyb3VuZDogI2ZkZGZkZi8qe2JnQ29sb3JFcnJvcn0qLyAvKntiZ0ltZ1VybEVycm9yfSovIC8qe2JnRXJyb3JYUG9zfSovIC8qe2JnRXJyb3JZUG9zfSovIC8qe2JnRXJyb3JSZXBlYXR9Ki87XFxuXFx0Y29sb3I6ICM1ZjNmM2YvKntmY0Vycm9yfSovO1xcbn1cXG4udWktc3RhdGUtZXJyb3IgYSxcXG4udWktd2lkZ2V0LWNvbnRlbnQgLnVpLXN0YXRlLWVycm9yIGEsXFxuLnVpLXdpZGdldC1oZWFkZXIgLnVpLXN0YXRlLWVycm9yIGEge1xcblxcdGNvbG9yOiAjNWYzZjNmLyp7ZmNFcnJvcn0qLztcXG59XFxuLnVpLXN0YXRlLWVycm9yLXRleHQsXFxuLnVpLXdpZGdldC1jb250ZW50IC51aS1zdGF0ZS1lcnJvci10ZXh0LFxcbi51aS13aWRnZXQtaGVhZGVyIC51aS1zdGF0ZS1lcnJvci10ZXh0IHtcXG5cXHRjb2xvcjogIzVmM2YzZi8qe2ZjRXJyb3J9Ki87XFxufVxcbi51aS1wcmlvcml0eS1wcmltYXJ5LFxcbi51aS13aWRnZXQtY29udGVudCAudWktcHJpb3JpdHktcHJpbWFyeSxcXG4udWktd2lkZ2V0LWhlYWRlciAudWktcHJpb3JpdHktcHJpbWFyeSB7XFxuXFx0Zm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcbi51aS1wcmlvcml0eS1zZWNvbmRhcnksXFxuLnVpLXdpZGdldC1jb250ZW50IC51aS1wcmlvcml0eS1zZWNvbmRhcnksXFxuLnVpLXdpZGdldC1oZWFkZXIgLnVpLXByaW9yaXR5LXNlY29uZGFyeSB7XFxuXFx0b3BhY2l0eTogLjc7XFxuXFx0LW1zLWZpbHRlcjogXFxcImFscGhhKG9wYWNpdHk9NzApXFxcIjsgLyogc3VwcG9ydDogSUU4ICovXFxuXFx0Zm9udC13ZWlnaHQ6IG5vcm1hbDtcXG59XFxuLnVpLXN0YXRlLWRpc2FibGVkLFxcbi51aS13aWRnZXQtY29udGVudCAudWktc3RhdGUtZGlzYWJsZWQsXFxuLnVpLXdpZGdldC1oZWFkZXIgLnVpLXN0YXRlLWRpc2FibGVkIHtcXG5cXHRvcGFjaXR5OiAuMzU7XFxuXFx0LW1zLWZpbHRlcjogXFxcImFscGhhKG9wYWNpdHk9MzUpXFxcIjsgLyogc3VwcG9ydDogSUU4ICovXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogbm9uZTtcXG59XFxuLnVpLXN0YXRlLWRpc2FibGVkIC51aS1pY29uIHtcXG5cXHQtbXMtZmlsdGVyOiBcXFwiYWxwaGEob3BhY2l0eT0zNSlcXFwiOyAvKiBzdXBwb3J0OiBJRTggLSBTZWUgIzYwNTkgKi9cXG59XFxuXFxuLyogSWNvbnNcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG4vKiBzdGF0ZXMgYW5kIGltYWdlcyAqL1xcbi51aS1pY29uIHtcXG5cXHR3aWR0aDogMTZweDtcXG5cXHRoZWlnaHQ6IDE2cHg7XFxufVxcbi51aS1pY29uLFxcbi51aS13aWRnZXQtY29udGVudCAudWktaWNvbiB7XFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuL2ltYWdlcy91aS1pY29uc180NDQ0NDRfMjU2eDI0MC5wbmdcIikpICsgXCIpO1xcbn1cXG4udWktd2lkZ2V0LWhlYWRlciAudWktaWNvbiB7XFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuL2ltYWdlcy91aS1pY29uc180NDQ0NDRfMjU2eDI0MC5wbmdcIikpICsgXCIpO1xcbn1cXG4udWktc3RhdGUtaG92ZXIgLnVpLWljb24sXFxuLnVpLXN0YXRlLWZvY3VzIC51aS1pY29uLFxcbi51aS1idXR0b246aG92ZXIgLnVpLWljb24sXFxuLnVpLWJ1dHRvbjpmb2N1cyAudWktaWNvbiB7XFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuL2ltYWdlcy91aS1pY29uc181NTU1NTVfMjU2eDI0MC5wbmdcIikpICsgXCIpO1xcbn1cXG4udWktc3RhdGUtYWN0aXZlIC51aS1pY29uLFxcbi51aS1idXR0b246YWN0aXZlIC51aS1pY29uIHtcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4vaW1hZ2VzL3VpLWljb25zX2ZmZmZmZl8yNTZ4MjQwLnBuZ1wiKSkgKyBcIik7XFxufVxcbi51aS1zdGF0ZS1oaWdobGlnaHQgLnVpLWljb24sXFxuLnVpLWJ1dHRvbiAudWktc3RhdGUtaGlnaGxpZ2h0LnVpLWljb24ge1xcblxcdGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi9pbWFnZXMvdWktaWNvbnNfNzc3NjIwXzI1NngyNDAucG5nXCIpKSArIFwiKTtcXG59XFxuLnVpLXN0YXRlLWVycm9yIC51aS1pY29uLFxcbi51aS1zdGF0ZS1lcnJvci10ZXh0IC51aS1pY29uIHtcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4vaW1hZ2VzL3VpLWljb25zX2NjMDAwMF8yNTZ4MjQwLnBuZ1wiKSkgKyBcIik7XFxufVxcbi51aS1idXR0b24gLnVpLWljb24ge1xcblxcdGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi9pbWFnZXMvdWktaWNvbnNfNzc3Nzc3XzI1NngyNDAucG5nXCIpKSArIFwiKTtcXG59XFxuXFxuLyogcG9zaXRpb25pbmcgKi9cXG4vKiBUaHJlZSBjbGFzc2VzIG5lZWRlZCB0byBvdmVycmlkZSBgLnVpLWJ1dHRvbjpob3ZlciAudWktaWNvbmAgKi9cXG4udWktaWNvbi1ibGFuay51aS1pY29uLWJsYW5rLnVpLWljb24tYmxhbmsge1xcblxcdGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7XFxufVxcbi51aS1pY29uLWNhcmV0LTEtbiB7IGJhY2tncm91bmQtcG9zaXRpb246IDAgMDsgfVxcbi51aS1pY29uLWNhcmV0LTEtbmUgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTZweCAwOyB9XFxuLnVpLWljb24tY2FyZXQtMS1lIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTMycHggMDsgfVxcbi51aS1pY29uLWNhcmV0LTEtc2UgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNDhweCAwOyB9XFxuLnVpLWljb24tY2FyZXQtMS1zIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTY1cHggMDsgfVxcbi51aS1pY29uLWNhcmV0LTEtc3cgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtODBweCAwOyB9XFxuLnVpLWljb24tY2FyZXQtMS13IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTk2cHggMDsgfVxcbi51aS1pY29uLWNhcmV0LTEtbncgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTEycHggMDsgfVxcbi51aS1pY29uLWNhcmV0LTItbi1zIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTEyOHB4IDA7IH1cXG4udWktaWNvbi1jYXJldC0yLWUtdyB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xNDRweCAwOyB9XFxuLnVpLWljb24tdHJpYW5nbGUtMS1uIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogMCAtMTZweDsgfVxcbi51aS1pY29uLXRyaWFuZ2xlLTEtbmUgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTZweCAtMTZweDsgfVxcbi51aS1pY29uLXRyaWFuZ2xlLTEtZSB7IGJhY2tncm91bmQtcG9zaXRpb246IC0zMnB4IC0xNnB4OyB9XFxuLnVpLWljb24tdHJpYW5nbGUtMS1zZSB7IGJhY2tncm91bmQtcG9zaXRpb246IC00OHB4IC0xNnB4OyB9XFxuLnVpLWljb24tdHJpYW5nbGUtMS1zIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTY1cHggLTE2cHg7IH1cXG4udWktaWNvbi10cmlhbmdsZS0xLXN3IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTgwcHggLTE2cHg7IH1cXG4udWktaWNvbi10cmlhbmdsZS0xLXcgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtOTZweCAtMTZweDsgfVxcbi51aS1pY29uLXRyaWFuZ2xlLTEtbncgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTEycHggLTE2cHg7IH1cXG4udWktaWNvbi10cmlhbmdsZS0yLW4tcyB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xMjhweCAtMTZweDsgfVxcbi51aS1pY29uLXRyaWFuZ2xlLTItZS13IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTE0NHB4IC0xNnB4OyB9XFxuLnVpLWljb24tYXJyb3ctMS1uIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogMCAtMzJweDsgfVxcbi51aS1pY29uLWFycm93LTEtbmUgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTZweCAtMzJweDsgfVxcbi51aS1pY29uLWFycm93LTEtZSB7IGJhY2tncm91bmQtcG9zaXRpb246IC0zMnB4IC0zMnB4OyB9XFxuLnVpLWljb24tYXJyb3ctMS1zZSB7IGJhY2tncm91bmQtcG9zaXRpb246IC00OHB4IC0zMnB4OyB9XFxuLnVpLWljb24tYXJyb3ctMS1zIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTY1cHggLTMycHg7IH1cXG4udWktaWNvbi1hcnJvdy0xLXN3IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTgwcHggLTMycHg7IH1cXG4udWktaWNvbi1hcnJvdy0xLXcgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtOTZweCAtMzJweDsgfVxcbi51aS1pY29uLWFycm93LTEtbncgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTEycHggLTMycHg7IH1cXG4udWktaWNvbi1hcnJvdy0yLW4tcyB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xMjhweCAtMzJweDsgfVxcbi51aS1pY29uLWFycm93LTItbmUtc3cgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTQ0cHggLTMycHg7IH1cXG4udWktaWNvbi1hcnJvdy0yLWUtdyB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xNjBweCAtMzJweDsgfVxcbi51aS1pY29uLWFycm93LTItc2UtbncgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTc2cHggLTMycHg7IH1cXG4udWktaWNvbi1hcnJvd3N0b3AtMS1uIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTE5MnB4IC0zMnB4OyB9XFxuLnVpLWljb24tYXJyb3dzdG9wLTEtZSB7IGJhY2tncm91bmQtcG9zaXRpb246IC0yMDhweCAtMzJweDsgfVxcbi51aS1pY29uLWFycm93c3RvcC0xLXMgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMjI0cHggLTMycHg7IH1cXG4udWktaWNvbi1hcnJvd3N0b3AtMS13IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTI0MHB4IC0zMnB4OyB9XFxuLnVpLWljb24tYXJyb3d0aGljay0xLW4geyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAxcHggLTQ4cHg7IH1cXG4udWktaWNvbi1hcnJvd3RoaWNrLTEtbmUgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTZweCAtNDhweDsgfVxcbi51aS1pY29uLWFycm93dGhpY2stMS1lIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTMycHggLTQ4cHg7IH1cXG4udWktaWNvbi1hcnJvd3RoaWNrLTEtc2UgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNDhweCAtNDhweDsgfVxcbi51aS1pY29uLWFycm93dGhpY2stMS1zIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTY0cHggLTQ4cHg7IH1cXG4udWktaWNvbi1hcnJvd3RoaWNrLTEtc3cgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtODBweCAtNDhweDsgfVxcbi51aS1pY29uLWFycm93dGhpY2stMS13IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTk2cHggLTQ4cHg7IH1cXG4udWktaWNvbi1hcnJvd3RoaWNrLTEtbncgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTEycHggLTQ4cHg7IH1cXG4udWktaWNvbi1hcnJvd3RoaWNrLTItbi1zIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTEyOHB4IC00OHB4OyB9XFxuLnVpLWljb24tYXJyb3d0aGljay0yLW5lLXN3IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTE0NHB4IC00OHB4OyB9XFxuLnVpLWljb24tYXJyb3d0aGljay0yLWUtdyB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xNjBweCAtNDhweDsgfVxcbi51aS1pY29uLWFycm93dGhpY2stMi1zZS1udyB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xNzZweCAtNDhweDsgfVxcbi51aS1pY29uLWFycm93dGhpY2tzdG9wLTEtbiB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xOTJweCAtNDhweDsgfVxcbi51aS1pY29uLWFycm93dGhpY2tzdG9wLTEtZSB7IGJhY2tncm91bmQtcG9zaXRpb246IC0yMDhweCAtNDhweDsgfVxcbi51aS1pY29uLWFycm93dGhpY2tzdG9wLTEtcyB7IGJhY2tncm91bmQtcG9zaXRpb246IC0yMjRweCAtNDhweDsgfVxcbi51aS1pY29uLWFycm93dGhpY2tzdG9wLTEtdyB7IGJhY2tncm91bmQtcG9zaXRpb246IC0yNDBweCAtNDhweDsgfVxcbi51aS1pY29uLWFycm93cmV0dXJudGhpY2stMS13IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogMCAtNjRweDsgfVxcbi51aS1pY29uLWFycm93cmV0dXJudGhpY2stMS1uIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTE2cHggLTY0cHg7IH1cXG4udWktaWNvbi1hcnJvd3JldHVybnRoaWNrLTEtZSB7IGJhY2tncm91bmQtcG9zaXRpb246IC0zMnB4IC02NHB4OyB9XFxuLnVpLWljb24tYXJyb3dyZXR1cm50aGljay0xLXMgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNDhweCAtNjRweDsgfVxcbi51aS1pY29uLWFycm93cmV0dXJuLTEtdyB7IGJhY2tncm91bmQtcG9zaXRpb246IC02NHB4IC02NHB4OyB9XFxuLnVpLWljb24tYXJyb3dyZXR1cm4tMS1uIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTgwcHggLTY0cHg7IH1cXG4udWktaWNvbi1hcnJvd3JldHVybi0xLWUgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtOTZweCAtNjRweDsgfVxcbi51aS1pY29uLWFycm93cmV0dXJuLTEtcyB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xMTJweCAtNjRweDsgfVxcbi51aS1pY29uLWFycm93cmVmcmVzaC0xLXcgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTI4cHggLTY0cHg7IH1cXG4udWktaWNvbi1hcnJvd3JlZnJlc2gtMS1uIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTE0NHB4IC02NHB4OyB9XFxuLnVpLWljb24tYXJyb3dyZWZyZXNoLTEtZSB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xNjBweCAtNjRweDsgfVxcbi51aS1pY29uLWFycm93cmVmcmVzaC0xLXMgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTc2cHggLTY0cHg7IH1cXG4udWktaWNvbi1hcnJvdy00IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogMCAtODBweDsgfVxcbi51aS1pY29uLWFycm93LTQtZGlhZyB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xNnB4IC04MHB4OyB9XFxuLnVpLWljb24tZXh0bGluayB7IGJhY2tncm91bmQtcG9zaXRpb246IC0zMnB4IC04MHB4OyB9XFxuLnVpLWljb24tbmV3d2luIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTQ4cHggLTgwcHg7IH1cXG4udWktaWNvbi1yZWZyZXNoIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTY0cHggLTgwcHg7IH1cXG4udWktaWNvbi1zaHVmZmxlIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTgwcHggLTgwcHg7IH1cXG4udWktaWNvbi10cmFuc2Zlci1lLXcgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtOTZweCAtODBweDsgfVxcbi51aS1pY29uLXRyYW5zZmVydGhpY2stZS13IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTExMnB4IC04MHB4OyB9XFxuLnVpLWljb24tZm9sZGVyLWNvbGxhcHNlZCB7IGJhY2tncm91bmQtcG9zaXRpb246IDAgLTk2cHg7IH1cXG4udWktaWNvbi1mb2xkZXItb3BlbiB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xNnB4IC05NnB4OyB9XFxuLnVpLWljb24tZG9jdW1lbnQgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMzJweCAtOTZweDsgfVxcbi51aS1pY29uLWRvY3VtZW50LWIgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNDhweCAtOTZweDsgfVxcbi51aS1pY29uLW5vdGUgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNjRweCAtOTZweDsgfVxcbi51aS1pY29uLW1haWwtY2xvc2VkIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTgwcHggLTk2cHg7IH1cXG4udWktaWNvbi1tYWlsLW9wZW4geyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtOTZweCAtOTZweDsgfVxcbi51aS1pY29uLXN1aXRjYXNlIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTExMnB4IC05NnB4OyB9XFxuLnVpLWljb24tY29tbWVudCB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xMjhweCAtOTZweDsgfVxcbi51aS1pY29uLXBlcnNvbiB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xNDRweCAtOTZweDsgfVxcbi51aS1pY29uLXByaW50IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTE2MHB4IC05NnB4OyB9XFxuLnVpLWljb24tdHJhc2ggeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTc2cHggLTk2cHg7IH1cXG4udWktaWNvbi1sb2NrZWQgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTkycHggLTk2cHg7IH1cXG4udWktaWNvbi11bmxvY2tlZCB7IGJhY2tncm91bmQtcG9zaXRpb246IC0yMDhweCAtOTZweDsgfVxcbi51aS1pY29uLWJvb2ttYXJrIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTIyNHB4IC05NnB4OyB9XFxuLnVpLWljb24tdGFnIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTI0MHB4IC05NnB4OyB9XFxuLnVpLWljb24taG9tZSB7IGJhY2tncm91bmQtcG9zaXRpb246IDAgLTExMnB4OyB9XFxuLnVpLWljb24tZmxhZyB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xNnB4IC0xMTJweDsgfVxcbi51aS1pY29uLWNhbGVuZGFyIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTMycHggLTExMnB4OyB9XFxuLnVpLWljb24tY2FydCB7IGJhY2tncm91bmQtcG9zaXRpb246IC00OHB4IC0xMTJweDsgfVxcbi51aS1pY29uLXBlbmNpbCB7IGJhY2tncm91bmQtcG9zaXRpb246IC02NHB4IC0xMTJweDsgfVxcbi51aS1pY29uLWNsb2NrIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTgwcHggLTExMnB4OyB9XFxuLnVpLWljb24tZGlzayB7IGJhY2tncm91bmQtcG9zaXRpb246IC05NnB4IC0xMTJweDsgfVxcbi51aS1pY29uLWNhbGN1bGF0b3IgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTEycHggLTExMnB4OyB9XFxuLnVpLWljb24tem9vbWluIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTEyOHB4IC0xMTJweDsgfVxcbi51aS1pY29uLXpvb21vdXQgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTQ0cHggLTExMnB4OyB9XFxuLnVpLWljb24tc2VhcmNoIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTE2MHB4IC0xMTJweDsgfVxcbi51aS1pY29uLXdyZW5jaCB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xNzZweCAtMTEycHg7IH1cXG4udWktaWNvbi1nZWFyIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTE5MnB4IC0xMTJweDsgfVxcbi51aS1pY29uLWhlYXJ0IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTIwOHB4IC0xMTJweDsgfVxcbi51aS1pY29uLXN0YXIgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMjI0cHggLTExMnB4OyB9XFxuLnVpLWljb24tbGluayB7IGJhY2tncm91bmQtcG9zaXRpb246IC0yNDBweCAtMTEycHg7IH1cXG4udWktaWNvbi1jYW5jZWwgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwIC0xMjhweDsgfVxcbi51aS1pY29uLXBsdXMgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTZweCAtMTI4cHg7IH1cXG4udWktaWNvbi1wbHVzdGhpY2sgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMzJweCAtMTI4cHg7IH1cXG4udWktaWNvbi1taW51cyB7IGJhY2tncm91bmQtcG9zaXRpb246IC00OHB4IC0xMjhweDsgfVxcbi51aS1pY29uLW1pbnVzdGhpY2sgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNjRweCAtMTI4cHg7IH1cXG4udWktaWNvbi1jbG9zZSB7IGJhY2tncm91bmQtcG9zaXRpb246IC04MHB4IC0xMjhweDsgfVxcbi51aS1pY29uLWNsb3NldGhpY2sgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtOTZweCAtMTI4cHg7IH1cXG4udWktaWNvbi1rZXkgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTEycHggLTEyOHB4OyB9XFxuLnVpLWljb24tbGlnaHRidWxiIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTEyOHB4IC0xMjhweDsgfVxcbi51aS1pY29uLXNjaXNzb3JzIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTE0NHB4IC0xMjhweDsgfVxcbi51aS1pY29uLWNsaXBib2FyZCB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xNjBweCAtMTI4cHg7IH1cXG4udWktaWNvbi1jb3B5IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTE3NnB4IC0xMjhweDsgfVxcbi51aS1pY29uLWNvbnRhY3QgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTkycHggLTEyOHB4OyB9XFxuLnVpLWljb24taW1hZ2UgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMjA4cHggLTEyOHB4OyB9XFxuLnVpLWljb24tdmlkZW8geyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMjI0cHggLTEyOHB4OyB9XFxuLnVpLWljb24tc2NyaXB0IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTI0MHB4IC0xMjhweDsgfVxcbi51aS1pY29uLWFsZXJ0IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogMCAtMTQ0cHg7IH1cXG4udWktaWNvbi1pbmZvIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTE2cHggLTE0NHB4OyB9XFxuLnVpLWljb24tbm90aWNlIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTMycHggLTE0NHB4OyB9XFxuLnVpLWljb24taGVscCB7IGJhY2tncm91bmQtcG9zaXRpb246IC00OHB4IC0xNDRweDsgfVxcbi51aS1pY29uLWNoZWNrIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTY0cHggLTE0NHB4OyB9XFxuLnVpLWljb24tYnVsbGV0IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTgwcHggLTE0NHB4OyB9XFxuLnVpLWljb24tcmFkaW8tb24geyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtOTZweCAtMTQ0cHg7IH1cXG4udWktaWNvbi1yYWRpby1vZmYgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTEycHggLTE0NHB4OyB9XFxuLnVpLWljb24tcGluLXcgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTI4cHggLTE0NHB4OyB9XFxuLnVpLWljb24tcGluLXMgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTQ0cHggLTE0NHB4OyB9XFxuLnVpLWljb24tcGxheSB7IGJhY2tncm91bmQtcG9zaXRpb246IDAgLTE2MHB4OyB9XFxuLnVpLWljb24tcGF1c2UgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTZweCAtMTYwcHg7IH1cXG4udWktaWNvbi1zZWVrLW5leHQgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMzJweCAtMTYwcHg7IH1cXG4udWktaWNvbi1zZWVrLXByZXYgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNDhweCAtMTYwcHg7IH1cXG4udWktaWNvbi1zZWVrLWVuZCB7IGJhY2tncm91bmQtcG9zaXRpb246IC02NHB4IC0xNjBweDsgfVxcbi51aS1pY29uLXNlZWstc3RhcnQgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtODBweCAtMTYwcHg7IH1cXG4vKiB1aS1pY29uLXNlZWstZmlyc3QgaXMgZGVwcmVjYXRlZCwgdXNlIHVpLWljb24tc2Vlay1zdGFydCBpbnN0ZWFkICovXFxuLnVpLWljb24tc2Vlay1maXJzdCB7IGJhY2tncm91bmQtcG9zaXRpb246IC04MHB4IC0xNjBweDsgfVxcbi51aS1pY29uLXN0b3AgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtOTZweCAtMTYwcHg7IH1cXG4udWktaWNvbi1lamVjdCB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xMTJweCAtMTYwcHg7IH1cXG4udWktaWNvbi12b2x1bWUtb2ZmIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTEyOHB4IC0xNjBweDsgfVxcbi51aS1pY29uLXZvbHVtZS1vbiB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xNDRweCAtMTYwcHg7IH1cXG4udWktaWNvbi1wb3dlciB7IGJhY2tncm91bmQtcG9zaXRpb246IDAgLTE3NnB4OyB9XFxuLnVpLWljb24tc2lnbmFsLWRpYWcgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTZweCAtMTc2cHg7IH1cXG4udWktaWNvbi1zaWduYWwgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMzJweCAtMTc2cHg7IH1cXG4udWktaWNvbi1iYXR0ZXJ5LTAgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNDhweCAtMTc2cHg7IH1cXG4udWktaWNvbi1iYXR0ZXJ5LTEgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNjRweCAtMTc2cHg7IH1cXG4udWktaWNvbi1iYXR0ZXJ5LTIgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtODBweCAtMTc2cHg7IH1cXG4udWktaWNvbi1iYXR0ZXJ5LTMgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtOTZweCAtMTc2cHg7IH1cXG4udWktaWNvbi1jaXJjbGUtcGx1cyB7IGJhY2tncm91bmQtcG9zaXRpb246IDAgLTE5MnB4OyB9XFxuLnVpLWljb24tY2lyY2xlLW1pbnVzIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTE2cHggLTE5MnB4OyB9XFxuLnVpLWljb24tY2lyY2xlLWNsb3NlIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTMycHggLTE5MnB4OyB9XFxuLnVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLWUgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNDhweCAtMTkycHg7IH1cXG4udWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtcyB7IGJhY2tncm91bmQtcG9zaXRpb246IC02NHB4IC0xOTJweDsgfVxcbi51aS1pY29uLWNpcmNsZS10cmlhbmdsZS13IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTgwcHggLTE5MnB4OyB9XFxuLnVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLW4geyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtOTZweCAtMTkycHg7IH1cXG4udWktaWNvbi1jaXJjbGUtYXJyb3ctZSB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xMTJweCAtMTkycHg7IH1cXG4udWktaWNvbi1jaXJjbGUtYXJyb3ctcyB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xMjhweCAtMTkycHg7IH1cXG4udWktaWNvbi1jaXJjbGUtYXJyb3ctdyB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xNDRweCAtMTkycHg7IH1cXG4udWktaWNvbi1jaXJjbGUtYXJyb3ctbiB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xNjBweCAtMTkycHg7IH1cXG4udWktaWNvbi1jaXJjbGUtem9vbWluIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTE3NnB4IC0xOTJweDsgfVxcbi51aS1pY29uLWNpcmNsZS16b29tb3V0IHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTE5MnB4IC0xOTJweDsgfVxcbi51aS1pY29uLWNpcmNsZS1jaGVjayB7IGJhY2tncm91bmQtcG9zaXRpb246IC0yMDhweCAtMTkycHg7IH1cXG4udWktaWNvbi1jaXJjbGVzbWFsbC1wbHVzIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogMCAtMjA4cHg7IH1cXG4udWktaWNvbi1jaXJjbGVzbWFsbC1taW51cyB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xNnB4IC0yMDhweDsgfVxcbi51aS1pY29uLWNpcmNsZXNtYWxsLWNsb3NlIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTMycHggLTIwOHB4OyB9XFxuLnVpLWljb24tc3F1YXJlc21hbGwtcGx1cyB7IGJhY2tncm91bmQtcG9zaXRpb246IC00OHB4IC0yMDhweDsgfVxcbi51aS1pY29uLXNxdWFyZXNtYWxsLW1pbnVzIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTY0cHggLTIwOHB4OyB9XFxuLnVpLWljb24tc3F1YXJlc21hbGwtY2xvc2UgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtODBweCAtMjA4cHg7IH1cXG4udWktaWNvbi1ncmlwLWRvdHRlZC12ZXJ0aWNhbCB7IGJhY2tncm91bmQtcG9zaXRpb246IDAgLTIyNHB4OyB9XFxuLnVpLWljb24tZ3JpcC1kb3R0ZWQtaG9yaXpvbnRhbCB7IGJhY2tncm91bmQtcG9zaXRpb246IC0xNnB4IC0yMjRweDsgfVxcbi51aS1pY29uLWdyaXAtc29saWQtdmVydGljYWwgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMzJweCAtMjI0cHg7IH1cXG4udWktaWNvbi1ncmlwLXNvbGlkLWhvcml6b250YWwgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNDhweCAtMjI0cHg7IH1cXG4udWktaWNvbi1ncmlwc21hbGwtZGlhZ29uYWwtc2UgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNjRweCAtMjI0cHg7IH1cXG4udWktaWNvbi1ncmlwLWRpYWdvbmFsLXNlIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogLTgwcHggLTIyNHB4OyB9XFxuXFxuXFxuLyogTWlzYyB2aXN1YWxzXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuLyogQ29ybmVyIHJhZGl1cyAqL1xcbi51aS1jb3JuZXItYWxsLFxcbi51aS1jb3JuZXItdG9wLFxcbi51aS1jb3JuZXItbGVmdCxcXG4udWktY29ybmVyLXRsIHtcXG5cXHRib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAzcHgvKntjb3JuZXJSYWRpdXN9Ki87XFxufVxcbi51aS1jb3JuZXItYWxsLFxcbi51aS1jb3JuZXItdG9wLFxcbi51aS1jb3JuZXItcmlnaHQsXFxuLnVpLWNvcm5lci10ciB7XFxuXFx0Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDNweC8qe2Nvcm5lclJhZGl1c30qLztcXG59XFxuLnVpLWNvcm5lci1hbGwsXFxuLnVpLWNvcm5lci1ib3R0b20sXFxuLnVpLWNvcm5lci1sZWZ0LFxcbi51aS1jb3JuZXItYmwge1xcblxcdGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDNweC8qe2Nvcm5lclJhZGl1c30qLztcXG59XFxuLnVpLWNvcm5lci1hbGwsXFxuLnVpLWNvcm5lci1ib3R0b20sXFxuLnVpLWNvcm5lci1yaWdodCxcXG4udWktY29ybmVyLWJyIHtcXG5cXHRib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogM3B4Lyp7Y29ybmVyUmFkaXVzfSovO1xcbn1cXG5cXG4vKiBPdmVybGF5cyAqL1xcbi51aS13aWRnZXQtb3ZlcmxheSB7XFxuXFx0YmFja2dyb3VuZDogI2FhYWFhYS8qe2JnQ29sb3JPdmVybGF5fSovIC8qe2JnSW1nVXJsT3ZlcmxheX0qLyAvKntiZ092ZXJsYXlYUG9zfSovIC8qe2JnT3ZlcmxheVlQb3N9Ki8gLyp7YmdPdmVybGF5UmVwZWF0fSovO1xcblxcdG9wYWNpdHk6IC4zLyp7b3BhY2l0eU92ZXJsYXl9Ki87XFxuXFx0LW1zLWZpbHRlcjogXFxcImFscGhhKG9wYWNpdHk9MzApXFxcIi8qe29wYWNpdHlGaWx0ZXJPdmVybGF5fSovOyAvKiBzdXBwb3J0OiBJRTggKi9cXG59XFxuLnVpLXdpZGdldC1zaGFkb3cge1xcblxcdC13ZWJraXQtYm94LXNoYWRvdzogMC8qe29mZnNldExlZnRTaGFkb3d9Ki8gMC8qe29mZnNldFRvcFNoYWRvd30qLyA1cHgvKnt0aGlja25lc3NTaGFkb3d9Ki8gIzY2NjY2Ni8qe2JnQ29sb3JTaGFkb3d9Ki87XFxuXFx0Ym94LXNoYWRvdzogMC8qe29mZnNldExlZnRTaGFkb3d9Ki8gMC8qe29mZnNldFRvcFNoYWRvd30qLyA1cHgvKnt0aGlja25lc3NTaGFkb3d9Ki8gIzY2NjY2Ni8qe2JnQ29sb3JTaGFkb3d9Ki87XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/css-loader/index.js?!../node_modules/jquery-ui/themes/base/theme.css\n')},"../node_modules/css-loader/index.js?!./app.css":function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ "../node_modules/css-loader/lib/css-base.js")(false);\n// imports\n\n\n// module\nexports.push([module.i, ".oeb-table {\\n  margin-bottom: 50px;\\n}\\n\\n.title {\\n  text-align: center;\\n  margin-top: 50px;\\n  margin-bottom: 50px;\\n}\\n\\n.ui-widget-content {\\n  border: none !important;\\n}\\n\\n.ui-tabs-nav li {\\n  display: inline-block;\\n  margin: 5px;\\n  height: auto;\\n}\\n\\n.ui-tabs-nav .empty-tab {\\n  display: none !important; /* Fully hide empty tabs */\\n}\\n\\n.ui-widget-header {\\n  height: auto;\\n}\\n\\n.ui-tabs .ui-tabs-nav li {\\n  list-style: none;\\n  float: left;\\n  position: relative;\\n  top: 0;\\n  margin: 1px 0.2em 0 0;\\n  border-bottom-width: 1px;\\n  padding: 0;\\n  white-space: nowrap;\\n}\\n\\n.ui-tabs .ui-tabs-nav li.ui-tabs-active .ui-tabs-anchor,\\n.ui-tabs .ui-tabs-nav li.ui-state-disabled .ui-tabs-anchor,\\n.ui-tabs .ui-tabs-nav li.ui-tabs-loading .ui-tabs-anchor {\\n  cursor: default !important;\\n}\\n\\n.ui-state-active,\\n.ui-widget-content .ui-state-active,\\n.ui-widget-header .ui-state-active,\\na.ui-button:active,\\n.ui-button:active,\\n.ui-button.ui-state-active:hover {\\n  background: #0c59a0 !important;\\n  font-weight: normal;\\n  color: white;\\n  border: 1px solid #e9e9e9;\\n  border-top-left-radius: 3px;\\n  border-top-right-radius: 3px;\\n  outline: none !important;\\n}\\n\\n*:focus {\\n  outline: none !important;\\n  outline-offset: 0 !important;\\n}\\n\\n.ui-tabs-active:focus,\\n.ui-tabs-anchor:focus {\\n    outline: none !important;\\n    outline-offset: 0 !important;\\n}\\n\\n.oeb-table-scroll {\\n  position: relative;\\n  z-index: 1;\\n  table-layout: fixed;\\n  margin: auto;\\n  overflow-x: auto;\\n  overflow-y: auto;\\n  max-height: 500px;\\n  white-space: nowrap;\\n}\\n\\n.oeb-table-scroll table {\\n  width: auto;\\n  min-width: 100%;\\n  margin: auto;\\n  border-collapse: separate;\\n  border-spacing: 0;\\n  border: 0.2px solid #0000003d;\\n  border-radius: 10px;\\n  border-top-right-radius: 10px;\\n}\\n\\n.oeb-table-scroll th {\\n  white-space: nowrap;\\n  text-overflow: ellipsis;\\n  overflow: hidden;\\n  padding: 5px 10px;\\n  border: 0.1px solid #0000003d;\\n  text-align: center;\\n}\\n\\n/* General styling for th and td */\\n.oeb-table-scroll th,\\n.oeb-table-scroll td {\\n  padding: 5px 10px;\\n  border: 0.1px solid #0000003d !important;\\n  text-align: center;\\n  white-space: nowrap; /* Prevent text wrapping */\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n  min-width: 120px; /* Adjust based on content size */\\n  max-width: 250px;\\n}\\n\\n.oeb-table-scroll th:first-child,\\n.oeb-table-scroll td:first-child {\\n  position: sticky;\\n  left: 0;\\n  background-color: #fff;\\n  z-index: 4;\\n}\\n\\n/* Sticky thead (for both header rows) */\\n.oeb-table-scroll thead th {\\n  position: sticky;\\n  top: 0;\\n  background-color: #fff;\\n  z-index: 3;\\n  border: 0.1px solid #0000003d;\\n}\\n\\n/* Fix sticky behavior for the second row */\\n.oeb-table-scroll thead tr:nth-child(2) th {\\n  z-index: 3;\\n  background-color: #fff;\\n  top: 40px;\\n}\\n\\n/* Fix overlapping issue of first column and first two rows */\\n.oeb-table-scroll thead tr:first-child th,\\n.oeb-table-scroll thead tr:nth-child(2) th {\\n  position: sticky;\\n  background-color: #fff;\\n  z-index: 5;\\n}\\n\\n/* Ensure first cell (top-left corner) remains fixed */\\n.oeb-table-scroll thead tr:first-child th:first-child {\\n  z-index: 6;\\n  background-color: #fff;\\n}\\n\\n.no_benchmark_data {\\n  text-align: center;\\n  border: none !important;\\n}\\n\\n.classificator_list {\\n  background-color: #0a58a2;\\n  color: #fff;\\n  cursor: pointer;\\n  padding-left: 5px;\\n  padding-right: 25px;\\n  margin-left: 50px;\\n  text-align: center;\\n  border: 5px solid transparent;\\n  border-right: 15px solid transparent;\\n  line-height: 1.25rem;\\n  font-size: 0.875rem;\\n  border-radius: 0.375rem;\\n}\\n\\n.classificator_list:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(61 121 179 / var(--tw-bg-opacity));\\n}\\n\\nselect.classificator_list {\\n  appearance: auto;\\n  -moz-appearance: auto !important;\\n  -webkit-appearance: auto !important;\\n}\\n\\n.notbold {\\n  font-weight: normal;\\n}\\n\\n.italic {\\n  font-style: italic;\\n}\\n\\n.Q1 {\\n  background-color: #238b45;\\n  color: #ffffff;\\n}\\n\\n.Q2 {\\n  background-color: #74c575;\\n}\\n\\n.Q3 {\\n  background-color: #bbe4b3;\\n}\\n\\n.Q4 {\\n  background-color: #edf8e9;\\n}\\n\\n/* Disable strange header coloring */\\n.aggregation_cell a {\\n  color: revert;\\n}\\n\\n.spinner-container {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  position: relative;\\n  margin-top: 20px;\\n  height: 100px;\\n  text-align: center;\\n}\\n\\n/* Styling for the loading spinner image */\\n.spinner {\\n  width: 150px;\\n  height: 100px;\\n}\\n\\n.ui-tabs .ui-tabs-nav .empty-challenge {\\n  background: rgb(255, 191, 191);\\n}\\n\\n.ui-widget.ui-widget-content {\\n  margin-top: 20px;\\n}\\n\\n.tabs-container {\\n  position: relative;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  width: 100%;\\n  height: auto;\\n}\\n\\n.tabs-wrapper {\\n  width: 100%;\\n  display: flex;\\n  justify-content: center;\\n  align-items: flex-start;\\n  min-height: auto;\\n  height: auto;\\n}\\n\\n.empty-tab {\\n  display: none;\\n}\\n\\n/* Tab list styling */\\n.ui-tabs-nav {\\n  display: flex;\\n  flex-wrap: wrap;\\n  width: 96%;\\n  list-style: none;\\n  padding: 0 0 0 20px;\\n  margin: 0;\\n  transition: transform 0.3s ease;\\n  justify-content: center;\\n  height: auto;\\n  overflow: hidden;\\n}\\n\\n.ui-tabs-nav:only-child {\\n  height: auto; /* Ensure it collapses to fit the height */\\n}\\n/* Tabs styling */\\n.ui-tabs-tab {\\n  flex: 0 0 calc(20% - 10px); /* Same width for tabs */\\n  margin: 5px;\\n  max-width: calc(20% - 10px);\\n  max-height: calc(70% - 10px);\\n  box-sizing: padding-box;\\n  border: 1px solid transparent;\\n}\\n\\n.ui-tabs-anchor {\\n  display: inline-block;\\n  width: 100%;\\n  white-space: nowrap;\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n}\\n\\n.tablimits {\\n  display: inline-block;\\n  max-width: 70%;\\n  white-space: nowrap;\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n  padding-top: 5px;\\n}\\n\\n/* Arrow button styling */\\n.arrow {\\n  position: absolute;\\n  top: 0;\\n  bottom: 0;\\n  width: 1.5%;\\n  background-color: #e9e9e9;\\n  border: 1px solid #dddddd;\\n  cursor: pointer;\\n  font-size: 1.5rem;\\n  border-radius: 3px;\\n}\\n\\n.left-arrow {\\n  left: 0;\\n}\\n\\n.right-arrow {\\n  right: 0;\\n}\\n\\n/* Ensure arrow buttons take up the full height of the tabs container */\\n.arrow:focus {\\n  outline: none;\\n}\\n\\n.arrow:disabled {\\n  cursor: not-allowed;\\n  opacity: 0.5;\\n}\\n\\n/* Responsive adjustments */\\n@media (max-width: 768px) {\\n  .ui-tabs-tab {\\n    flex: 0 0 calc(50% - 10px); /* Adjust tab width for smaller screens */\\n  }\\n}\\n\\n.report {\\n  display: flex;\\n  justify-content: left;\\n  margin-top: 20px;\\n  font-weight: bold;\\n  margin-left: 0.5em;\\n}\\n\\n.pags {\\n  display: flex;\\n  justify-content: center;\\n  margin-top: -0.5rem;\\n  margin-right: 0.8em;\\n}\\n\\n.ui-tabs-panel {\\n  display: block;\\n  border-width: 0;\\n  padding: 0px !important;\\n  background: none;\\n  margin: 0rem;\\n}\\n\\n.tabs-footer {\\n  display: flex;\\n  align-items: flex-end;\\n  justify-content: space-between;\\n  margin-bottom: 1em;\\n}\\n\\n.aggregation_cell_2 {\\n  color: #0b579f !important;\\n  text-decoration: none;\\n}\\n\\n.aggregation_cell_2:hover {\\n  color: #6a98c4 !important;\\n  text-decoration: underline;\\n  cursor: pointer;\\n}\\n\\n.aggregation_cell_2:visited {\\n  color: #701a75 !important;\\n}\\n\\n.aggregation_cell a {\\n  cursor: default;\\n  text-decoration: none;\\n  color: black;\\n  font-size: 1em;\\n  overflow-wrap: break-word;\\n  white-space: normal;\\n  max-height: 200px;\\n  overflow-y: auto;\\n  overflow-x: hidden;\\n  display: block;\\n  padding: 1px;\\n}\\n\\n.ui-tabs .ui-tabs-nav {\\n  margin: 0;\\n  padding: 0.2em;\\n}\\n\\nb {\\n  font-size: 0.85em;\\n}\\n\\n/* CSS of boostrap container */\\n.container {\\n  width: 100%;\\n  padding-right: var(--bs-gutter-x, 1.5rem);\\n  padding-left: var(--bs-gutter-x, 1.5rem);\\n  margin-right: auto;\\n  margin-left: auto;\\n}\\n\\n@media (min-width: 576px) {\\n  .container {\\n    max-width: 540px;\\n  }\\n}\\n\\n@media (min-width: 768px) {\\n  .container {\\n    max-width: 720px;\\n  }\\n}\\n\\n@media (min-width: 992px) {\\n  .container {\\n    max-width: 960px;\\n  }\\n}\\n\\n@media (min-width: 1200px) {\\n  .container {\\n    max-width: 1140px;\\n  }\\n}\\n\\n@media (min-width: 1400px) {\\n  .container {\\n    max-width: 1320px;\\n  }\\n}\\n", ""]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/IS4vYXBwLmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FwcC5jc3M/MzEzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5vZWItdGFibGUge1xcbiAgbWFyZ2luLWJvdHRvbTogNTBweDtcXG59XFxuXFxuLnRpdGxlIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIG1hcmdpbi10b3A6IDUwcHg7XFxuICBtYXJnaW4tYm90dG9tOiA1MHB4O1xcbn1cXG5cXG4udWktd2lkZ2V0LWNvbnRlbnQge1xcbiAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XFxufVxcblxcbi51aS10YWJzLW5hdiBsaSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBtYXJnaW46IDVweDtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuLnVpLXRhYnMtbmF2IC5lbXB0eS10YWIge1xcbiAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyAvKiBGdWxseSBoaWRlIGVtcHR5IHRhYnMgKi9cXG59XFxuXFxuLnVpLXdpZGdldC1oZWFkZXIge1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG5cXG4udWktdGFicyAudWktdGFicy1uYXYgbGkge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdG9wOiAwO1xcbiAgbWFyZ2luOiAxcHggMC4yZW0gMCAwO1xcbiAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4O1xcbiAgcGFkZGluZzogMDtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcblxcbi51aS10YWJzIC51aS10YWJzLW5hdiBsaS51aS10YWJzLWFjdGl2ZSAudWktdGFicy1hbmNob3IsXFxuLnVpLXRhYnMgLnVpLXRhYnMtbmF2IGxpLnVpLXN0YXRlLWRpc2FibGVkIC51aS10YWJzLWFuY2hvcixcXG4udWktdGFicyAudWktdGFicy1uYXYgbGkudWktdGFicy1sb2FkaW5nIC51aS10YWJzLWFuY2hvciB7XFxuICBjdXJzb3I6IGRlZmF1bHQgIWltcG9ydGFudDtcXG59XFxuXFxuLnVpLXN0YXRlLWFjdGl2ZSxcXG4udWktd2lkZ2V0LWNvbnRlbnQgLnVpLXN0YXRlLWFjdGl2ZSxcXG4udWktd2lkZ2V0LWhlYWRlciAudWktc3RhdGUtYWN0aXZlLFxcbmEudWktYnV0dG9uOmFjdGl2ZSxcXG4udWktYnV0dG9uOmFjdGl2ZSxcXG4udWktYnV0dG9uLnVpLXN0YXRlLWFjdGl2ZTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiAjMGM1OWEwICFpbXBvcnRhbnQ7XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2U5ZTllOTtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDNweDtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAzcHg7XFxuICBvdXRsaW5lOiBub25lICFpbXBvcnRhbnQ7XFxufVxcblxcbio6Zm9jdXMge1xcbiAgb3V0bGluZTogbm9uZSAhaW1wb3J0YW50O1xcbiAgb3V0bGluZS1vZmZzZXQ6IDAgIWltcG9ydGFudDtcXG59XFxuXFxuLnVpLXRhYnMtYWN0aXZlOmZvY3VzLFxcbi51aS10YWJzLWFuY2hvcjpmb2N1cyB7XFxuICAgIG91dGxpbmU6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgb3V0bGluZS1vZmZzZXQ6IDAgIWltcG9ydGFudDtcXG59XFxuXFxuLm9lYi10YWJsZS1zY3JvbGwge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogMTtcXG4gIHRhYmxlLWxheW91dDogZml4ZWQ7XFxuICBtYXJnaW46IGF1dG87XFxuICBvdmVyZmxvdy14OiBhdXRvO1xcbiAgb3ZlcmZsb3cteTogYXV0bztcXG4gIG1heC1oZWlnaHQ6IDUwMHB4O1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG59XFxuXFxuLm9lYi10YWJsZS1zY3JvbGwgdGFibGUge1xcbiAgd2lkdGg6IGF1dG87XFxuICBtaW4td2lkdGg6IDEwMCU7XFxuICBtYXJnaW46IGF1dG87XFxuICBib3JkZXItY29sbGFwc2U6IHNlcGFyYXRlO1xcbiAgYm9yZGVyLXNwYWNpbmc6IDA7XFxuICBib3JkZXI6IDAuMnB4IHNvbGlkICMwMDAwMDAzZDtcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMTBweDtcXG59XFxuXFxuLm9lYi10YWJsZS1zY3JvbGwgdGgge1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHBhZGRpbmc6IDVweCAxMHB4O1xcbiAgYm9yZGVyOiAwLjFweCBzb2xpZCAjMDAwMDAwM2Q7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbi8qIEdlbmVyYWwgc3R5bGluZyBmb3IgdGggYW5kIHRkICovXFxuLm9lYi10YWJsZS1zY3JvbGwgdGgsXFxuLm9lYi10YWJsZS1zY3JvbGwgdGQge1xcbiAgcGFkZGluZzogNXB4IDEwcHg7XFxuICBib3JkZXI6IDAuMXB4IHNvbGlkICMwMDAwMDAzZCAhaW1wb3J0YW50O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDsgLyogUHJldmVudCB0ZXh0IHdyYXBwaW5nICovXFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICBtaW4td2lkdGg6IDEyMHB4OyAvKiBBZGp1c3QgYmFzZWQgb24gY29udGVudCBzaXplICovXFxuICBtYXgtd2lkdGg6IDI1MHB4O1xcbn1cXG5cXG4ub2ViLXRhYmxlLXNjcm9sbCB0aDpmaXJzdC1jaGlsZCxcXG4ub2ViLXRhYmxlLXNjcm9sbCB0ZDpmaXJzdC1jaGlsZCB7XFxuICBwb3NpdGlvbjogc3RpY2t5O1xcbiAgbGVmdDogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICB6LWluZGV4OiA0O1xcbn1cXG5cXG4vKiBTdGlja3kgdGhlYWQgKGZvciBib3RoIGhlYWRlciByb3dzKSAqL1xcbi5vZWItdGFibGUtc2Nyb2xsIHRoZWFkIHRoIHtcXG4gIHBvc2l0aW9uOiBzdGlja3k7XFxuICB0b3A6IDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgei1pbmRleDogMztcXG4gIGJvcmRlcjogMC4xcHggc29saWQgIzAwMDAwMDNkO1xcbn1cXG5cXG4vKiBGaXggc3RpY2t5IGJlaGF2aW9yIGZvciB0aGUgc2Vjb25kIHJvdyAqL1xcbi5vZWItdGFibGUtc2Nyb2xsIHRoZWFkIHRyOm50aC1jaGlsZCgyKSB0aCB7XFxuICB6LWluZGV4OiAzO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIHRvcDogNDBweDtcXG59XFxuXFxuLyogRml4IG92ZXJsYXBwaW5nIGlzc3VlIG9mIGZpcnN0IGNvbHVtbiBhbmQgZmlyc3QgdHdvIHJvd3MgKi9cXG4ub2ViLXRhYmxlLXNjcm9sbCB0aGVhZCB0cjpmaXJzdC1jaGlsZCB0aCxcXG4ub2ViLXRhYmxlLXNjcm9sbCB0aGVhZCB0cjpudGgtY2hpbGQoMikgdGgge1xcbiAgcG9zaXRpb246IHN0aWNreTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICB6LWluZGV4OiA1O1xcbn1cXG5cXG4vKiBFbnN1cmUgZmlyc3QgY2VsbCAodG9wLWxlZnQgY29ybmVyKSByZW1haW5zIGZpeGVkICovXFxuLm9lYi10YWJsZS1zY3JvbGwgdGhlYWQgdHI6Zmlyc3QtY2hpbGQgdGg6Zmlyc3QtY2hpbGQge1xcbiAgei1pbmRleDogNjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxufVxcblxcbi5ub19iZW5jaG1hcmtfZGF0YSB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBib3JkZXI6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxuLmNsYXNzaWZpY2F0b3JfbGlzdCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMGE1OGEyO1xcbiAgY29sb3I6ICNmZmY7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBwYWRkaW5nLWxlZnQ6IDVweDtcXG4gIHBhZGRpbmctcmlnaHQ6IDI1cHg7XFxuICBtYXJnaW4tbGVmdDogNTBweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGJvcmRlcjogNXB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXJpZ2h0OiAxNXB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgbGluZS1oZWlnaHQ6IDEuMjVyZW07XFxuICBmb250LXNpemU6IDAuODc1cmVtO1xcbiAgYm9yZGVyLXJhZGl1czogMC4zNzVyZW07XFxufVxcblxcbi5jbGFzc2lmaWNhdG9yX2xpc3Q6aG92ZXIge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDYxIDEyMSAxNzkgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcblxcbnNlbGVjdC5jbGFzc2lmaWNhdG9yX2xpc3Qge1xcbiAgYXBwZWFyYW5jZTogYXV0bztcXG4gIC1tb3otYXBwZWFyYW5jZTogYXV0byAhaW1wb3J0YW50O1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBhdXRvICFpbXBvcnRhbnQ7XFxufVxcblxcbi5ub3Rib2xkIHtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxufVxcblxcbi5pdGFsaWMge1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcbn1cXG5cXG4uUTEge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzIzOGI0NTtcXG4gIGNvbG9yOiAjZmZmZmZmO1xcbn1cXG5cXG4uUTIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzc0YzU3NTtcXG59XFxuXFxuLlEzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNiYmU0YjM7XFxufVxcblxcbi5RNCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWRmOGU5O1xcbn1cXG5cXG4vKiBEaXNhYmxlIHN0cmFuZ2UgaGVhZGVyIGNvbG9yaW5nICovXFxuLmFnZ3JlZ2F0aW9uX2NlbGwgYSB7XFxuICBjb2xvcjogcmV2ZXJ0O1xcbn1cXG5cXG4uc3Bpbm5lci1jb250YWluZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIG1hcmdpbi10b3A6IDIwcHg7XFxuICBoZWlnaHQ6IDEwMHB4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG4vKiBTdHlsaW5nIGZvciB0aGUgbG9hZGluZyBzcGlubmVyIGltYWdlICovXFxuLnNwaW5uZXIge1xcbiAgd2lkdGg6IDE1MHB4O1xcbiAgaGVpZ2h0OiAxMDBweDtcXG59XFxuXFxuLnVpLXRhYnMgLnVpLXRhYnMtbmF2IC5lbXB0eS1jaGFsbGVuZ2Uge1xcbiAgYmFja2dyb3VuZDogcmdiKDI1NSwgMTkxLCAxOTEpO1xcbn1cXG5cXG4udWktd2lkZ2V0LnVpLXdpZGdldC1jb250ZW50IHtcXG4gIG1hcmdpbi10b3A6IDIwcHg7XFxufVxcblxcbi50YWJzLWNvbnRhaW5lciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IGF1dG87XFxufVxcblxcbi50YWJzLXdyYXBwZXIge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXG4gIG1pbi1oZWlnaHQ6IGF1dG87XFxuICBoZWlnaHQ6IGF1dG87XFxufVxcblxcbi5lbXB0eS10YWIge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLyogVGFiIGxpc3Qgc3R5bGluZyAqL1xcbi51aS10YWJzLW5hdiB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbiAgd2lkdGg6IDk2JTtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICBwYWRkaW5nOiAwIDAgMCAyMHB4O1xcbiAgbWFyZ2luOiAwO1xcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuM3MgZWFzZTtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuLnVpLXRhYnMtbmF2Om9ubHktY2hpbGQge1xcbiAgaGVpZ2h0OiBhdXRvOyAvKiBFbnN1cmUgaXQgY29sbGFwc2VzIHRvIGZpdCB0aGUgaGVpZ2h0ICovXFxufVxcbi8qIFRhYnMgc3R5bGluZyAqL1xcbi51aS10YWJzLXRhYiB7XFxuICBmbGV4OiAwIDAgY2FsYygyMCUgLSAxMHB4KTsgLyogU2FtZSB3aWR0aCBmb3IgdGFicyAqL1xcbiAgbWFyZ2luOiA1cHg7XFxuICBtYXgtd2lkdGg6IGNhbGMoMjAlIC0gMTBweCk7XFxuICBtYXgtaGVpZ2h0OiBjYWxjKDcwJSAtIDEwcHgpO1xcbiAgYm94LXNpemluZzogcGFkZGluZy1ib3g7XFxuICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcXG59XFxuXFxuLnVpLXRhYnMtYW5jaG9yIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHdpZHRoOiAxMDAlO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG59XFxuXFxuLnRhYmxpbWl0cyB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBtYXgtd2lkdGg6IDcwJTtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICBwYWRkaW5nLXRvcDogNXB4O1xcbn1cXG5cXG4vKiBBcnJvdyBidXR0b24gc3R5bGluZyAqL1xcbi5hcnJvdyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBib3R0b206IDA7XFxuICB3aWR0aDogMS41JTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlOWU5ZTk7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZGRkZGRkO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgZm9udC1zaXplOiAxLjVyZW07XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxufVxcblxcbi5sZWZ0LWFycm93IHtcXG4gIGxlZnQ6IDA7XFxufVxcblxcbi5yaWdodC1hcnJvdyB7XFxuICByaWdodDogMDtcXG59XFxuXFxuLyogRW5zdXJlIGFycm93IGJ1dHRvbnMgdGFrZSB1cCB0aGUgZnVsbCBoZWlnaHQgb2YgdGhlIHRhYnMgY29udGFpbmVyICovXFxuLmFycm93OmZvY3VzIHtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcblxcbi5hcnJvdzpkaXNhYmxlZCB7XFxuICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgb3BhY2l0eTogMC41O1xcbn1cXG5cXG4vKiBSZXNwb25zaXZlIGFkanVzdG1lbnRzICovXFxuQG1lZGlhIChtYXgtd2lkdGg6IDc2OHB4KSB7XFxuICAudWktdGFicy10YWIge1xcbiAgICBmbGV4OiAwIDAgY2FsYyg1MCUgLSAxMHB4KTsgLyogQWRqdXN0IHRhYiB3aWR0aCBmb3Igc21hbGxlciBzY3JlZW5zICovXFxuICB9XFxufVxcblxcbi5yZXBvcnQge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogbGVmdDtcXG4gIG1hcmdpbi10b3A6IDIwcHg7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIG1hcmdpbi1sZWZ0OiAwLjVlbTtcXG59XFxuXFxuLnBhZ3Mge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgbWFyZ2luLXRvcDogLTAuNXJlbTtcXG4gIG1hcmdpbi1yaWdodDogMC44ZW07XFxufVxcblxcbi51aS10YWJzLXBhbmVsIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgYm9yZGVyLXdpZHRoOiAwO1xcbiAgcGFkZGluZzogMHB4ICFpbXBvcnRhbnQ7XFxuICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgbWFyZ2luOiAwcmVtO1xcbn1cXG5cXG4udGFicy1mb290ZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBmbGV4LWVuZDtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIG1hcmdpbi1ib3R0b206IDFlbTtcXG59XFxuXFxuLmFnZ3JlZ2F0aW9uX2NlbGxfMiB7XFxuICBjb2xvcjogIzBiNTc5ZiAhaW1wb3J0YW50O1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbn1cXG5cXG4uYWdncmVnYXRpb25fY2VsbF8yOmhvdmVyIHtcXG4gIGNvbG9yOiAjNmE5OGM0ICFpbXBvcnRhbnQ7XFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLmFnZ3JlZ2F0aW9uX2NlbGxfMjp2aXNpdGVkIHtcXG4gIGNvbG9yOiAjNzAxYTc1ICFpbXBvcnRhbnQ7XFxufVxcblxcbi5hZ2dyZWdhdGlvbl9jZWxsIGEge1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgY29sb3I6IGJsYWNrO1xcbiAgZm9udC1zaXplOiAxZW07XFxuICBvdmVyZmxvdy13cmFwOiBicmVhay13b3JkO1xcbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcXG4gIG1heC1oZWlnaHQ6IDIwMHB4O1xcbiAgb3ZlcmZsb3cteTogYXV0bztcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcGFkZGluZzogMXB4O1xcbn1cXG5cXG4udWktdGFicyAudWktdGFicy1uYXYge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMC4yZW07XFxufVxcblxcbmIge1xcbiAgZm9udC1zaXplOiAwLjg1ZW07XFxufVxcblxcbi8qIENTUyBvZiBib29zdHJhcCBjb250YWluZXIgKi9cXG4uY29udGFpbmVyIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZy1yaWdodDogdmFyKC0tYnMtZ3V0dGVyLXgsIDEuNXJlbSk7XFxuICBwYWRkaW5nLWxlZnQ6IHZhcigtLWJzLWd1dHRlci14LCAxLjVyZW0pO1xcbiAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxufVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA1NzZweCkge1xcbiAgLmNvbnRhaW5lciB7XFxuICAgIG1heC13aWR0aDogNTQwcHg7XFxuICB9XFxufVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xcbiAgLmNvbnRhaW5lciB7XFxuICAgIG1heC13aWR0aDogNzIwcHg7XFxuICB9XFxufVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkge1xcbiAgLmNvbnRhaW5lciB7XFxuICAgIG1heC13aWR0aDogOTYwcHg7XFxuICB9XFxufVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiAxMjAwcHgpIHtcXG4gIC5jb250YWluZXIge1xcbiAgICBtYXgtd2lkdGg6IDExNDBweDtcXG4gIH1cXG59XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDE0MDBweCkge1xcbiAgLmNvbnRhaW5lciB7XFxuICAgIG1heC13aWR0aDogMTMyMHB4O1xcbiAgfVxcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/css-loader/index.js?!./app.css\n')},"../node_modules/css-loader/lib/css-base.js":function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn "@media " + item[2] + "{" + content + "}";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join("");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === "string")\n\t\t\tmodules = [[null, modules, ""]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === "number")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || \'\';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === \'function\') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn \'/*# sourceURL=\' + cssMapping.sourceRoot + source + \' */\'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n\t}\n\n\treturn [content].join(\'\\n\');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = \'sourceMappingURL=data:application/json;charset=utf-8;base64,\' + base64;\n\n\treturn \'/*# \' + data + \' */\';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcz83YjRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/css-loader/lib/css-base.js\n')},"../node_modules/css-loader/lib/url/escape.js":function(module,exports){eval("module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL3VybC9lc2NhcGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL3VybC9lc2NhcGUuanM/MTExZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZSh1cmwpIHtcbiAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgICAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cbiAgICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICAgICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAgIC8vIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG4gICAgaWYgKC9bXCInKCkgXFx0XFxuXS8udGVzdCh1cmwpKSB7XG4gICAgICAgIHJldHVybiAnXCInICsgdXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJykgKyAnXCInXG4gICAgfVxuXG4gICAgcmV0dXJuIHVybFxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/css-loader/lib/url/escape.js\n")},"../node_modules/jquery-ui/themes/base/core.css":function(module,exports,__webpack_require__){eval('\nvar content = __webpack_require__(/*! !../../../css-loader??ref--4-1!./core.css */ "../node_modules/css-loader/index.js?!../node_modules/jquery-ui/themes/base/core.css");\n\nif(typeof content === \'string\') content = [[module.i, content, \'\']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {"hmr":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../../style-loader/lib/addStyles.js */ "../node_modules/style-loader/lib/addStyles.js")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS90aGVtZXMvYmFzZS9jb3JlLmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3RoZW1lcy9iYXNlL2NvcmUuY3NzPzA1ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNC0xIS4vY29yZS5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS00LTEhLi9jb3JlLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNC0xIS4vY29yZS5jc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/jquery-ui/themes/base/core.css\n')},"../node_modules/jquery-ui/themes/base/images/ui-icons_444444_256x240.png":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS90aGVtZXMvYmFzZS9pbWFnZXMvdWktaWNvbnNfNDQ0NDQ0XzI1NngyNDAucG5nLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdGhlbWVzL2Jhc2UvaW1hZ2VzL3VpLWljb25zXzQ0NDQ0NF8yNTZ4MjQwLnBuZz9mNzc0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFRQUFBQUR3QkFNQUFBQWR1YWY0QUFBQU1GQk1WRVZNYVhGR1JrWkVSRVEvUHo5RlJVVS9QejlEUTBORVJFUkRRME5EUTBORlJVVkVSRVJEUTBORFEwTkVSRVJEUTBNOXFTWjBBQUFBRUhSU1RsTUFHZjhQTXdoT3Y1Q2ZMQ0Z6UVdMTitoaVpBUUFBRERGSlJFRlVlQUhzbVF0dTNEQU1STzA1Z2FFVFVMei9JUXRVOUVNbUMwUVZIS1RkUW9QUFlwYS9FU1ZiM09UWStCOXc5dVB2b3VWMWZDczB5OWU4QWRuNjc4OGdjQkZ0eENtekJQUXlaTkV6QjZWaW1UTSsybHNRdUlZenV3czQ3NWFtclJBQmd5TGdJSXJBTmJSK3gxRWhpdHNlWXpaM29FN2dJdktpSUd2eGpyRGk4QTRjYk5HakRnQXkycFlBQkhBRy9CQnlCbjcyS1dDTGVBcmUvMFcwc2JHeHNmNG14SDhWSlBCM3Zib1ZVdGFsMEYvbmdVSEwwTFN1eEJQY0F2SXFRMzFrdDJ1NEljQnV6VE5Sdm9hV2QwRUVCSVZzSHVCYVBvd1hsQ3JESXBMSnBsa0h6dGQ1NERKaFJhMER6M0RHMGp4UTVmd012T05UOEJ3Ykd4c2JNWHZYeDlmK2VsaUFPOGdMS2VmNVBDN1RIR1FCYmpEL2lISlFEQzZZeGV1T0RLY1NHYjBsSVU4UXhPUHVYMFJVOVBpVXQ0SUVVWDdFNFNpdVo3Z0pDSitRZ3NLNFZ6eXRvZUQ0WGg4RlNSUkM0Q2RGNUFtb0xWaG1WeER0VytJQmNPK0E3N252c2RLNU8yTDNUbk80L0F3QTZQT25ZTmxlbmQvWTJOZ0Eweit3S21aL2JQYnI4Uk5UWm55WnI2VWxBUEVhWUpIaWw5cTlBbVg5d09zMkhSQncyVDJ0bzNGN2tmTDJoQkJnQmR3N2ZhQm9jZVJWekRxazdnSk9CcG1YcHRrS0tvQnZHZ0xDN1VxTkxFTlJXSWU0amhFc2xJK3lsdUNtcGxqSmZRL0hUa0VFSFBLQ0pRQkJMb0FGVW9DR2lIeHVKMENCTzF0Z0NjSzNvTGJFdDhBM3ZkOWZtR0lLNEpjSVJNNDRoTmdSd0NFRUhFS2JkTXJUbDlUOTFBYzVBb0c0QStzQVFQRDNBSUgvR0RZMk5tSnhIZ2dmRElRaC95eVQwaWdaQ0orZ2hROEdnU0dhTDBpSG93ckg4QkNGMC9nVW1kd2RPZktwdUpkbFNZR2VLTHZLYW9VRHo3a0ErM2Q0WHVwRmZXQ1JSQUZYcHJLS2hxd0lhRUdwd1RNVDZqKzM0VkFVMFFtcUJyL3I1NGV3VW5IOXBxMDhUQUFHU2RoZFFIRS9uZk8vdjNkMW13ZGF3cXNRUFErYlJ4QktZZmpTZzZ1OGJCN3djZDJHVS91Z2pIeFEramxvdjNvM2ZyVjNCaENTWlBjZi8rM3IrZS9lek56MlRzLy9MSURmZnJ1blo3cG51cmZWWkYwa0ozckxKc2pCNmtzSFI5Z3RzUkZ4ekUwNGhCQWJBR0VNQ1NmRUdodGNnekVJTXNMYUF4S2hiMEx1WUtOMURtRnBhd0NFUzczM2V5Vy82dXZlMmVudDZjblorcTd4bVZkZFhlL2IzL3E5VjEydmpEMXpaUXBtTTQ3QkJCNTFUNWJqVXp6aW5FUmdRVExYVVU0WkVEYkd6SDNYcHBrQU16RTdQMEZBbGtaNkNuTHNDSFZEbmhnRVRVRnMwdXZ0bkNzYVIyK0FLWEFrWnFOdnE1ZW5aTUFnVnRwUWc3UUIrVkZKeVc4WElLZmdEQktnWkR2QVlrZ25ZTGV5RUdicExHcUFhY2dJRlUxRDFRQ1Ryb0F6R0FVQVVzdjZBYUN0Sm40djRPem1nV0VWeDN5Tm1wVk1nN1F5WmNvMEJ6UnBsTnJ0MnpTQklueEFLZDBIU0t1Q2RJOGhVQklqRmtwN1ZXL1F2M0NBZmNWRnJKUFR2VmhrdFNoVDNjYVR5UDBTb1V4T1RIWFdjKzNuTVh2MnVHSkVxRzdCRGdEWHc3c3JyZCtuYnRjaEhaQ0Z1b05EUDNtalhGUnFUelkzTnh2ZXlKWVk2THNEdGRzdFNjQVpNRndvR0k1cEUyQmxZS1hkYnR0MjY1MnZyYmozWGZuQ2tCYU0yNTJIREN4Nmc4WE53UDFTKzhRYWNRY1VyMlp6TTFBSm1JaW9iQTNZR3JCa3lDR0xRTkVaK09hZnhNQ0ZndEVKQ2lVU1ZnWU9jQ1FHQURIdy81QTlpNzVqVXlnczZ3U3Vzcm5MTVNrc2tXVVJSYmk3NmtLaHdQWVVsQ04zQ3E3OFgvdUtwUW5EOERrR0ZsRitMMlhnV3VBTlhQTWRtOE1ENkFRS1VibmdERFRueUxLRWtudDlIVGprbUkyOWFrNmRlMlhBZUFQc0RlU04yenlJME5VR1BHbjk4UERBdmJHenQ2SVRlT1BxM1p2dUZGeTkyOVFHcXAxT2g0a3U3UDN4WVhWSkREU2RnU2lLeEVETEcxanhCb3drVUVlTmhnMzRBKzc1Nk5vNmdadUZ3aHVzV0VZWmNpNDdkaFFzSU5ZRGxZQVlHSFVLNE4vbkFoQURUZG1QL1R5d1JrcVYwY1BRMUZFSHljbmU5LzJBUnhSZkhxaVRWUi9vS1FPTEVzREp1alVZREpyMEhKbDFHaW54TTE0SFhYcEZsU25UYTcrZ3RJSWlhUmsyVEdtRlRYV2Rqd0Rja1dHTm5wOVI5a2VSN3Z2alBCblRYMzdna0N1RmpSaVhXdmh6NUNhZWZuMDN2ZDQ1NTM0UFlXQ05ZRERvYytwNjM5a2JTUUpaZzVlTENMcTIzM3BlMWhtMlYwblV4MU5uS0N4WlN5WlpKWWNuMStzYmNxQm01RHFHZ2U2WW56M2JzcVNxV1JDUzU0MXZPT1l4c0RSK2Y2QnZtVWVTM01WNjRGZ0NRbTBndVJ6ejI1Lzg1STRMb0R4SEl3eXN4cElPVVUzejlydU9mZGt2QjZEeDMvZTladW1xNE5KRy81OHg1a09ndEtNTXNHSGp1TEd4NWc0VTJnQkdKTEN6OVd2TEJaZUFKUWw5QW5uL1NZOUFxQ1h2VTllYXhRTi9qVENsa0dtVWdiZWZQdTI1QUVySjFDNEdnczNBc2hMTGN0bWRjOHVIUXQvdVl6RFlWd1lDbjRRQmZFQ2NxbnJ6L1VYVXRJSFFPL1lCRUFEakRUaXV2Ly8rejFpZWIyRC95OHpMNS9PblFPaktQMWpkdHN6WGc2MjBBZkxpWE1PUWtndytNZFIwQmhwR25Rcmp2Z1NNb09sWnFPdDg0SHpRVVM5ZnN3WTIrcTRwQjlJRytrQmRQL0Z3dmZwNVFIOE45MHpXaVlhWmR3ZFJ3NUJ5TXY3L1R2UWUrWVMwRnVqTTlJUkdhZENqcjd3eVpZcHFicGdCRDBqTE1KMUtDeGcrQU9oNUNuWm8xMDBocjh1ZHhkRzl3NnB0N20yUTAzZEs0UTh0UTVRc0xpTFdIYzl5OG4xQzM3RHNmUkJWbGZPeEJ2TFZoYm9sS3ZQSlpINWd1WkxjeGtjUCtqVjFPUy82ZTl4a2dYc3psdDNDcFZ2TTluWDJsKzlWMnNXTEdERG93M0lYdTlpaFdJLzlWZEYzVWpiL1FFOGJDT1VPYXE1a21HTTJIc3ZESDVRR2NBYXV5VjAxbGVjcmtUYUFXS3o3OWUwRndDVTFEMVNTaTR3M2NDQzNkTnQxVW9rVTVYWFRRcnZ0RXNDZGZVbGc0Qkl3RDcvYkVRTzdPMUhTY1VMMjFBYW9ENWs4ZlFCQktEV3dlM2k0NW9yeFNGNHZEaGtJRUJRdDMwSjVQVkRIRHd1RjhKR2NVOW8rMlVBcWdWWDNWUkxTNFVjZmZ2aGJ5ejFneDMrakVnTXNwK2N3bGhoQlJkZEE2V2JCRjJINVI5WFQxc0FXa1FscmplUXF1VzlaZWZ5NElnVW4xUmQ2QTUzcVhzY2JnSzZCOHExYkpVNkc0YWxHd2VvbEZ5MjZKUHJkdnh4cTVtL1lVVVZKVFB1Y0RFT2Z4SUdxZ2ZLOWUySkFkSUlCcFdDTHRodEVwa1JlZ0MrTlJzQzIrZmtTeElDTG5yNVhDcjlONCtlQktlanJ2NVNFUHFaY1R0VVN5VEI4QVdYS2RQR093NCtCMzlDNWFMZmlMNjdBbzNNSlFJWmxCRGF5WW4vbE9qa2RvMHVpeS9RQ3VnSmNwMGswWHd4MmJBN1dnTXZDWUhpZDc2aXI3aVRrb3FSNHZVblBrdjBuVWNTbUhBTk8yZ0FGN0FOQXpTOTA2cFhQZk8wSGpxUWZURXlpM1dKUWtiY2JRTjlVNWJCbDBhVWpkRlUvcHY0dE9NWXZpSUhqbHpKd0diRzYyc0RsR2ptWjZ3M1hjZ0VvQThVY0hHOVR5d0xld056MUwwbzBnWXp0bUxXQlJLYm96ajhrZ0JNU21Md0lqMUFNN0VlOGJ3MnNTUUpEQ1VuN2hCcVkrT29HSjJzRXZxdWhQOTN3QVp3OENvaHBFaDBETGp1L2VxVnJnRWszVHhiVFMra3o0RmYwVW1MS2xDblRPZWxJY0pscElwbWZrd2dFT28zbWQzekg4RDRtTlFEdkFBVHg4MmJYSGZlbjlLbGJsdTlTM3JKT3RxMHV1MGMxRXNMN1lOT2R6SUIzQUlMM2c2NzdYSis2bnJEYUZRUFNGZ05DZ2REWXpUeWhBZlMwQVd3WkVJRXZRUXhnVlF6NE5ua1lvVGJBUE1zRVJoZ2dubDBOS09rYW1PVW84QW5vVWZBVm5RY29VNlpNcGtmbnFyZk1YeHFXQmgvVGVTaTNhdjVhcEZnTG4rRUJpWXgvOWx3ZnorbHBmczA4cXBEVG0xVmx3UDAweDNOcUNwNjkzajEyVDdVcis5dVdSTVoxOGs3N3hnMk9HZHhvdHgwRHoxYkxjbXF5YS9hUG0vWVU5TmVEUjhwQUlSYkhYRTY0bkhEWmNvb0pFQjAzcEJybTJkS0lnVTZuczljY3o2bnBVcDN5cTY1Zmp2N2dEY3kwQ0JmdzcrT3FHREJQMkRJV3pWSWZvZktBWGwxbHlxU2VFMmpxUmF2UmxQMG1vWlorVGpCTVdiWWJUOW52MVB5eUlzUXFEek5adUJ4UDJlLzBISlovVG1BSk9OWU45MlBlQndOcmxraG9kSHNYOE8vamhFaTNuNUdRUFFFVE15MjFUQThyUzg3M0RFWnNsN1lpS04wbVdLb2ZObzc1Z1JBOGh6Ri9hV2FnaUY3ZUg1aVEyaDVEcUxkN0E2T09ZNUJtU09Fa0J0U1A3bWcwdGFIaEJFbzBCMHgwQ29ZSmVBNGJCSVlTU1JITmNLUUJlVTZnaXMwVzRab3VLaVEwcXEyS2toTWkxWTZSSWtxT3c1cDRtTWwrcCtld0pwNW9aTC9UTTYzSnAxclpieEpteXBUcGYwOEd3Q2s0WGVtL0s5U2NzWUdWZE1ldGxoQW1iWUQ1akF5MDBFb3hNY1NFRkdIT1A0SHpyNEZ6SHdXdnZESmx5clJNWnlGbVNzbUV6ZG4rRDJaTFN5Y1pXRTY0ZEQ0SnlBY1hubDBDWmpuV2tqS0FXR0p0ZVRrSllLWTFjQ3RXVXo3NE5SSktCRE5QSU42ZUJMQTA4d1FrQU5ZQnpId1VHQlhBK2MwREVzQ1oxc0JKTWt2MkgwMWJtZjREM2o5M3Y5aFVqWUFBQUFBQVNVVk9SSzVDWUlJPVwiIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/jquery-ui/themes/base/images/ui-icons_444444_256x240.png\n')},"../node_modules/jquery-ui/themes/base/images/ui-icons_555555_256x240.png":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS90aGVtZXMvYmFzZS9pbWFnZXMvdWktaWNvbnNfNTU1NTU1XzI1NngyNDAucG5nLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdGhlbWVzL2Jhc2UvaW1hZ2VzL3VpLWljb25zXzU1NTU1NV8yNTZ4MjQwLnBuZz8xYjUxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFRQUFBQUR3QkFNQUFBQWR1YWY0QUFBQU1GQk1WRVZNYVhGU1VsSlZWVlZQVDA5VlZWVmVYbDVXVmxaVlZWVlVWRlJWVlZWV1ZsWlVWRlJWVlZWVVZGUlZWVlZWVlZVdGdnRnBBQUFBRUhSU1RsTUFHZjhQTXdkT3hJMmZMQ0ZwUVdEdHlsVGhoQUFBRERsSlJFRlVlQUhzbVF0cUhERVFSRFYxZ2tFbmFQWDlEeG1JZWg0dUZxeUlOVTVpVkh4TWJmOUtMZTJvWjkxK0FnNnUwZjR1ZXQ3dFM2RlZ2dTROeUQ1Ky93MENOOUZubkRKTHdDaERGcjF5VWlxV09lT2p2UWVCZTdoeXVJRHJhV25hQ2hFd0tRSWFVUVR1b1k4bmpncFJuRDAyczdrRERRSTNrVGNGV1l0M2hCV0hkNkN4Ulc5MUFKRFJ0Z1FnZ0RQZ2g1QXo4STNmQXJhSWI4R1BlQkFkSEJ3YzdEOEo4ZCtHSmVCWnIyR0ZsSFVwak5kNVlOSXlkTzByOFFTUGdMekxVSDl5MkRYY0VXQzM1cFVvMzBQUHB5QUN3Z294RDNBdE4rTUZwY3F3aVdTeTZkYUI2M1VldUUxWVVldkFlN2hpYXg2b2NuWUcvc3R2d2ZzNE9EZzRpTld6UGo3MzE1c0Z1SU84a0hLZHorTXl6VUVXWUFiM2p5Z0h4ZVNDV2J5ZXlIQXFrZEZiRXZJRVFieTc4MEZFUmMrLzhsYVFJTXFQT0J6RjlRdzNBZUVUVWxBWTk0cW5OUlNjbit1aklJbENDSFJGalR3QnRRWEw3QXFpZlVzOEFPNGQ4RDMzUFZZNmQwZnMzbWtPbDU4QkFIMy9XN0J0end6akJ3Y0hCOHNmV0JXckg1djllblRXbEJtZjV1dHBDVUM4Qmxpa2VGTjdWcUNzRjd4aDB3RUJ0OTNUYXAzYmk1U1BKNFFBSytEZTZRTkZqNVozTWV1UWhndTRHR1JlbW1ZcnFBQSs2UWdJdHlzMXMweEZZUjNpT2thd1VKN3RKY0ZEVGJHUyt4Nk9uWUlJYVBLQ0pRQkJMb0FGVW9DR2lIeHVKMENCTzF0Z0NjSzNvTGJFdDhBM2ZUd2ZtR0lLNEpjSVJNNDhoTmdSd0NFRUhFS2JkTXJUbHpUODFBYzVBb0c0QSs4QVFQQ1hBWUVIQi84UURtTDM5MUVmRElRaC95eVQwaWdaQ0YrZ2h3OEdnU0c2TDBqTlVZVmplb2pDYVh5SlRPNk9uUGxVM011eXBFQlBsRjFsdGNLQjUxcUEvVHM4YjQyaVByQklvb0FyVTFsRlEzWUU5S0RVNUprSjlkZHRPQlJGZElLcXdYdjkraEJXS3E3ZnRKV0hDY0FnQ2JzTEtPNm5jLzM3KzlDd2VhQW5uUGYrUXRnOGdsQUt3N2UrdU1yYjVnRWIxMzA0dFQrVWtROUszd2VkUisvQndhLzJ6Z0JDa3V5TTQ5KytudHZabVpsdDA1T3pBTDc5ZDAvM2RFLzNYS3ZKdXBORTlKWk5rSVBWbHc2T3NOdGlJK0trYjhKZGhIRG1nTVF4aG9TVFlJME5yc0VZQkJsaFRTQlkwVGNoZDdBeE9nY3NnME1BcE43N1hzbFh2ZDA3TzcwOVBUbGIvelYrODZxcjZ2MzdYKys5cXZmSzJITlhNSjErRENid3NEbFpoc2Q1eFhrR2dRWHhXRWNaWlVCWUh6SDJYWjlrQXN6RTdQd0VBVmthcVNuSXNDUFVoRHcyQ0pxQTJDVFgyem1UTjQ3ZUFGUGdTTXhHVDZ1WEoyVEFJRkxTVUoyMEFmbFJTY2x2bHlDWDRCd1NvSGc3d0dKSUoyQzNzaEJtNlR6YUFOT0FFY3FidW1vRFRMb0ZuRU12QUpCWTFnOEFiVFgyZXdubk53NE1Lai9pTVdwYU1uVktsU3FWMWd6UW9DRjZwZFc2VFdPb2pmY29vUzJBdE1wSTFoZ0NCV2ZFUXVuMmJ1VVZiMUErMk1lZTRnTFd5T2xlSkxKYWtLR3Urcmp0Zm1talNFNU1WZFpqN1JjUmorMTV4WWhRVGNIMkFWZkQyeXZOUHlhbTY1QUt5RUxONEhBWUh5ZzNsZHJqalkyTnVqZlNFUU9IN2tTdFZ0TWxJQVlNNTNLR0k5b0VXQmxZYWJWYXR0eDg2K3NyN3JqWjl3MXB3YmpkZWNEQWdqZVkzd2pjTDdWUHJSRjNRdkZxTmpZQ2xZQnBFeFd0QWRzR0xCbHl5anlRZHdhKytSY3hjQ2xuZElKQ2lZU1ZnWDBjaVFGQURId05rWndqcWRqa2NzczZnV3RzN25KRUNndGttVWNlYmxhZHkrWFlYb0ppMjEyQzJWZGFzNVltRE1ObkdGaEE4WjJFZ2V1Qk4zRGRWMndPOXFFVHlMV0xPV2VnTVVPV0JSVGM1MnZBQVVlczcxWXk2dG9yQThZYllHOGdhOXptdjdmUjB3WThhZTNnWU44ZDJOMWQwUW04ZXUzdVRYY0pydDF0YUFPVmJyZkxSSmQyLy95Z3NpUUdHczVBdTkwV0EwMXZZTVViTUpKQUZUVWFOT0JQdU91amEra0VidVp5cjdKaUVVWEl0ZXphWGpDUFNQZDFBbUpneUNXQVA4NEZJQVlhc2gvN2NXQ1ZsTXJEdTZHcG9ncVNpNzNuNndFUGFYeFpZSjJzK3NDeE1yQWdBWnl1V3ljbkp3MTZoc3dhRFpYNEdhMzlIcVZLOVpMcXlnZVVWSkFuTGNPR0thbXdvZTd6YlFCM0loNUdmT2hIbEwxaHBDMG1wOGNqNnN1ZU9HUUtZVDNDYkJPL2JydUI1N0M2azF6dm5IRy9oekN3UnZEbzBTRW43dmZkM2FFa2tCMTRydVlSOUd5OTFVVlpaOWdza2FpUEo4NVFXTENXVEx4S0RrK3VWcXR5b2tiYlZRd0RYVEYzT2gxTHFwaDVJWG5lK0laakZpZCtaUFRISFZvdUlrN3U4bnB3YkZrQVFtMGd2aDN6bTUvKzlJNExvRGhEUXd5VUlrbUZxQ1I1KzIzSHZ1eVhBVkQvMzNGWExGMHJtSzMyL3gxaExnUUsyOG9BR3phU3dPb3F1eFpnQXhpU3dIYm50NWJ6TGdGTEV2b0VzcEN4L3dpRW1qb3V2dGNzN1B0N2hDbUVUTU1NdlBua3liRUxvQkFQN1dJZzJBZ3N5NUVzbDkwMXQzd2c5T1UrVGs3MmxJSEFKMkVBSHhBbldyMzV3UUpxMmtEb0hmc0FDSUR4Qmh6WDNuMzNseXp2TjdEM05MUHkvZndsRUxybUg1UTJMYlByUVNkcGdMdzRVemVrSkoxUEREV2NnYnBSbDhLNGg0QWhOTWNXNmo0Zk9COTA5SEN4WmcxVSs2NG9KOUlHRG9HcWZ1UGhhdlhqZ0g0TTk0elhpUWFaZFFHb2JrZ1o2Zi8vSkhxSGZFSmE4M1J1ZWt6RGRISk1xVko5NWRXdXVXNEczQ2N0dzNRbXpUOTFBdEN6Rkd6VGpodENyc2pNNHVqZVFZVWk3VmJKNmJ1RjhFZVdvUXdibHhIcGptY3hmcDdRRTViZDkzNVdVYzVIR3NoVzV0Y3RVWjZMQi9OOXk1VjRHdCsrMzYrcDIzbmV6M0hqQmU2TlNIWUxGMjR4MjgvWjM3NUx0UFBsOHhndzZNTnlCenZZbGltVU04SytrcUw1RjQ2MWdWQm1VRE1Gd3h5eGZpZ3ZmMUI0QkdmZ3VzeXFxVGhYYm1zRGlNUzZYbCtlQjF4U2MwRFozMlJpQS92aVozT2RWQ0o1K2R3MDBXcTVCSEJuVHhKNDVCSXdENzdYRlFNNzIrMjRZbVhBVVJ1Z1BtVHc5QUVFb2JTQm5ZT0RWZGNZaitUei9JQ0JBRUhlOGcwVTF3SjEvakNYQzkyRHlXdGwyanpkUUNLQmtudVVoRlQ0eWNjZi85NXlGOWoyVDFSaWdPWHlIRVFTSXlqck5sQzRtZk9OOEQ4L3JweTFEWFNJVEZpcngzZkpQWG1ZM1NwYk1rbnJDNzJCYm1XMzZ3MUF0NEhpclZzRmpydmhtWHBCYWRaRml4NkovdkEzaDVyNUI3WlZveVNtUFk2N29VOWlYN1dCNHIxN1lrQjBpZ0dsb0VPYmRTSlRJQy9BWWVlMWVzQzIrTVVTeElDTG5yNWZDTDlEbzhlQkNlaU5EeVdodjFJbW85b1NTVGQ4RHFWS2RmbU93MCtBMzlHRmFLZE1wQ2VOVXc5QXVtVWJiR1RGZnJaRVRsK2lSNktyOUJ5YUJVbzBqdWJ5d2JiTndScHdXUmdNcnZNZDlkUk1RbTVLaXFVR2RlTDl4MUdiVFRFQ25MUUJDdGdIZ0pwZjZOUXJuOW5hRHgxSnY1Z1lSenY1b0N5SEd6R3dXQ1duRERvV1BUcENUOVZqMXI4TngrZ0RNYkQ1UWdhdUlsSlBHN2hhSXlkVHFydVNDMEFaeUdmZ2VKdWFGdkFHWmtydkYyZ01HVnN4YXdPeFRONWRmMGdBcHlZd2JpTThRajZ3WDNITEdsaVZCQVlTa3ZKcGJXRGN1eHVjckJINHFnYitkTU1IY0hvdklLWnh0QW00N0xLV3g0azJ3S1NMcDR2cGhmUTU4Qkc5a0pndVNLbFNwVG9TWEdVYVMrWlhKQUtCenFLNWJWOHh2STl4RGNBN0FFSDh2TjV6NS8wNWZjWVJTejFhdEt5U2xBbGdxYkJHUW5nZmJIcmpHZkFPUVBCKzBIUGY2ek5YRTBvOU1TQmxNU0FVQ0kzZHpHTWF3RU50QUIwREl2QXN4QUJLWXNDWHljTUl0UUhtYVNZd3hBRHg5TnFBa200RDArd0ZQZ0hkQzc2aTQwQ3FWS25JSE5PRjZsdm1OM1ZMZ3cvcElwUXBtWS95RkduK2M5d25rZkVySnRYUm5Kem1WczBIWlhKNnZhSU11Si9HYUU1TVFlZEtiOU85MVM3dk9SSVpWOGxiclJzM09HSndvOVZ5RER5YlRjdUp5YTdaYnpYc0plaXZCUStWZ1Z3a2pyZ2Njem5tc3VVRUV5Q1NiNTRwemJHbEVRUGRibmUzTVpvVDArdzZaVXV1WG03L3lSdVlhaU9jeHk4MksyTEFQR2JMU0RSTmZZTHlmWHA1bFNxVmVrK2dxUmV0aGxQMkc0ZGErajNCSUdYWmJqUmx2elB6YWJVUnFUakllT0Z5TkdXL3MzTlEvajJCSmVDNGJyZ2ZjUXNNckZvaXB0SGxIY0FmeHpHUkxIZEl5SjZBaVppVVdxYUhsU1ZuancyR2JKZXlJaWhaSmxpcUh6YU9pNCtFNEJtTStFc3pBMFVjWitISWhNVDJDRUs5M1JzWWRoNkRKRU1LeHpHZ2ZuUkZvd2syUXhNbzBBd3cxaVVZSk9BNWFCQVlTQ1JCTk1LaEJ1UTlnV3BzdGhHdTZrYUZtRWFWVmFQa21FaVVJeVNJZ3VPQXh1OW1zdC9aT2FpeEJ4clo3K3hNYXZ5aFZ2WWJoNmxTcGZyL2t3RndCazVXK3U4S05hZHNZQ1ZaY2JNcGhFa2FZRDRuQTAwMEU0d05NU0ZCbUl0UDRPTGJ3SVgzZ3BkZXFWS2xXcWJ6RURNbFpNTEdkUDhIczZXbDB3d3N4MXk2a0FUa2l3dlBNUUd6SEdsSkdVQWtzYmE4SEFjdzFUWndLMUpEdnZoMUVrb0VVMDhnMmg0SHNEVDFCQ1FBMWdGTXZSY1lGY0JGalFNU3dEbTNnZE5rbHV3L21yUlMvUmNtYjJwa0lPZjdOZ0FBQUFCSlJVNUVya0pnZ2c9PVwiIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/jquery-ui/themes/base/images/ui-icons_555555_256x240.png\n')},"../node_modules/jquery-ui/themes/base/images/ui-icons_777620_256x240.png":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS90aGVtZXMvYmFzZS9pbWFnZXMvdWktaWNvbnNfNzc3NjIwXzI1NngyNDAucG5nLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdGhlbWVzL2Jhc2UvaW1hZ2VzL3VpLWljb25zXzc3NzYyMF8yNTZ4MjQwLnBuZz84ODQ3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFRQUFBQUR3QkFNQUFBQWR1YWY0QUFBQU1GQk1WRVZNYVhGNWVSNTNkaUJ3Y0I5NGVCNS9meDUzZFI5MmRSOTJkU0IzZFI5M2RpQjNkeDUzZFI5MmRoOTNkUjkyZFNEeDVrQWNBQUFBRUhSU1RsTUFHZjhQTXdoT3Y1Q2ZMQ0Z5UVdMTlFxVCtaQUFBREMxSlJFRlVlQUhzbVF0dTNEQU1STzA1Z2FFVFVMei9JUXRVOUVNbUMwUVZIS1RkUW9QUFlwYS9FU1ZiM09UWStCOXc5dVB2b3VWMWZDczB5OWU4QWRuNjc4OGdjQkZ0eENtekJQUXlaTkV6QjZWaW1UTSsybHNRdUlZenV3czQ3NWFtclJBQmd5TGdJSXJBTmJSK3gxRWhpdHNlWXpaM29FN2dJdktpSUd2eGpyRGk4QTRjYk5HakRnQXkycFlBQkhBRy9CQnlCbjcyS1dDTGVBcmUvMFcwc2JHeHNmNG14SDhWSlBCM3Zib1ZVdGFsMEYvbmdVSEwwTFN1eEJQY0F2SXFRMzFrdDJ1NEljQnV6VE5Sdm9hV2QwRUVCSVZzSHVCYVBvd1hsQ3JESXBMSnBsa0h6dGQ1NERKaFJhMER6M0RHMGp4UTVmd012T05UOEJ3Ykd4c2JNWHZYeDlmK2VsaUFPOGdMS2VmNVBDN1RIR1FCYmpEL2lISlFEQzZZeGV1T0RLY1NHYjBsSVU4UXhPUHVYMFJVOVBpVXQ0SUVVWDdFNFNpdVo3Z0pDSitRZ3NLNFZ6eXRvZUQ0WGg4RlNSUkM0Q2RGNUFtb0xWaG1WeER0VytJQmNPK0E3N252c2RLNU8yTDNUbk80L0F3QTZQT25ZTmxlbmQvWTJOZ0Eweit3S21aL2JQYnI4Uk5UWm55WnI2VWxBUEVhWUpIaWw5cTlBbVg5d09zMkhSQncyVDJ0bzNGN2tmTDJoQkJnQmR3N2ZhQm9jZVJWekRxazdnSk9CcG1YcHRrS0tvQnZHZ0xDN1VxTkxFTlJXSWU0amhFc2xJK3lsdUNtcGxqSmZRL0hUa0VFSFBLQ0pRQkJMb0FGVW9DR2lIeHVKMENCTzF0Z0NjSzNvTGJFdDhBM3ZkOWZtR0lLNEpjSVJNNDRoTmdSd0NFRUhFS2JkTXJUbDlUOTFBYzVBb0c0QStzQVFQRDNBSUgvR0RZMk5tSnhIZ2dmRElRaC95eVQwaWdaQ0orZ2hROEdnU0dhTDBpSG93ckg4QkNGMC9nVW1kd2RPZktwdUpkbFNZR2VLTHZLYW9VRHo3a0ErM2Q0WHVwRmZXQ1JSQUZYcHJLS2hxd0lhRUdwd1RNVDZqKzM0VkFVMFFtcUJyL3I1NGV3VW5IOXBxMDhUQUFHU2RoZFFIRS9uZk8vdjNkMW13ZGF3cXNRUFErYlJ4QktZZmpTZzZ1OGJCN3djZDJHVS91Z2pIeFEramxvdjNvM2ZyVjNCaENTWkdjYy8vYjFaUGRtNXJaM3VuTVd3TGYvcnVtWjdwbnViVFZaRjhtSjNySUpjbkQ2MHNFUmRsdHNSQnh6RXc0aHhBWkFHRVBDQ2JIR0J0ZGdESUtNc1BhQVJPaWJrRHZZYUoxRFdOb2FBT0ZTNzMydjVLdStucDJkM3A2ZU8xdi9NMzd6cXF2cS9mdGYzM3MxOWNxNlRHZXVjRGJqR0V6Z2NjOWtPVDdGSzg1SkJCWWtjeDNsbEFGaDQ1aTU3OW8wRTJBbVp1Y25ETW5TU0U5aGpoMmhIc2dUZzZBcGlFMTZ2WjF6SmVQb0RUQ0Zqc1JzOUdOMWNVb0dER0tsRFRWSUc1QWZsWlQ4ZGdGeUNjNGdBVXEyQXl5R2RBSjJLd3RobHM2aUJwaEdqRkRKTkZRTk1La0tPSXRSQUNDMXJCOEMybXJpOXdMT2JoNFlWWW5HcVVpemttbFFwa3ladE9hQUpvMVR1MDJUcUlQM0thVjdBR2xWa080eEFnSXhZcUcwVy9VRy9RZjcyRk5jeEJvNTNZMUZWb3N5MWEwLzdyaGZPaWlURTFPZDlWejdXY3krUGE4WUVhcEhzSDNBOWZET2N1dVBxY2QxU0Fka29aN2dNRWdPbEp0SzdmSEd4a2JERzlrVUF3TjNvbmE3SlFrNEE0WUxCY014YlFLc0RDeTMyMjNiYnIzOWpXVjMzSlhQRFduQnVOMTV4TUNpTjFqYUNOMHZ0WSt0RVhkQzhXbzJOa0tWZ09rUWxhMEJXd09XRERsbENTZzVBOS8raXhpNFVEQTZRYUZFd3NyQVBnN0ZBQ0FHdmc3WnMrUTdOb1ZDVVNkd2xjMGRqa2xSUUpZbGxPQ2VxZ3VGQXR0TFVPNjRTM0RsYSswcmxpYUtvbWNZV0VUNTNaU0JhNkUzY00xM2JBNzJvUk1vZE1vRlo2QTVSNVlCQXZmNUduREFNUnU3MVp5NjlzcUE4UWJZRzhnYnQzbllRVThiOEtTMWc0TjlkMkIzZDFrbjhOclZPemZkSmJoNnA2a05WTHZkTGhOZDJQM3pnK3FTR0dnNkE1MU9Sd3kwdklGbGI4QklBblhVYU5TQVArR3VqNjZ0RTdoWktMekdpbVdVSWRleWEwZkJBbUxkVndtSWdYR1hBUDQ0RjRBWWFNcCs3T2VCVlZLcWpCK0dwbzQ2U0M3Mm51OEhQS2I0OGtDZHJBWkFYeGxZbEFCTzFxM2hjTmlrWjhpczBWaUpuK08xMzZOTW1WNVN2ZklyU2lzc2taWmh3NVJXMUZUMytRNkEyektzMGZjenl0NDQwajBtcDhmSDlKY2ZPdVNDcUJIalVndC83YmlKWjFEZlNhOTN6cm5mSXhoWUl4Z09CNXk2MzNkM3g1SkExdURsRXNLZTdiZWVsM1dHclJVU0RmREVHWW9DYThra3ErVHc1UFgxZFRsUnMrTTZob0h1bUo4KzNiU2txbGtRa3VlTmJ6bm1NYlEwZm45Z1lKbEhrdHpGZXVnWUFKRTJrTnlPK2MyUGYzYmJCVkNlb3pFR1ZtSkpoNmltK2RZN2pnUFpMd2VnOGYvalhyRjBWWEJwZmZEdkdQTVJFR3dyQTJ6WStBUlcyVldBRFdCTUF0dWJ2N1ZjY0FsWWt0QW5rUGZmOUJDRVduS2N1dGNzN3Z0N2hBa2lwbkVHM256eXBPOENDSktwWFF5RUc2RmxKWlpsMFY1enh3ZWUwaDVnT054VEJrS2ZoQUY4UUp5cWV2UERSZFMwZ2NnNzlnRVFBT01OT0s2OTk5NHZXTjV2WU8rTHpQdnZKNWRBNk1vL1hObXl6TmZEemJRQjh1SmN3NUNTREQ0eDFIUUdHa1pkQ3VQK0NCaEQwN2RROS9uUSthRERmcjVtRGF3UFhGTk9wQTBNZ0xwKzQrRjY5Zk9BL2pQY00xa25HbVhlblVRTlE4ckorUDhuMGJ2a0U5SmFvRFBUWXhxbllaOHlaZnJLcTFOend3eTRUMXFHNlZSYXdPZ0pRTTlTdUUwN2JncDVWWjRzRHU4ZVZHMXpkNTJjdmhkRVA3YU1FRmhjUkt6Ym51WGs3d245d0xMN2ZxZXFuUjluSUY5ZHFGdWlNcDlNNXZ1V3k4bGpmT2Yrb0tadTV5WC9qSnNzY0cvRXNsczR1TVZzUDJkLysxNmhIVHlQQVlNQkxIZXdnMjJLOWNqZkZYMG5aZk12OUxXQlNKNmc1Z0xESExQeGlNZ2FRRENFTTNCTm5xcXBQRi9wYUFPSXhicGYzMTRBWEZMelFNWGZaQklEKy9KSXQxVW5sVWhKUGpjdHROc3VBZHpla3dTR0xnSHo0UHRkTWJDejNVazZWZ1ljdFFFYVFDWlBIMEFZU1Ezc0hCeXN1bUk4bE05TEl3WkNoQ1hMTjFCZUM5WDVvMEloZWlqWGxMYWV3NEJPWU1VR0VFQTYvUENERDM1dnVRdHMrNytveEFETDVUbUlKVVpRMFRVUTNDejRJaXovcEhyYUd0Z2tNbEd0a2R3bDl5d3JqeDVWTEptaytpSnZvRnZkN1hvRDBEVlF2blVyNEdRWW5tb1VyRnh5MGFKSG9qLzh4NkZtL29GdFZaVEV0TWZKTVBSSjdLc2FLTis5S3daRUp4aFFDamRwcTBGa0F2SUNmR2swUXJiTno1WWdCbHowOUlNZytpNGROdzlNUmQvOHRTVDBFZVZ5cXBaSWhtR21UTStoaTdjZGZncjhqczVGT3hWL2N3VWVua3NBTWl3N1lDTXI5bGV1azlNUmVpUzZUTStoSzhCMW1rVHpwWERiNW1BTnVDd01SdGY1RG52cVNVSnVTb3JYbS9RMDJYOFNkZGlVWThCSkc2Q1FmUUNvK1lWT3ZmS1pyLzNJa2ZTTGlVbTBVd29yY3JnQjlFTlZEcHNXUFRwRVQvVmo2dCtCWS95QkdEaDZJUU9YRWF1bkRWeXVrWk81M25BdEY0QXlVTXJCOFMxcVdjQWJtTHYrZVVBVHlOaU9XUnRJWkVydStrTUNPQ0dCeVl2d0VLWFFmc1Y3MXNDcUpEQ1NrTFJQcW9GSjcyNXdza2JndXhyNXB4cytnSk5IQVRGTm9pUEFaZWRYcjNRTk1Pbm15V0o2SVgwSy9JWmVTRXpucEV5Wk1oMEtMak5OSlBOTEVvRkFwOUg4dHU4WTNzZWtCdUFkZ0NCK1h1KzU4LzZjUG5ITDhqM0tXOWJKdHRWdDk3QkdRbmdmYkhxVEdmQU9RUEIrMEhQZjZ4UFhFMVo2WWtEYVlrQW9FQnE3bVNjMGdMNDJnRTBESXZBbGlBR3NpQUhmSmc4ajFBYVlaNWJBZUFQRXM2c0JKVjBEc3h3RlBnRTlDcjZpOHdCbHlwVEo5T2xjOVliNVc4UFM0Q002RCtWV3pOOUxGR3ZoVTl3bmtmSHZudXZIY29xYVh6VVBLK1QwZWxVWmNEL05Zems5aFU5ZjdSMjV0OXFWdlMxTEl1TTZlYnQ5NHdiSERHKzAyNDZoWjZ0bE9UWFpOZnRIVFhzSkJtdmhRMldnRUl0akZoTVdFeFl0cDVnQTBWRkRxbUdlTFkwWTZIYTd1ODFqT1QxZHFsTit4ZlhMblQ5NUF6TXR3Z1g4OTZncUJzeGp0b3hGczlTSHFOeW5USmxlWHFuM0JKcDYwV284WmI5SnFLWGZFNHhTbHUyT3AreDNlbjVCSGNRcWp6Slp1RHllc3QvcE9Tci9uc0FTY0t3YkhzUzhCd1pXTFpIUTZQWU80SS9qaEVpM241S1FQUUVUTXkyMVRBOHJTODczRGNac2w3WWlLTjBtV0tvZk5vNzVvUkE4aDNFR21NaEFFZjA4SEptUTJoNURxTGQ3QStQT1k1Qm1STkVFQnZUUCtJNDB0YUhSQkFLYUF5YTZCS01FUEVjTkFpT0pwSWhtTk02QXZDZlF4V2FMY0ZVWEZSSWExVlpGeVFtUmFzZElFWUhqcUNZZVpyTGY2VG1xaVNjYTJlLzBUR3Z5cVZiMm00U1pNbVg2OHNrQU9BMm5LdjN2Q2pWbmJHQTUzWEdySllSSkcyQStJd010dEJLbURERWhSWmp6VCtEOGErRGNSOEZMcjB5Wk1oWHBMTVJNS1ptb09kdi9nOW5TMGtrR2lnbVh6aVVCK2VMQ00wekFGR010S1FPSUpkYUt4U1NBbWRiQXJWaE4rZUxYU0NnUnpEeUJlSHNTd05MTUU1QUFXQVV3KzFGZ1ZBRG5OdzlJQURPYUI4YkxMTm4vS05PMDlUL0x3SGRyM3oyemFRQUFBQUJKUlU1RXJrSmdnZz09XCIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/jquery-ui/themes/base/images/ui-icons_777620_256x240.png\n')},"../node_modules/jquery-ui/themes/base/images/ui-icons_777777_256x240.png":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS90aGVtZXMvYmFzZS9pbWFnZXMvdWktaWNvbnNfNzc3Nzc3XzI1NngyNDAucG5nLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdGhlbWVzL2Jhc2UvaW1hZ2VzL3VpLWljb25zXzc3Nzc3N18yNTZ4MjQwLnBuZz8wZTNiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFRQUFBQUR3QkFNQUFBQWR1YWY0QUFBQU1GQk1WRVZNYVhGNWVYbDNkM2R3Y0hCNGVIaC9mMzkzZDNkMmRuWjJkblozZDNkM2QzZDNkM2QzZDNkMmRuWjNkM2QyZG5iMDB3bXBBQUFBRUhSU1RsTUFHZjhQTXdoTnY1Q2ZMQ0Z5UUdMTnFGRXZVQUFBRERGSlJFRlVlQUhzbVF0dTNEQU1STzA1Z2FFVFVMei9JUXRVOUVNbUMwUVZIS1RkUW9QUFlwYS9FU1ZiM09UWStCOXc5dVB2b3VWMWZDczB5OWU4QWRuNjc4OGdjQkZ0eENtekJQUXlaTkV6QjZWaW1UTSsybHNRdUlZenV3czQ3NWFtclJBQmd5TGdJSXJBTmJSK3gxRWhpdHNlWXpaM29FN2dJdktpSUd2eGpyRGk4QTRjYk5HakRnQXkycFlBQkhBRy9CQnlCbjcyS1dDTGVBcmUvMFcwc2JHeHNmNG14SDhWSlBCM3Zib1ZVdGFsMEYvbmdVSEwwTFN1eEJQY0F2SXFRMzFrdDJ1NEljQnV6VE5Sdm9hV2QwRUVCSVZzSHVCYVBvd1hsQ3JESXBMSnBsa0h6dGQ1NERKaFJhMER6M0RHMGp4UTVmd012T05UOEJ3Ykd4c2JNWHZYeDlmK2VsaUFPOGdMS2VmNVBDN1RIR1FCYmpEL2lISlFEQzZZeGV1T0RLY1NHYjBsSVU4UXhPUHVYMFJVOVBpVXQ0SUVVWDdFNFNpdVo3Z0pDSitRZ3NLNFZ6eXRvZUQ0WGg4RlNSUkM0Q2RGNUFtb0xWaG1WeER0VytJQmNPK0E3N252c2RLNU8yTDNUbk80L0F3QTZQT25ZTmxlbmQvWTJOZ0Eweit3S21aL2JQYnI4Uk5UWm55WnI2VWxBUEVhWUpIaWw5cTlBbVg5d09zMkhSQncyVDJ0bzNGN2tmTDJoQkJnQmR3N2ZhQm9jZVJWekRxazdnSk9CcG1YcHRrS0tvQnZHZ0xDN1VxTkxFTlJXSWU0amhFc2xJK3lsdUNtcGxqSmZRL0hUa0VFSFBLQ0pRQkJMb0FGVW9DR2lIeHVKMENCTzF0Z0NjSzNvTGJFdDhBM3ZkOWZtR0lLNEpjSVJNNDRoTmdSd0NFRUhFS2JkTXJUbDlUOTFBYzVBb0c0QStzQVFQRDNBSUgvR0RZMk5tSnhIZ2dmRElRaC95eVQwaWdaQ0orZ2hROEdnU0dhTDBpSG93ckg4QkNGMC9nVW1kd2RPZktwdUpkbFNZR2VLTHZLYW9VRHo3a0ErM2Q0WHVwRmZXQ1JSQUZYcHJLS2hxd0lhRUdwd1RNVDZqKzM0VkFVMFFtcUJyL3I1NGV3VW5IOXBxMDhUQUFHU2RoZFFIRS9uZk8vdjNkMW13ZGF3cXNRUFErYlJ4QktZZmpTZzZ1OGJCN3djZDJHVS91Z2pIeFEramxvdjNvM2ZyVjNCaENTWkdjYy8vYjFaUGRtNXJaM2VuSVd3TGYvN3VtWjdwbnViVFZaRjhtSjNySUpjckQ2MG9jRHN5VTJJbzY1Q1ljUVlnTWdqQ0hoaEZoamcyc3dCa0ZHV0h0QUl2Uk55QjFzdE00aExHME5nSENwOTc1WGw2LzZ1bmQyZW1kNjdtejl6L2pOcTYycTkrOS9mZTlWMXl2ak1wMjVndW1NWXpDQlJ6MlQ1ZmdFcnpnblVkTHRGM05kVGhrUU5zYk1mZGRPTXdGbVluWitBcGM1alBRVTVOZ1I2b0U4TVFnNkJiRkpyN2R6cm1nY3ZRR213SkdZalg2c1hqd2xBd2F4MG9ZYXBBeklqMDVLZnJzQXVRUm5rTUFYMndFV1F6b0J1NVdGTUF0blVRTk1RMGFvYUJxcUJwaFVCWnpGS0VoT0RMODlBTFRWeE84Rm5OMDhNS3ppK0s5UlU1RnBVS1pNbWJSbWdDYU5VcnQ5bXlaUWhQY3BwWHNBYVZXUTdqRUVTczZJZzlKdTFSdjAvN0NQUGNWNXJKTFQzVmhrTlM5VDNkcmp5UDBTb1V4T1RIWFdjKzFuTVh2dXZNNklVRDJDN1FPdWgzZVdXbjlNUGE1RE9pQUw5UVNIZm5LZzNGUnFqOWZYMXh2ZXlLWVk2THNUdGRzdGw0QVlNRndvR0k1cEUyQmxZS25kYnR0MjY2MXZMYm5qcm54dVNBdkc3YzVEQnVhOXdlSjY0SDZwZmV5TTJCT0tWN08rSHFnRVRFUlV0Z1pzRFZneTVKUkZvT2dNZlBjdll1QkN3ZWdFaFJJSkt3UDdPQlFEZ0JqNEptVFBvdS9ZRkFxTE9vR3JiTzV3VEFwTFpGbEVFZTZwdWxBb3NMMEU1Y2hkZ2l2ZmFGK3hOR0VZUHNQQVBNcnZwZ3hjQzd5QmE3NWpjN0FQblVBaEtoZWNnZVlNV1paUWN2KytDaHh3ek1adU5hZXV2VEpndkFIMkJ2TEdiUjVFNkdvRG5yUjZjTER2RHV6c0x1a0VYcnQ2NTZhN0JGZnZOTFdCYXFmVFlhSUx1MzkrVUYwUUEwMW5JSW9pTWREeUJwYThBU01KMUZHallRUCtoTHMrdXJaTzRHYWg4Qm9ybGxHR1hNdU9IUVZ6aUhWZkpTQUdSbDBDK09QUVRReWdLZnV4bndkV1NLa3llaGlhT3VvZ3VkaDd2aC93aU9MTEEzV3k2Z005WldCZUFqaGV0d2FEUVpPZUliTktJeVYreG11L1N5K3BNbVY2NVZlVVZsQWtMY09HS2Eyd3FlN3pFWUFOR2RibytSbGxieFRwbmovUDR6SDk1UWNPdVZMWWlIR3BoYjlHYnVMcDEzZlM2NTB6N3ZjUUJ0WUlCb00rcCs3M25kMlJKSkExZUxtSW9HdjdyZWRsbldGcm1VUjlQSEdHd3BLMVpKSlZjbmp5MnRxYW5LZ1p1WTVob0R2bXAwODNMYWxxNW9Ua2VlTTdqbmtNL016b2ordGI1cEVrZDdFZU9KYUFVQnRJYnNmODVzYy8yM0FCbEdkb2hJSGxXTklocW1uZWZzZXhML3ZsQURUK2Y5d3JscTRLTHEzMS94MWpOZ1JLMjhvQUd6WStnUlYzb3RBR01DS0I3YzNmV3M3WkJCekpVeExJKzA5NkNFSk5IWmZjYStiMy9UM0NsRUttVVFiZWZQS2s1d0lvSlZPN0dBaldBOHRLTE10RmU4MGRId2g5dTQvQllFOFpDSHdTQnZBQmNhcnF6ZHZ6cUdrRG9YZnNBeUFBeGh0d1hIM3Z2Vit3dk4vQTNwZVo5NTlQTG9IUWxYK3d2R1dacndlYmFRUGt4Ym1HSVNVWmZHS282UXcwakxvVXhuMEpHRUhUczFEMytjRDVvTU5ldm1ZTnJQVmRVMDZrRGZTQnVuN2o0WHIxODREK0d1NlpyQk1OTSs5T29vWWg1V1Q4LzVQb1hmSUphYzNSbWVreGpkS2dSMTk3WmNvVTFkd3dBKzRQdjE4OGtlWXdmQUxRc3hSczA0NmJRbDZWSjR2RHV3ZFYyOXhkSTZjZmxNSWZXNFl5YlZ4RXJBM1Bjdko5UWordzdMNGZWYlh6Y1FieTFibTZKU3F6eVdTK2I3bVVQTVpIOS9zMWRUc3YrbWZjWklGN1BaYmR3cVZiN0I1SzJkKytsMmtIejJQQW9BL0xIZXhnbTJJOThuZEYzMG5aL0FzOWJTQ1VKNmlaa21HTzJYZ2tMMzlRR3NBWnVDWlAxVlNlclVUYUFHS3g3dGUzNXdDWDFDeFFTVzR5M3NDK1BOSnQxVWtsVXZUM2loYmFiWmNBTnZZa2dZRkx3RHo0WVVjTTdHeEhTY2NKMlZNYm9ENWs4dlFCQktIVXdNN0J3WW9yeGtQNTkrS1FnUUJCMGZJTmxGY0RkZjZ3VUFnZnlqV2xyZU1OcEJKWWRsOGxJUjErK01FSHY3ZmNCYmI5TnlveHdISjVEbUtKRVZSMERaUnVGbndSbG45U1BXa05iQktac05aSTdwSjdscFZIanlwU2NGSjlvVGZRcWU1MnZBSG9HaWpmdWxYaVpCaWVhQlFzWDNMUm9rdWlQL3pIb1diK2dXMVZsTVMweDhrdzlFbnNxeG9vMzcwckJrVEhHRkFLTm1tclFXUks1QVg0MG1nRWJKdWZMVUFNdU9qcFI2WHcrelIrSGpnRmZmdlhrdEJIbE11cFdpSVpocytoVEprdWJqajhGUGdkbll0Mkt2N21Danc4bHdCa1dFWmdJeXYyVjY2VDB4RzZKTHBNejZFcndIV2FSTFBGWU52bVlBMjRMQXlHMS9rT3UrcEpRbTVLaXRlYjlEVFpmeEpGYk1veDRLUU5VTUErQU5UOFFxZGUrY3lYMzNZay9XSmlFdTBVZzRvY2JnRDlVSlhEcGtXWER0RlYvWmo2OStDNFFaRVlPSG9oQTVjUnE2c05YSzZSazduZWNDMFhnREpRek1IeE5yVXM0QTNNWFArOFJCUEkySTVaRzBoa2l1NzZRd0k0Tm9GSmkvQVF4Y0IreEh2V3dJb2tNSlNRdEkrcGdZbnZibkN5UnVDN0d2clREUi9BOGFPQW1DYlJFZUN5ODZ0WHVnYVlkUE40TWIyUVBnVitReThrcGt5Wk1wMlREZ1dYbVNhUytTV0pRS0NUYUhiYmR3enZZMUlEOEE1QUVEK3ZkOTE1ZjA2ZnVHWDVMdVV0NjJUYjZyWjdXQ01odkE4MjNja01lQWNnZUQvb3VzLzFpZXNKeTEweElHMHhJQlFJamQzTUV4cEFUeHZBcGdFUitCTEVBSmJGZ0crVGh4RnFBOHpUU21DTUFlS3AxWUNXcm9GcGpnS2ZnQjRGWDlONWdESmx5bVI2ZEs1NncveXQ0WHpnSXpvUDVaYk4zNHNVYSs1VDNDZVI4ZStlNitONWVwcGRNUThyNVBSNlZSbHdQODN4UERVRlQxL3RIcm0zMnBXOXJZYjA3enA1cTMzakJzY01iclRiam9GbnEyVjVhckpyOW8rYTloTDBWNE9IeWtBaEZzZGNUTGlZY05IeUZCTWdPbXBJTmN5eXBSRURuVTVudHptZXA2WkxkY292dTM0NStwTTNNTlVpbk1OL2o2cGl3RHhtU3pFd1BYMkl5bjE2cVpVcGs3d25HS1lzV28ybjdEY0p0ZlI3Z21IS3N0MTR5bjRuNXBjVklWWjVtTW5DNVhqS2ZpZm5zUHg3QWt2QXNXNjRIL01lR0ZpeFJFS2oyenVBUDQ0VEl0MStTcjd0Q1ppWWFhbGxlbGhaY3I1bk1MdzlhV3VDMG0yQ1ovTER4akUvRUlKbk1PWXZ6UXdVMGN2N0V4TlMyMk1JOVhadllOUjVETklNS1p6RWdQcFJIWTJoTmpTY1FJbG1nSWt1d1RBQnoyR0R3RkFpS2FJWmpqSWc3d2wwc2RraVhORkZoWVJHdFZWUmNrS2syakZTUk1seFdCTVBNOW52NUJ6UzVCT043SGR5cGpYNVZDdjdUY0N2b0RKbHltUUFuSVNuS3YxM2hacFROckNVN3JqVkVzS2tEVENma1lFV1dnbFRocGlRSXN6NUozRCtOWEQrb3lCVHBrd3Z1eGJwTE1STUtabXdPZDMvZzluQ3duRUdGaE11bkVzQzhzR0ZaNWlBV1l5MW9Bd2dsbGhiWEV3Q21Hb04zSXJWbEE5K2pZUVN3ZFFUaUxjbkFTeE1QUUVKZ0ZVQTB4OEZSZ1Z3ZnZPQUJIQ0dOWEM4eklMOWp6S2R0djRINGFwMTM4SG96SUVBQUFBQVNVVk9SSzVDWUlJPVwiIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/jquery-ui/themes/base/images/ui-icons_777777_256x240.png\n')},"../node_modules/jquery-ui/themes/base/images/ui-icons_cc0000_256x240.png":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,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");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS90aGVtZXMvYmFzZS9pbWFnZXMvdWktaWNvbnNfY2MwMDAwXzI1NngyNDAucG5nLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdGhlbWVzL2Jhc2UvaW1hZ2VzL3VpLWljb25zX2NjMDAwMF8yNTZ4MjQwLnBuZz9hYjJkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFRQUFBQUR3QkFNQUFBQWR1YWY0QUFBQU1GQk1WRVZNYVhITkFBRE1BQURPQUFETkFBREFBQURNQUFETUFBRExBQURNQUFET0FBRE1BQURMQUFETEFBRE1BQURNQUFDTEZuY3RBQUFBRUhSU1RsTUFHZjhQTXdoTnY1Q2ZMU0Z5UUdMTll3Mzg5UUFBREMxSlJFRlVlQUhzbVF0dTNEQU1STzA1Z2FFVFVMei9JUXRVOUVNbUMwUVZIS1RkUW9QUFlwYS9FU1ZiM09UWStCOXc5dVB2b3VWMWZDczB5OWU4QWRuNjc4OGdjQkZ0eENtekJQUXlaTkV6QjZWaW1UTSsybHNRdUlZenV3czQ3NWFtclJBQmd5TGdJSXJBTmJSK3gxRWhpdHNlWXpaM29FN2dJdktpSUd2eGpyRGk4QTRjYk5HakRnQXkycFlBQkhBRy9CQnlCbjcyS1dDTGVBcmUvMFcwc2JHeHNmNG14SDhWSlBCM3Zib1ZVdGFsMEYvbmdVSEwwTFN1eEJQY0F2SXFRMzFrdDJ1NEljQnV6VE5Sdm9hV2QwRUVCSVZzSHVCYVBvd1hsQ3JESXBMSnBsa0h6dGQ1NERKaFJhMER6M0RHMGp4UTVmd012T05UOEJ3Ykd4c2JNWHZYeDlmK2VsaUFPOGdMS2VmNVBDN1RIR1FCYmpEL2lISlFEQzZZeGV1T0RLY1NHYjBsSVU4UXhPUHVYMFJVOVBpVXQ0SUVVWDdFNFNpdVo3Z0pDSitRZ3NLNFZ6eXRvZUQ0WGg4RlNSUkM0Q2RGNUFtb0xWaG1WeER0VytJQmNPK0E3N252c2RLNU8yTDNUbk80L0F3QTZQT25ZTmxlbmQvWTJOZ0Eweit3S21aL2JQYnI4Uk5UWm55WnI2VWxBUEVhWUpIaWw5cTlBbVg5d09zMkhSQncyVDJ0bzNGN2tmTDJoQkJnQmR3N2ZhQm9jZVJWekRxazdnSk9CcG1YcHRrS0tvQnZHZ0xDN1VxTkxFTlJXSWU0amhFc2xJK3lsdUNtcGxqSmZRL0hUa0VFSFBLQ0pRQkJMb0FGVW9DR2lIeHVKMENCTzF0Z0NjSzNvTGJFdDhBM3ZkOWZtR0lLNEpjSVJNNDRoTmdSd0NFRUhFS2JkTXJUbDlUOTFBYzVBb0c0QStzQVFQRDNBSUgvR0RZMk5tSnhIZ2dmRElRaC95eVQwaWdaQ0orZ2hROEdnU0dhTDBpSG93ckg4QkNGMC9nVW1kd2RPZktwdUpkbFNZR2VLTHZLYW9VRHo3a0ErM2Q0WHVwRmZXQ1JSQUZYcHJLS2hxd0lhRUdwd1RNVDZqKzM0VkFVMFFtcUJyL3I1NGV3VW5IOXBxMDhUQUFHU2RoZFFIRS9uZk8vdjNkMW13ZGF3cXNRUFErYlJ4QktZZmpTZzZ1OGJCN3djZDJHVS91Z2pIeFEramxvdjNvM2ZyVjNCaENTWkdjYy8vYjFaUGRtNXJaM2VuSVd3TGYvN3VtWjdwbnVhVFZaRjhtSjNySUpjbkQ2MG9jRHN5VTJJbzY1Q1ljUVlnTWdqQ0hoaEZoamd4c3dCa0ZHV0h0QUl2Uk55QjFzdE00aExHME5nSENwOTc1WDhsVmY5ODVPYjAvUG5hM2ZHYitwMnVwNi8vN3F2YXArcjQwN2R6S0M2WXhqTUlHSHpjbHlmSWF2T01jQkxLTGtYcGRUQWNTTkVmZStHNU9zQURNeHV6eEJRTlpHV2dweTdBdzFJVThDZ2lZQW0vUjZPK2VLeHRrSFlBcWNpZG5vYWZYaWhBSVl4S1FETlVnRmtCOWRLZm50RXVRU25FTUZLTmtQc0FUU0ZiQjdXUXl6Y0I1OWdHa2dDQlZOUS9VQkp0MER6bUVVQUVndDZ3ZUFqcHJrdllUenV3OE1VaHp4TVdwYW1BWnBNakl5Wm9BbURhUGRwbkdJOEFHbHVBZVFwb0owaXlGUWtpQldpcjJxRCtqLzRSQUh5dk5ZSmNmZEdMTE15NjF1N1hIa2ZvbFFKZ2RUbmZXOTl2UFlYWHRlQ1NKV1U3QkR3TFh3N2xMcmo2bnBPcVFCc2xJek9QU1NGOHBEcGZaNFkyT2o0WU5zU1lDZU8xRzczWklLdUFDR0N3WERzVzBGV0FWWWFyZmJkcnYxOXJlVzNPdXVmV0ZJQStNTzU0RUE4ejVnY1NOd3Y5UStjVUhzQ1NXcjJkZ0lWQVZNUkZTMkFXd2ZzR2JJS1l0QTBRWDQ3bDhrd0tXQzBSVVVTMGxZQlRqRXNRUUFKTUEzSVVjV2ZjT21VRmpVRmJqTzVnN0hwckJFMWtVVTRXYlZoVUtCN1NVb1IrNFNYUHRHKzVxMUNjUHdHUUhtVVg0dkZlQkc0QVBjOEEyYm8wUG9DaFNpY3NFRmFNNlFkUWtsVU13cWNNU3hHM3ZWbkxyMktvRHhBZGdIeUJ1M3V4K2hvd040MCtyUjBhRVBzS1FyOE5yMU83ZmNKYmgrcDZrQzJPTnRnRXQ3ZjM1UVhaQUFUUmNnaWlJSjBQSUJsbndBSXhXb28wYURBU2ltdXIrLzUwdlgxaFc0VlNpOHhzcGxsQ0hYY3QrT2dqbkUzTmNWa0FCRExnSDg2MXdCSkVCVGptTi9IMWdoUldYNE1EUjExRUZ5c1E5OE8rQWhuUzhQMU1uU0E3b3F3THdVNEhSdTkvdjlKajBEczBwRGtUeWpPZXpRUzBwR3hpdS9valJCa1RTR0RWT2FzS21lOHhHQVRSblc2UG83eXNFdzB6MG14K01SN2VYN1RybFMySWgxcFlXL1J1N0cwNnZ2cHRjN1o5enZJUXhzRVBUN1BVNDk3L2YzaHBwQU51RFZJb0tPYmJlZWwzV0c3V1VTZW5qaUFvVWxHOGtrcStUdzVyVzFOVGxSTTNJTncwQTN6RStmYmxsVDFjeUp5ZnZtZDV6ejZGc2JmenpRczg0anFkemxldUJjQWtJZElIa2M4NXVmL0d6VEZhQThRME1DTE1kSWc2aW0vZGE3emowNUxnZWc4Zi9YdldMdGVzR1Z0ZDYvWTgyR1FHbEhCV0REeGxkZ2hWMFBzQVVZVW9HZHJkOWF6N3NLV0pQWVZ5RHYzK2t4Q0xYa2RlcFpNMy9vbnhHbUZESU5DL0Rta3lkZFY0QlNjbXVYQU1GR1lGMkpzVjUwMTl6NmdiZHM5OUR2SDZnQWdhK0VBWHlCT05YcnpUdnpxT2tBb1Uvc0MwQUFqQS9ndlByKys3OWcrWDREQjE5MjNyOC91UVJpMS8yRDVXM3JmRDNZU2djZ0QrY2FoaFF5K0NSUTB3Vm9HSFVwalBzUU1NU21hNldlODRITFFjZmRmTTBHV091NVRUbVJEdEFENnZvYkQ5ZXF2dy9vaitIZXlUclJvUFB1SkdvWVVrN0cveitKM2lOZkljMGNuUnVQYVJqOUxuM3R5Y2lJYW02WXVkR29NRXhuWWc2NFR4b0RlaGJCRHUwMktPWlZtVmtjM3oycVVzemVHamwrVUFwL2JCMmlaSFVaTVp2ZTVlVHpoSjZ3N0gwUVZYWHlVUUh5MWJtNk5TcXp5YzM4MEhvcG1jWkg5M3MxOVRnditqbHVzc0M5RVdQM2NPazJ1MGtwKzhmM011M2llUUlZOUdDOWkxM3NVTXdqLzFUMGpaVE52OURWQVVLWlFjMlVESFBzeGlNaUd3Q2xQbHlBR3pLcnB2SnNKZElCRU1PNlhiODlCN2hLelFLVjVDSGpBeHpLbEc2N1Rxb2lSZitzYUtIZGRoWEE1b0ZVb084cVlCNzhjRjhDN081RVNjTXFnTE1PUUQzSXpkTVhJQWlsRCt3ZUhhMjR6bmdzLzE0Y0NCQWdLRnEvZ2ZKcW9NNGZGZ3JoUTdtbXRIMTZnRlFGbHQxSFNVaURIMzM0NGUrdDk0QWQvNGxLQXJCY25xTVlDWUtLN2dPbFd3WGZDY3MvcVo2MUQyd1JtYkRXa0tla0g0YVZSNDhxMHVHazk0VSt3SDUxYjk4SGdPNEQ1ZHUzUzV3TXd6T05ndVVycnJUb2tQQ0gvempWekQrd296b2xNUjF3TWd4OUpRNVZIeWpmdlNzQmhGTUNLSUl0Mm00UW1SSjVBTjgxR2dIYnpjOFhJQUZjNmVsSHBmRDdOT28rTUJHKy9XdXAwTWVVeTZtK1JESU1NektlZzh1YlRqOEZma2NYd203RlAxeUJoeGRTQUJtV0VkaklpdjIxZFhLY29FUENWWG9PcmdIck5BNnp4V0RIMXNFR2NMVXdHRnpuTys2b21ZUThsSlRYbS9RME9YNGNJamJsV0hEb0FCU3dMd0JxZnFGVHIzem15Ky9VMVJMcytBRjJpMEZGWG00QVBhbktZY3VxUThmb3FIWk0vWHR3M3FSSUFweThVSUNyaU9ub0FGZHI1RERyRGJmbENxQUNGSE53Zm90YVZ2QUJadGEvS05FWUdOc3c2d0FKcHVpdVA2UUFwMVJnL0U1NGpHSmczK0k5RzJERlZ5QmRJZGsrcFErTS9YU0R3d2FCYjJyZ1R6ZDhBVTRmQmNRMERpZUlXZGVyVjFJQkNhQTJUNGZwaGZnTStBMjlFRXdYUkVaR3hySG9LdE5ZbUYrU0FBS2RoZGtkM3pCOGpuRUR3Q2NBUWZLODNuSG4vVGw5NnBibE81UzNycFBkVm8vZDR4cUo0WE93Nll3WHdDY0F3ZWRCeDcydlQxMUxXTzVJQU5tV0FHS1IyTmpkUEdZQWRIVUFiQmtRZ2E5QUFtQlpBdmh0OGpKaUhZQjVtaFVZRW9CNGFuMUFvL3ZBTkVlQnI0QWVCVi9UK3dCbFpHU1lMbDBvYjVpL05hd05QcWFMSUxkcy9sNmttTG5QY0o4RTQ3OTdyby8wQkpsZE1ROHI1SGk5cWdLNG4rWklUNDdnNmF1ZEUzc05UT1ZnMjVySXVFYmVidCs4eWJHRG0rMjJjK0RkYWxsUERMdG0vNmhwTDBGdk5YaW9BaFJpT1BaaTRzWEVpOVlUckFEUlNVTjZ3eXhiR3dtd3Y3Ky8xeHpweVhHbFR2bGwxeTVIZi9JQnB0b0o1L0RmazZvRU1JL1pPb2FteVVlbzNLZU1qSmNYOVQyQnRsNjBHbTQ1Ymh4cjlQY0VnNVpsdTlHVzQ4N3VMeEVocGp6b1pPRnl0T1c0czNzUS96MkJOZUJjTjl5TGZROE1yRmdqc2RIYnU0Qi9IU2RHZXZzcGlka2JNTEhUcUdWNldLdzUzelVZc2wrMmxVSHBiWUsxK21Iam5PK0x3VE1ZOFpkbUJzcm81dUhNaE5UK1dHSzkzd2NZZGg2RHRFTUt4d21nZm5SRG93MDJReXRRb2hsZ3JFc3dhTUI3TUNBd1VKR1UwUXlIQlpEdkNYUm5zNTF3UlhjcUpEWnFXM1ZLVG96VWRxeVVVWEllWVB4aEpzZWQzUU9NZjZPUjQ4N3VOT1BmYXVXNGNaeVJrZkhWd3dBNGl5ZUsvcnRDN1NrSFdFbzMzR3FKWWRJQm1NOHBRQXV0eEtsQVRFZ1o1dUlyY09GOTRPSkh3VXRQUmtiR0lwMEh6SlRDaE0zcC9oL01GaFpPQzdDWWVPRmlLaUJ2WEh4K0ZUQ0xNUXNxQUdJazJ1SmlVb0NwOW9IYk1VMTU0emRJTENXWWVnWGkvVWtCRnFaZUFTa0Fxd0pNZnhRWVZZQ0x1dzlJQWM2MUQ1eUdXYkQvVWNhaytSOC9ESFgzT0FUK25nQUFBQUJKUlU1RXJrSmdnZz09XCIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/jquery-ui/themes/base/images/ui-icons_cc0000_256x240.png\n')},"../node_modules/jquery-ui/themes/base/images/ui-icons_ffffff_256x240.png":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAADwBAMAAAAduaf4AAAAMFBMVEVMaXH////////////////////////////////////////////////////////////6w4mEAAAAEHRSTlMAGf8PMwhOv5CfLSFzQWLNMURKpAAADC9JREFUeAHsmQtu3DAMRO05gaETULz/IQtU9EMmC0QVHKTdQoPPYpa/ESVb3OTY+B9w9uPvouV1fCs0y9e8Adn6788gcBFtxCmzBPQyZNEzB6VimTM+2lsQuIYzuws475amrRABgyLgIIrANbR+x1EhitseYzZ3oE7gIvKiIGvxjrDi8A4cbNGjDgAy2pYABHAG/BByBn72KWCLeAre/0W0sbGxsf4mxH8VJPB3vboVUtal0F/ngUHL0LSuxBPcAvIqQ31kt2u4IcBuzTNRvoaWd0EEBIVsHuBaPowXlCrDIpLJplkHztd54DJhRa0Dz3DG0jxQ5fwMvONT8BwbGxsbMXvXx9f+eliAO8gLKef5PC7THGQBbjD/iHJQDC6YxeuODKcSGb0lIU8QxOPuX0RU9PiUt4IEUX7E4SiuZ7gJCJ+QgsK4VzytoeD4Xh8FSRRC4CdF5AmoLVhmVxDtW+IBcO+A77nvsdK5O2L3TnO4/AwA6POnYNlend/Y2NgA0z+wKmZ/bPbr8RNTZnyZr6UlAPEaYJHil9q9AmX9wOs2HRBw2T2to3F7kfL2hBBgBdw7faBoceRVzDqk7gJOBpmXptkKKoBvGgLC7UqNLENRWIe4jhEslI+yluCmpljJfQ/HTkEEHPKCJQBBLoAFUoCGiHxuJ0CBO1tgCcK3oLbEt8A3vd9fmGIK4JcIRM44hNgRwCEEHEKbdMrTl9T91Ac5AoG4A+sAQPD3AIH/GDY2NmJxHggfDIQh/yyT0igZCJ+ghQ8GgSGaL0iHowrH8BCF0/gUmdwdOfKpuJdlSYGeKLvKaoUDz7kA+3d4XupFfWCRRAFXprKKhqwIaEGpwTMT6j+34VAU0QmqBr/r54ewUnH9pq08TAAGSdhdQHE/nfO/v3d1mwdawqsQPQ+bRxBKYfjSg6u8bB7wcd2GU/ugjHxQ+jlov3o3frV3BhCSZGcc//b15PZm5rZ3enIWwLf/7umZ7pnuaTVZF8mJ3rIJcrD60sERdktsRBxzEw4hxAZAGEPCCbHGBjdgDIKMsPaAROibkDvYaJ1DWNoaAOFS732v5Ku+7p2dykxPztZvjd9Ud3W9f3/vvaqu18aeOznBdOYxmMDj7skKnOErztMAFlFyriuoAOLWhHPf9bOsADMxuzxBQNZGWgoK7Ax1Q54EBJ0BbNLr7VwoG2cfgClwJmajb6sXzyiAQUw6UItUAPnRlZLfLkG64BwqQMnjAEsgXQH7KIthFs5jDDCNBKGyaakxwKRHwDnMAgCpZf0A0FGTvJdwfueBUcoTPkZNC9MiTU5OzgzQpnF0u7cpAxHepxT3AdLUkG4xBCoSxEqxW/cB/RMH2Feexyo57sWQZV5OdWtPIvdLhCo5mJqsz7Wfxe7b40oQsboFOwBcC+8sdX6ful2HNEBW6g4Og+SFclFpPNnY2Gj5IJsSYOAO1O12pAIugOFSyXBsWwFWAZa63a7d7rz9tSX3uqufG9LAuN15JMC8D1jeCNwvjY9dEHtAyWo2NgJVARMRVW0AOwasGXLIMlB2Ab75JwlwqWR0BcVSElYBDnAkAQAJ8FXInmXfsCmVFnUFrrG5y7EprJB1GWW4u+pSqcS2C6qR64KrX+letTZhGD4nwDyq76YCXA98gOu+YXN4AF2BUlQtuQDtGbKuoOKeXwUOOXZrt15Qfa8CGB+AfYCicQ8PI/R0AG9aPTw88AGWdAVev3b3puuCa3fbKoDd3wa4tPvHh/UFCdB2AaIokgAdH2DJBzBSgSYaNBqAYup7e7u+dF1dgZul0uusXEUV0pd7dhbMIeaBqoAEGNcF8K9zBZAAbdmP/XlghRS18dPQNNEESWfv+3bAYwZfEWiSZQD0VYB5KcDJ3BoOh216DmaVxiJ5JnPQo5eUnJxXf0FpgjJpDBumNGFbXecjAHdkWqPvzyj740z3mRxPJrRXHDoVKmEr1uUO/hy5E8+guZNe75xxv4cwsEEwHA44db3f2x1rAtmAV8oIerbdZlHWGbaWSRjgqQsUVmwkk6ySw5ubzTU5UDtyDcNAN8zPnm1aU93Micn7xjecixhaG78/MLAuIqncK83AuQKEOkByOea3Pv7JHVeA6gyNCbAcIw2invbtd5wHsl8BQOu/r3vV2o2Cy2uDf8aaDYHKtgrAho3z2toKuxFgCzCmAtubv7aedxWwJrGvQNG/0yMQGup1ybVm/sBfI0wlZBoX4K2nT/uuAJXk1C4Bgo3AuhZjvej63Pqh2G8PMBzuqwCBr4QBfIE4NerN9+fR0AFCn9gXgAAYH8B59b33fsby/Qb2v+iif3/SBWI3/IPlLetiM9hMByAPF1qGFDL5JFDbBWgZ1RXGfQgYY9O3Utf5wOWgo36xYQOsDdymHEgHGABN/Y2Ha9WfB/THcO9knWjURXcQNQ2pIPP/70Tvkq+QZo7OjSc0jmGfvvTk5EQNN83cbFQYplMxBzwgjQE9j2CbdloU85rcWRzdO6xTzO4aOb5TCX9oHaJi9Qpi7nhXk88T+oZl9/2orpNPClCszzWtUZtNTuYH1kvJbXz0YNBQl/Oyv8dNFrg3YuwjXLnFbJ9nf/leph28SACDAax3sINtinnsr4q+kar5B/o6QCh3UDMVwxy79ZjIBkBlCBfgutxVU3W2FukAiGHdrt+eA1ylZoGav8gkAQ7klm6rSaoiZXnedNDtugrgzr5UYOgqYB5+d08C7GxHScMqgLMOQAP0yeILEIQyBnYOD1fcYDyS58sjAQIEZes3UV0N1PHDUil8JH1KWycGSFdg2X2UhDT44Qcf/NZ6F9j2n6gkAEv3HMZIENT0GKjcLPlBWP1R/bRjYJPIhI2WXCX9NKw9flyzZpLRF/oAe/XdPR8AegxUb92qcDINTzULli+70qJHwu/+5dQwf8O2GpTEtM/JNPSVOFBjoHrvngQQTgigCDZpq0VkKuQB/NBoBWw3P1uABHClp+9Vwm/T5PPAGfD1X0qFPqJCQY0lkmn4AuTkvHLH6cfAb+hC2Kn5iyvw6EIKINMyAhtZsb+6To5j9Ei4Qi/AVWCdsjBbDrZtHWwAVwuD0XW+o566k5CLkvJ6m54l+2chYlONBYcOQAH7AqDhFzr1ymex8YOmWoLNHmCnHNTk5QbQN1UFbFr16Ag91Y5pfgvO8RMS4Ph/CnAFMT0d4EqDHGa95bZcAVSAcgHOt6ljBR9gZv3zCmXA2IZZB0gwZdf/kAKcWIGsg/AI5cC+xfs2wIqvQLpCsn3CGMh8dYPDBoFvauRPN3wBTp4FxJSFY8Ssq9UrqYAE0Jsnw6KsfAr8yjo7TBdETk7OkegKUybMz0kAgU7D7LZvGD5H1gDwCUCQPG/03HF/Sp+4ZfkeFa2bZLfVZfeoQWL4HGx62QL4BCD4POi59/WJawnLPQkg2xJALBIb+zBnDIC+DoBNAyLwZUgALEsAv01eRqwDME+tAuMDEE9vDCj0GJjmLPAV0LPgS3oeoJycHNOnC+VN85eWtcFHdBEUls1fyxQz9ykekGD8d8/NyT47ZlfMoxo53qirAO6nPdlnRvDstd6x7QNT29+yJjKukbe7N25w7OBGt+sceHc61meGXbN/3LZdMFgNHqkApRiOvZh4MfGi9RlWgOi4JaNhlq2NBNjb29ttT/aZcblJxWXXLkd/8AGmOgjn8O/jugQwT9g6hqbJh6g9oJeXnBz1PYG2XrQab9kvizX6e4JRy7LdZMt+p/YXiRBTHXWycDnZst/pPYr/nsAacG4aHsS+DwZWrJHY6O0dwL+OEyO9/YzE7A2Y2GnUMj0s1lzsG4x5XLaVQeltgrX6YeNcHIrBM5jwl2YGyugX4cyE1OOxxPpxH2DccQzSDinMEkD96IYmG2zGVqBCM0CmLhg14D0aEBipSMpoh+MCyPcEerDZQbiiBxUSG7WtBiUnRmo7VsqoOI+SeZrJfqf2KNlPNLLf6Z0m+6lW9svg/0NycnIMgNP4TNF/V6g95QBL6YY7HTFMOgDzOQXooJNyEogJKcNcfAUufgxc/CzIycl52Vmk84CZUpiwPd3/wWxh4aQAi4kXLqYC8sbF51cBsxizoAIgRqItLiYFmOoYuBXTljd+ncRSgqlXIH48KcDC1CsgBWBVgOnPAqMKcHHnASnAOY6BkzEL9h/lnDX/AVibeCdFAPuVAAAAAElFTkSuQmCC");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS90aGVtZXMvYmFzZS9pbWFnZXMvdWktaWNvbnNfZmZmZmZmXzI1NngyNDAucG5nLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdGhlbWVzL2Jhc2UvaW1hZ2VzL3VpLWljb25zX2ZmZmZmZl8yNTZ4MjQwLnBuZz8wNmFlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFRQUFBQUR3QkFNQUFBQWR1YWY0QUFBQU1GQk1WRVZNYVhILy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vNnc0bUVBQUFBRUhSU1RsTUFHZjhQTXdoT3Y1Q2ZMU0Z6UVdMTk1VUktwQUFBREM5SlJFRlVlQUhzbVF0dTNEQU1STzA1Z2FFVFVMei9JUXRVOUVNbUMwUVZIS1RkUW9QUFlwYS9FU1ZiM09UWStCOXc5dVB2b3VWMWZDczB5OWU4QWRuNjc4OGdjQkZ0eENtekJQUXlaTkV6QjZWaW1UTSsybHNRdUlZenV3czQ3NWFtclJBQmd5TGdJSXJBTmJSK3gxRWhpdHNlWXpaM29FN2dJdktpSUd2eGpyRGk4QTRjYk5HakRnQXkycFlBQkhBRy9CQnlCbjcyS1dDTGVBcmUvMFcwc2JHeHNmNG14SDhWSlBCM3Zib1ZVdGFsMEYvbmdVSEwwTFN1eEJQY0F2SXFRMzFrdDJ1NEljQnV6VE5Sdm9hV2QwRUVCSVZzSHVCYVBvd1hsQ3JESXBMSnBsa0h6dGQ1NERKaFJhMER6M0RHMGp4UTVmd012T05UOEJ3Ykd4c2JNWHZYeDlmK2VsaUFPOGdMS2VmNVBDN1RIR1FCYmpEL2lISlFEQzZZeGV1T0RLY1NHYjBsSVU4UXhPUHVYMFJVOVBpVXQ0SUVVWDdFNFNpdVo3Z0pDSitRZ3NLNFZ6eXRvZUQ0WGg4RlNSUkM0Q2RGNUFtb0xWaG1WeER0VytJQmNPK0E3N252c2RLNU8yTDNUbk80L0F3QTZQT25ZTmxlbmQvWTJOZ0Eweit3S21aL2JQYnI4Uk5UWm55WnI2VWxBUEVhWUpIaWw5cTlBbVg5d09zMkhSQncyVDJ0bzNGN2tmTDJoQkJnQmR3N2ZhQm9jZVJWekRxazdnSk9CcG1YcHRrS0tvQnZHZ0xDN1VxTkxFTlJXSWU0amhFc2xJK3lsdUNtcGxqSmZRL0hUa0VFSFBLQ0pRQkJMb0FGVW9DR2lIeHVKMENCTzF0Z0NjSzNvTGJFdDhBM3ZkOWZtR0lLNEpjSVJNNDRoTmdSd0NFRUhFS2JkTXJUbDlUOTFBYzVBb0c0QStzQVFQRDNBSUgvR0RZMk5tSnhIZ2dmRElRaC95eVQwaWdaQ0orZ2hROEdnU0dhTDBpSG93ckg4QkNGMC9nVW1kd2RPZktwdUpkbFNZR2VLTHZLYW9VRHo3a0ErM2Q0WHVwRmZXQ1JSQUZYcHJLS2hxd0lhRUdwd1RNVDZqKzM0VkFVMFFtcUJyL3I1NGV3VW5IOXBxMDhUQUFHU2RoZFFIRS9uZk8vdjNkMW13ZGF3cXNRUFErYlJ4QktZZmpTZzZ1OGJCN3djZDJHVS91Z2pIeFEramxvdjNvM2ZyVjNCaENTWkdjYy8vYjE1UFptNXJaM2VuSVd3TGYvN3VtWjdwbnVhVFZaRjhtSjNySUpjckQ2MHNFUmRrdHNSQnh6RXc0aHhBWkFHRVBDQ2JIR0JqZGdESUtNc1BhQVJPaWJrRHZZYUoxRFdOb2FBT0ZTNzMydjVLdSs3cDJkeWt4UHp0WnZqZDlVZDNXOWYzL3Z2YXF1MThhZU96bkJkT1l4bU1Eajdza0tuT0VyenRNQUZsRnlyaXVvQU9MV2hIUGY5Yk9zQURNeHV6eEJRTlpHV2dvSzdBeDFRNTRFQkowQmJOTHI3VndvRzJjZmdDbHdKbWFqYjZzWHp5aUFRVXc2VUl0VUFQblJsWkxmTGtHNjRCd3FRTW5qQUVzZ1hRSDdLSXRoRnM1akREQ05CS0d5YWFreHdLUkh3RG5NQWdDcFpmMEEwRkdUdkpkd2Z1ZUJVY29UUGtaTkM5TWlUVTVPemd6UXBuRjB1N2NwQXhIZXB4VDNBZExVa0c0eEJDb1N4RXF4Vy9jQi9STUgyRmVleHlvNTdzV1FaVjVPZFd0UEl2ZExoQ281bUpxc3o3V2Z4ZTdiNDBvUXNib0ZPd0JjQys4c2RYNmZ1bDJITkVCVzZnNE9nK1NGY2xGcFBOblkyR2o1SUpzU1lPQU8xTzEycEFJdWdPRlN5WEJzV3dGV0FaYTYzYTdkN3J6OXRTWDN1cXVmRzlMQXVOMTVKTUM4RDFqZUNOd3ZqWTlkRUh0QXlXbzJOZ0pWQVJNUlZXMEFPd2FzR1hMSU1sQjJBYjc1Sndsd3FXUjBCY1ZTRWxZQkRuQWtBUUFKOEZYSW5tWGZzQ21WRm5VRnJyRzV5N0VwckpCMUdXVzR1K3BTcWNTMkM2cVI2NEtyWCtsZXRUWmhHRDRud0R5cTc2WUNYQTk4Z091K1lYTjRBRjJCVWxRdHVRRHRHYkt1b09LZVh3VU9PWFpydDE1UWZhOENHQitBZllDaWNROFBJL1IwQUc5YVBUdzg4QUdXZEFWZXYzYjNwdXVDYTNmYktvRGQzd2E0dFB2SGgvVUZDZEIyQWFJb2tnQWRIMkRKQnpCU2dTWWFOQnFBWXVwN2U3dStkRjFkZ1p1bDB1dXNYRVVWMHBkN2RoYk1JZWFCcW9BRUdOY0Y4Szl6QlpBQWJkbVAvWGxnaFJTMThkUFFOTkVFU1dmdiszYkFZd1pmRVdpU1pRRDBWWUI1S2NESjNCb09oMjE2RG1hVnhpSjVKblBRbzVlVW5KeFhmMEZwZ2pKcERCdW1OR0ZiWGVjakFIZGtXcVB2enlqNzQwejNtUnhQSnJSWEhEb1ZLbUVyMXVVTy9oeTVFOCtndVpOZTc1eHh2NGN3c0VFd0hBNDRkYjNmMngxckF0bUFWOG9JZXJiZFpsSFdHYmFXU1JqZ3FRc1VWbXdrazZ5U3c1dWJ6VFU1VUR0eURjTkFOOHpQbm0xYVU5M01pY243eGplY2l4aGFHNzgvTUxBdUlxbmNLODNBdVFLRU9rQnlPZWEzUHY3SkhWZUE2Z3lOQ2JBY0l3MmludmJ0ZDV3SHNsOEJRT3UvcjN2VjJvMkN5MnVEZjhhYURZSEt0Z3JBaG8zejJ0b0t1eEZnQ3pDbUF0dWJ2N2FlZHhXd0pyR3ZRTkcvMHlNUUd1cDF5YlZtL3NCZkkwd2xaQm9YNEsyblQvdXVBSlhrMUM0QmdvM0F1aFpqdmVqNjNQcWgyRzhQTUJ6dXF3Q0JyNFFCZklFNE5lck45K2ZSMEFGQ245Z1hnQUFZSDhCNTliMzNmc2J5L1FiMnYraWlmMy9TQldJMy9JUGxMZXRpTTloTUJ5QVBGMXFHRkRMNUpGRGJCV2daMVJYR2ZRZ1lZOU8zVXRmNXdPV2dvMzZ4WVFPc0RkeW1IRWdIR0FCTi9ZMkhhOVdmQi9USGNPOWtuV2pVUlhjUU5RMnBJUFAvNzBUdmtxK1FabzdPalNjMGptR2Z2dlRrNUVRTk44M2NiRlFZcGxNeEJ6d2dqUUU5ajJDYmRsb1U4NXJjV1J6ZE82eFR6TzRhT2I1VENYOW9IYUppOVFwaTduaFhrODhUK29abDkvMm9ycE5QQ2xDc3p6V3RVWnROVHVZSDFrdkpiWHowWU5CUWwvT3l2OGRORnJnM1l1d2pYTG5GYko5bmYvbGVwaDI4U0FDREFheDNzSU50aW5uc3I0cStrYXI1Qi9vNlFDaDNVRE1Wd3h5NzlaaklCa0JsQ0JmZ3V0eFZVM1cyRnVrQWlHSGRydCtlQTF5bFpvR2F2OGdrQVE3a2xtNnJTYW9pWlhuZWRORHR1Z3JnenI1VVlPZ3FZQjUrZDA4QzdHeEhTY01xZ0xNT1FBUDB5ZUlMRUlReUJuWU9EMWZjWUR5UzU4c2pBUUlFWmVzM1VWME4xUEhEVWlsOEpIMUtXeWNHU0ZkZzJYMlVoRFQ0NFFjZi9OWjZGOWoybjZna0FFdjNITVpJRU5UMEdLamNMUGxCV1AxUi9iUmpZSlBJaEkyV1hDWDlOS3c5Zmx5elpwTFJGL29BZS9YZFBSOEFlZ3hVYjkycWNESU5UelVMbGkrNzBxSkh3dS8rNWRRd2Y4TzJHcFRFdE0vSk5QU1ZPRkJqb0hydm5nUVFUZ2lnQ0RacHEwVmtLdVFCL05Cb0JXdzNQMXVBQkhDbHArOVZ3bS9UNVBQQUdmRDFYMHFGUHFKQ1FZMGxrbW40QXVUa3ZITEg2Y2ZBYitoQzJLbjVpeXZ3NkVJS0lOTXlBaHRac2IrNlRvNWo5RWk0UWkvQVZXQ2RzakJiRHJadEhXd0FWd3VEMFhXK281NjZrNUNMa3ZKNm01NGwrMmNoWWxPTkJZY09RQUg3QXFEaEZ6cjF5bWV4OFlPbVdvTE5IbUNuSE5UazVRYlFOMVVGYkZyMTZBZzkxWTVwZmd2TzhSTVM0UGgvQ25BRk1UMGQ0RXFESEdhOTViWmNBVlNBY2dIT3Q2bGpCUjlnWnYzekNtWEEySVpaQjBnd1pkZi9rQUtjV0lHc2cvQUk1Y0MreGZzMndJcXZRTHBDc24zQ0dNaDhkWVBEQm9GdmF1UlBOM3dCVHA0RnhKU0ZZOFNzcTlVcnFZQUUwSnNudzZLc2ZBcjh5am83VEJkRVRrN09rZWdLVXliTXowa0FnVTdEN0xadkdENUgxZ0R3Q1VDUVBHLzAzSEYvU3ArNFpma2VGYTJiWkxmVlpmZW9RV0w0SEd4NjJRTDRCQ0Q0UE9pNTkvV0phd25MUFFrZzJ4SkFMQkliK3pCbkRJQytEb0JOQXlMd1pVZ0FMRXNBdjAxZVJxd0RNRSt0QXVNREVFOXZEQ2owR0pqbUxQQVYwTFBnUzNvZW9KeWNITk9uQytWTjg1ZVd0Y0ZIZEJFVWxzMWZ5eFF6OXlrZWtHRDhkOC9OeVQ0N1psZk1veG81M3FpckFPNm5QZGxuUnZEc3RkNng3UU5UMjkreUpqS3VrYmU3TjI1dzdPQkd0K3NjZUhjNjFtZUdYYk4vM0xaZE1GZ05IcWtBcFJpT3ZaaDRNZkdpOVJsV2dPaTRKYU5obHEyTkJOamIyOXR0VC9hWmNibEp4V1hYTGtkLzhBR21PZ2puOE8vanVnUXdUOWc2aHFiSmg2ZzlvSmVYbkJ6MVBZRzJYclFhYjlrdml6WDZlNEpSeTdMZFpNdCtwL1lYaVJCVEhYV3ljRG5ac3QvcFBZci9uc0FhY0c0YUhzUytEd1pXckpIWTZPMGR3TCtPRXlPOS9ZekU3QTJZMkduVU1qMHMxbHpzRzR4NVhMYVZRZWx0Z3JYNlllTmNISXJCTTVqd2wyWUd5dWdYNGN5RTFPT3h4UHB4SDJEY2NRelNEaW5NRWtEOTZJWW1HMnpHVnFCQ00wQ21MaGcxNEQwYUVCaXBTTXBvaCtNQ3lQY0VlckRaUWJpaUJ4VVNHN1d0QmlVblJtbzdWc3FvT0krU2VackpmcWYyS05sUE5MTGY2WjBtKzZsVzlzdmcvME55Y25JTWdOUDRUTkYvVjZnOTVRQkw2WVk3SFRGTU9nRHpPUVhvb0pOeUVvZ0pLY05jZkFVdWZneGMvQ3pJeWNsNTJWbWs4NENaVXBpd1BkMy93V3hoNGFRQWk0a1hMcVlDOHNiRjUxY0JzeGl6b0FJZ1JxSXRMaVlGbU9vWXVCWFRsamQrbmNSU2dxbFhJSDQ4S2NEQzFDc2dCV0JWZ09uUEFxTUtjSEhuQVNuQU9ZNkJrekVMOWgvbG5EWC9BVmliZUNkRkFQdVZBQUFBQUVsRlRrU3VRbUNDXCIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/jquery-ui/themes/base/images/ui-icons_ffffff_256x240.png\n')},"../node_modules/jquery-ui/themes/base/tabs.css":function(module,exports,__webpack_require__){eval('\nvar content = __webpack_require__(/*! !../../../css-loader??ref--4-1!./tabs.css */ "../node_modules/css-loader/index.js?!../node_modules/jquery-ui/themes/base/tabs.css");\n\nif(typeof content === \'string\') content = [[module.i, content, \'\']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {"hmr":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../../style-loader/lib/addStyles.js */ "../node_modules/style-loader/lib/addStyles.js")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS90aGVtZXMvYmFzZS90YWJzLmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3RoZW1lcy9iYXNlL3RhYnMuY3NzPzY5Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNC0xIS4vdGFicy5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS00LTEhLi90YWJzLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNC0xIS4vdGFicy5jc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/jquery-ui/themes/base/tabs.css\n')},"../node_modules/jquery-ui/themes/base/theme.css":function(module,exports,__webpack_require__){eval('\nvar content = __webpack_require__(/*! !../../../css-loader??ref--4-1!./theme.css */ "../node_modules/css-loader/index.js?!../node_modules/jquery-ui/themes/base/theme.css");\n\nif(typeof content === \'string\') content = [[module.i, content, \'\']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {"hmr":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../../style-loader/lib/addStyles.js */ "../node_modules/style-loader/lib/addStyles.js")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS90aGVtZXMvYmFzZS90aGVtZS5jc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS90aGVtZXMvYmFzZS90aGVtZS5jc3M/NjM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS00LTEhLi90aGVtZS5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS00LTEhLi90aGVtZS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTQtMSEuL3RoZW1lLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/jquery-ui/themes/base/theme.css\n')},"../node_modules/jquery-ui/ui/core.js":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// This file is deprecated in 1.12.0 to be removed in 1.14\n( function() {\n"use strict";\n\n!(__WEBPACK_AMD_DEFINE_FACTORY__ = ([\n\t"jquery",\n\t"./data",\n\t"./disable-selection",\n\t"./focusable",\n\t"./form",\n\t"./ie",\n\t"./keycode",\n\t"./labels",\n\t"./jquery-patch.js",\n\t"./plugin",\n\t"./safe-active-element",\n\t"./safe-blur",\n\t"./scroll-parent",\n\t"./tabbable",\n\t"./unique-id",\n\t"./version"\n]),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} )();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS9jb3JlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvY29yZS5qcz8yMGRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBpcyBkZXByZWNhdGVkIGluIDEuMTIuMCB0byBiZSByZW1vdmVkIGluIDEuMTRcbiggZnVuY3Rpb24oKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuZGVmaW5lKCBbXG5cdFwianF1ZXJ5XCIsXG5cdFwiLi9kYXRhXCIsXG5cdFwiLi9kaXNhYmxlLXNlbGVjdGlvblwiLFxuXHRcIi4vZm9jdXNhYmxlXCIsXG5cdFwiLi9mb3JtXCIsXG5cdFwiLi9pZVwiLFxuXHRcIi4va2V5Y29kZVwiLFxuXHRcIi4vbGFiZWxzXCIsXG5cdFwiLi9qcXVlcnktcGF0Y2guanNcIixcblx0XCIuL3BsdWdpblwiLFxuXHRcIi4vc2FmZS1hY3RpdmUtZWxlbWVudFwiLFxuXHRcIi4vc2FmZS1ibHVyXCIsXG5cdFwiLi9zY3JvbGwtcGFyZW50XCIsXG5cdFwiLi90YWJiYWJsZVwiLFxuXHRcIi4vdW5pcXVlLWlkXCIsXG5cdFwiLi92ZXJzaW9uXCJcbl0gKTtcbn0gKSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/jquery-ui/ui/core.js\n')},"../node_modules/jquery-ui/ui/keycode.js":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery UI Keycode 1.13.2\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n */\n\n//>>label: Keycode\n//>>group: Core\n//>>description: Provide keycodes as keynames\n//>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/\n\n( function( factory ) {\n\t"use strict";\n\n\tif ( true ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "../node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "../node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n} )( function( $ ) {\n"use strict";\n\nreturn $.ui.keyCode = {\n\tBACKSPACE: 8,\n\tCOMMA: 188,\n\tDELETE: 46,\n\tDOWN: 40,\n\tEND: 35,\n\tENTER: 13,\n\tESCAPE: 27,\n\tHOME: 36,\n\tLEFT: 37,\n\tPAGE_DOWN: 34,\n\tPAGE_UP: 33,\n\tPERIOD: 190,\n\tRIGHT: 39,\n\tSPACE: 32,\n\tTAB: 9,\n\tUP: 38\n};\n\n} );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS9rZXljb2RlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkva2V5Y29kZS5qcz85YTAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IFVJIEtleWNvZGUgMS4xMy4yXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IEtleWNvZGVcbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBQcm92aWRlIGtleWNvZGVzIGFzIGtleW5hbWVzXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20valF1ZXJ5LnVpLmtleUNvZGUvXG5cbiggZnVuY3Rpb24oIGZhY3RvcnkgKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKCBbIFwianF1ZXJ5XCIsIFwiLi92ZXJzaW9uXCIgXSwgZmFjdG9yeSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeSggalF1ZXJ5ICk7XG5cdH1cbn0gKSggZnVuY3Rpb24oICQgKSB7XG5cInVzZSBzdHJpY3RcIjtcblxucmV0dXJuICQudWkua2V5Q29kZSA9IHtcblx0QkFDS1NQQUNFOiA4LFxuXHRDT01NQTogMTg4LFxuXHRERUxFVEU6IDQ2LFxuXHRET1dOOiA0MCxcblx0RU5EOiAzNSxcblx0RU5URVI6IDEzLFxuXHRFU0NBUEU6IDI3LFxuXHRIT01FOiAzNixcblx0TEVGVDogMzcsXG5cdFBBR0VfRE9XTjogMzQsXG5cdFBBR0VfVVA6IDMzLFxuXHRQRVJJT0Q6IDE5MCxcblx0UklHSFQ6IDM5LFxuXHRTUEFDRTogMzIsXG5cdFRBQjogOSxcblx0VVA6IDM4XG59O1xuXG59ICk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFVBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/jquery-ui/ui/keycode.js\n')},"../node_modules/jquery-ui/ui/safe-active-element.js":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {\n\t"use strict";\n\n\tif ( true ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "../node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "../node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n} )( function( $ ) {\n"use strict";\n\nreturn $.ui.safeActiveElement = function( document ) {\n\tvar activeElement;\n\n\t// Support: IE 9 only\n\t// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>\n\ttry {\n\t\tactiveElement = document.activeElement;\n\t} catch ( error ) {\n\t\tactiveElement = document.body;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE may return null instead of an element\n\t// Interestingly, this only seems to occur when NOT in an iframe\n\tif ( !activeElement ) {\n\t\tactiveElement = document.body;\n\t}\n\n\t// Support: IE 11 only\n\t// IE11 returns a seemingly empty object in some cases when accessing\n\t// document.activeElement from an <iframe>\n\tif ( !activeElement.nodeName ) {\n\t\tactiveElement = document.body;\n\t}\n\n\treturn activeElement;\n};\n\n} );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS9zYWZlLWFjdGl2ZS1lbGVtZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvc2FmZS1hY3RpdmUtZWxlbWVudC5qcz8wYTI2Il0sInNvdXJjZXNDb250ZW50IjpbIiggZnVuY3Rpb24oIGZhY3RvcnkgKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKCBbIFwianF1ZXJ5XCIsIFwiLi92ZXJzaW9uXCIgXSwgZmFjdG9yeSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeSggalF1ZXJ5ICk7XG5cdH1cbn0gKSggZnVuY3Rpb24oICQgKSB7XG5cInVzZSBzdHJpY3RcIjtcblxucmV0dXJuICQudWkuc2FmZUFjdGl2ZUVsZW1lbnQgPSBmdW5jdGlvbiggZG9jdW1lbnQgKSB7XG5cdHZhciBhY3RpdmVFbGVtZW50O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHQvLyBJRTkgdGhyb3dzIGFuIFwiVW5zcGVjaWZpZWQgZXJyb3JcIiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBmcm9tIGFuIDxpZnJhbWU+XG5cdHRyeSB7XG5cdFx0YWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnJvciApIHtcblx0XHRhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIG1heSByZXR1cm4gbnVsbCBpbnN0ZWFkIG9mIGFuIGVsZW1lbnRcblx0Ly8gSW50ZXJlc3RpbmdseSwgdGhpcyBvbmx5IHNlZW1zIHRvIG9jY3VyIHdoZW4gTk9UIGluIGFuIGlmcmFtZVxuXHRpZiAoICFhY3RpdmVFbGVtZW50ICkge1xuXHRcdGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5ib2R5O1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHQvLyBJRTExIHJldHVybnMgYSBzZWVtaW5nbHkgZW1wdHkgb2JqZWN0IGluIHNvbWUgY2FzZXMgd2hlbiBhY2Nlc3Npbmdcblx0Ly8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBmcm9tIGFuIDxpZnJhbWU+XG5cdGlmICggIWFjdGl2ZUVsZW1lbnQubm9kZU5hbWUgKSB7XG5cdFx0YWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmJvZHk7XG5cdH1cblxuXHRyZXR1cm4gYWN0aXZlRWxlbWVudDtcbn07XG5cbn0gKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxVQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/jquery-ui/ui/safe-active-element.js\n')},"../node_modules/jquery-ui/ui/unique-id.js":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery UI Unique ID 1.13.2\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n */\n\n//>>label: uniqueId\n//>>group: Core\n//>>description: Functions to generate and remove uniqueId\'s\n//>>docs: http://api.jqueryui.com/uniqueId/\n\n( function( factory ) {\n\t"use strict";\n\n\tif ( true ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "../node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "../node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n} )( function( $ ) {\n"use strict";\n\nreturn $.fn.extend( {\n\tuniqueId: ( function() {\n\t\tvar uuid = 0;\n\n\t\treturn function() {\n\t\t\treturn this.each( function() {\n\t\t\t\tif ( !this.id ) {\n\t\t\t\t\tthis.id = "ui-id-" + ( ++uuid );\n\t\t\t\t}\n\t\t\t} );\n\t\t};\n\t} )(),\n\n\tremoveUniqueId: function() {\n\t\treturn this.each( function() {\n\t\t\tif ( /^ui-id-\\d+$/.test( this.id ) ) {\n\t\t\t\t$( this ).removeAttr( "id" );\n\t\t\t}\n\t\t} );\n\t}\n} );\n\n} );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS91bmlxdWUtaWQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS91bmlxdWUtaWQuanM/ZDgxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBVSSBVbmlxdWUgSUQgMS4xMy4yXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IHVuaXF1ZUlkXG4vLz4+Z3JvdXA6IENvcmVcbi8vPj5kZXNjcmlwdGlvbjogRnVuY3Rpb25zIHRvIGdlbmVyYXRlIGFuZCByZW1vdmUgdW5pcXVlSWQnc1xuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3VuaXF1ZUlkL1xuXG4oIGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZSggWyBcImpxdWVyeVwiLCBcIi4vdmVyc2lvblwiIF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3RvcnkoIGpRdWVyeSApO1xuXHR9XG59ICkoIGZ1bmN0aW9uKCAkICkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnJldHVybiAkLmZuLmV4dGVuZCgge1xuXHR1bmlxdWVJZDogKCBmdW5jdGlvbigpIHtcblx0XHR2YXIgdXVpZCA9IDA7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5pZCApIHtcblx0XHRcdFx0XHR0aGlzLmlkID0gXCJ1aS1pZC1cIiArICggKyt1dWlkICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9O1xuXHR9ICkoKSxcblxuXHRyZW1vdmVVbmlxdWVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIC9edWktaWQtXFxkKyQvLnRlc3QoIHRoaXMuaWQgKSApIHtcblx0XHRcdFx0JCggdGhpcyApLnJlbW92ZUF0dHIoIFwiaWRcIiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG59ICk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFVBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/jquery-ui/ui/unique-id.js\n')},"../node_modules/jquery-ui/ui/version.js":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {\n\t"use strict";\n\n\tif ( true ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "../node_modules/jquery/dist/jquery.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n} )( function( $ ) {\n"use strict";\n\n$.ui = $.ui || {};\n\nreturn $.ui.version = "1.13.2";\n\n} );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS92ZXJzaW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvdmVyc2lvbi5qcz8zMjQzIl0sInNvdXJjZXNDb250ZW50IjpbIiggZnVuY3Rpb24oIGZhY3RvcnkgKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKCBbIFwianF1ZXJ5XCIgXSwgZmFjdG9yeSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeSggalF1ZXJ5ICk7XG5cdH1cbn0gKSggZnVuY3Rpb24oICQgKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuJC51aSA9ICQudWkgfHwge307XG5cbnJldHVybiAkLnVpLnZlcnNpb24gPSBcIjEuMTMuMlwiO1xuXG59ICk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsVUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/jquery-ui/ui/version.js\n')},"../node_modules/jquery-ui/ui/widget.js":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery UI Widget 1.13.2\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n */\n\n//>>label: Widget\n//>>group: Core\n//>>description: Provides a factory for creating stateful widgets with a common API.\n//>>docs: http://api.jqueryui.com/jQuery.widget/\n//>>demos: http://jqueryui.com/widget/\n\n( function( factory ) {\n\t"use strict";\n\n\tif ( true ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "../node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "../node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n} )( function( $ ) {\n"use strict";\n\nvar widgetUuid = 0;\nvar widgetHasOwnProperty = Array.prototype.hasOwnProperty;\nvar widgetSlice = Array.prototype.slice;\n\n$.cleanData = ( function( orig ) {\n\treturn function( elems ) {\n\t\tvar events, elem, i;\n\t\tfor ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {\n\n\t\t\t// Only trigger remove when necessary to save time\n\t\t\tevents = $._data( elem, "events" );\n\t\t\tif ( events && events.remove ) {\n\t\t\t\t$( elem ).triggerHandler( "remove" );\n\t\t\t}\n\t\t}\n\t\torig( elems );\n\t};\n} )( $.cleanData );\n\n$.widget = function( name, base, prototype ) {\n\tvar existingConstructor, constructor, basePrototype;\n\n\t// ProxiedPrototype allows the provided prototype to remain unmodified\n\t// so that it can be used as a mixin for multiple widgets (#8876)\n\tvar proxiedPrototype = {};\n\n\tvar namespace = name.split( "." )[ 0 ];\n\tname = name.split( "." )[ 1 ];\n\tvar fullName = namespace + "-" + name;\n\n\tif ( !prototype ) {\n\t\tprototype = base;\n\t\tbase = $.Widget;\n\t}\n\n\tif ( Array.isArray( prototype ) ) {\n\t\tprototype = $.extend.apply( null, [ {} ].concat( prototype ) );\n\t}\n\n\t// Create selector for plugin\n\t$.expr.pseudos[ fullName.toLowerCase() ] = function( elem ) {\n\t\treturn !!$.data( elem, fullName );\n\t};\n\n\t$[ namespace ] = $[ namespace ] || {};\n\texistingConstructor = $[ namespace ][ name ];\n\tconstructor = $[ namespace ][ name ] = function( options, element ) {\n\n\t\t// Allow instantiation without "new" keyword\n\t\tif ( !this || !this._createWidget ) {\n\t\t\treturn new constructor( options, element );\n\t\t}\n\n\t\t// Allow instantiation without initializing for simple inheritance\n\t\t// must use "new" keyword (the code above always passes args)\n\t\tif ( arguments.length ) {\n\t\t\tthis._createWidget( options, element );\n\t\t}\n\t};\n\n\t// Extend with the existing constructor to carry over any static properties\n\t$.extend( constructor, existingConstructor, {\n\t\tversion: prototype.version,\n\n\t\t// Copy the object used to create the prototype in case we need to\n\t\t// redefine the widget later\n\t\t_proto: $.extend( {}, prototype ),\n\n\t\t// Track widgets that inherit from this widget in case this widget is\n\t\t// redefined after a widget inherits from it\n\t\t_childConstructors: []\n\t} );\n\n\tbasePrototype = new base();\n\n\t// We need to make the options hash a property directly on the new instance\n\t// otherwise we\'ll modify the options hash on the prototype that we\'re\n\t// inheriting from\n\tbasePrototype.options = $.widget.extend( {}, basePrototype.options );\n\t$.each( prototype, function( prop, value ) {\n\t\tif ( typeof value !== "function" ) {\n\t\t\tproxiedPrototype[ prop ] = value;\n\t\t\treturn;\n\t\t}\n\t\tproxiedPrototype[ prop ] = ( function() {\n\t\t\tfunction _super() {\n\t\t\t\treturn base.prototype[ prop ].apply( this, arguments );\n\t\t\t}\n\n\t\t\tfunction _superApply( args ) {\n\t\t\t\treturn base.prototype[ prop ].apply( this, args );\n\t\t\t}\n\n\t\t\treturn function() {\n\t\t\t\tvar __super = this._super;\n\t\t\t\tvar __superApply = this._superApply;\n\t\t\t\tvar returnValue;\n\n\t\t\t\tthis._super = _super;\n\t\t\t\tthis._superApply = _superApply;\n\n\t\t\t\treturnValue = value.apply( this, arguments );\n\n\t\t\t\tthis._super = __super;\n\t\t\t\tthis._superApply = __superApply;\n\n\t\t\t\treturn returnValue;\n\t\t\t};\n\t\t} )();\n\t} );\n\tconstructor.prototype = $.widget.extend( basePrototype, {\n\n\t\t// TODO: remove support for widgetEventPrefix\n\t\t// always use the name + a colon as the prefix, e.g., draggable:start\n\t\t// don\'t prefix for widgets that aren\'t DOM-based\n\t\twidgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name\n\t}, proxiedPrototype, {\n\t\tconstructor: constructor,\n\t\tnamespace: namespace,\n\t\twidgetName: name,\n\t\twidgetFullName: fullName\n\t} );\n\n\t// If this widget is being redefined then we need to find all widgets that\n\t// are inheriting from it and redefine all of them so that they inherit from\n\t// the new version of this widget. We\'re essentially trying to replace one\n\t// level in the prototype chain.\n\tif ( existingConstructor ) {\n\t\t$.each( existingConstructor._childConstructors, function( i, child ) {\n\t\t\tvar childPrototype = child.prototype;\n\n\t\t\t// Redefine the child widget using the same prototype that was\n\t\t\t// originally used, but inherit from the new version of the base\n\t\t\t$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,\n\t\t\t\tchild._proto );\n\t\t} );\n\n\t\t// Remove the list of existing child constructors from the old constructor\n\t\t// so the old child constructors can be garbage collected\n\t\tdelete existingConstructor._childConstructors;\n\t} else {\n\t\tbase._childConstructors.push( constructor );\n\t}\n\n\t$.widget.bridge( name, constructor );\n\n\treturn constructor;\n};\n\n$.widget.extend = function( target ) {\n\tvar input = widgetSlice.call( arguments, 1 );\n\tvar inputIndex = 0;\n\tvar inputLength = input.length;\n\tvar key;\n\tvar value;\n\n\tfor ( ; inputIndex < inputLength; inputIndex++ ) {\n\t\tfor ( key in input[ inputIndex ] ) {\n\t\t\tvalue = input[ inputIndex ][ key ];\n\t\t\tif ( widgetHasOwnProperty.call( input[ inputIndex ], key ) && value !== undefined ) {\n\n\t\t\t\t// Clone objects\n\t\t\t\tif ( $.isPlainObject( value ) ) {\n\t\t\t\t\ttarget[ key ] = $.isPlainObject( target[ key ] ) ?\n\t\t\t\t\t\t$.widget.extend( {}, target[ key ], value ) :\n\n\t\t\t\t\t\t// Don\'t extend strings, arrays, etc. with objects\n\t\t\t\t\t\t$.widget.extend( {}, value );\n\n\t\t\t\t// Copy everything else by reference\n\t\t\t\t} else {\n\t\t\t\t\ttarget[ key ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n};\n\n$.widget.bridge = function( name, object ) {\n\tvar fullName = object.prototype.widgetFullName || name;\n\t$.fn[ name ] = function( options ) {\n\t\tvar isMethodCall = typeof options === "string";\n\t\tvar args = widgetSlice.call( arguments, 1 );\n\t\tvar returnValue = this;\n\n\t\tif ( isMethodCall ) {\n\n\t\t\t// If this is an empty collection, we need to have the instance method\n\t\t\t// return undefined instead of the jQuery instance\n\t\t\tif ( !this.length && options === "instance" ) {\n\t\t\t\treturnValue = undefined;\n\t\t\t} else {\n\t\t\t\tthis.each( function() {\n\t\t\t\t\tvar methodValue;\n\t\t\t\t\tvar instance = $.data( this, fullName );\n\n\t\t\t\t\tif ( options === "instance" ) {\n\t\t\t\t\t\treturnValue = instance;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !instance ) {\n\t\t\t\t\t\treturn $.error( "cannot call methods on " + name +\n\t\t\t\t\t\t\t" prior to initialization; " +\n\t\t\t\t\t\t\t"attempted to call method \'" + options + "\'" );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( typeof instance[ options ] !== "function" ||\n\t\t\t\t\t\toptions.charAt( 0 ) === "_" ) {\n\t\t\t\t\t\treturn $.error( "no such method \'" + options + "\' for " + name +\n\t\t\t\t\t\t\t" widget instance" );\n\t\t\t\t\t}\n\n\t\t\t\t\tmethodValue = instance[ options ].apply( instance, args );\n\n\t\t\t\t\tif ( methodValue !== instance && methodValue !== undefined ) {\n\t\t\t\t\t\treturnValue = methodValue && methodValue.jquery ?\n\t\t\t\t\t\t\treturnValue.pushStack( methodValue.get() ) :\n\t\t\t\t\t\t\tmethodValue;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t} else {\n\n\t\t\t// Allow multiple hashes to be passed on init\n\t\t\tif ( args.length ) {\n\t\t\t\toptions = $.widget.extend.apply( null, [ options ].concat( args ) );\n\t\t\t}\n\n\t\t\tthis.each( function() {\n\t\t\t\tvar instance = $.data( this, fullName );\n\t\t\t\tif ( instance ) {\n\t\t\t\t\tinstance.option( options || {} );\n\t\t\t\t\tif ( instance._init ) {\n\t\t\t\t\t\tinstance._init();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$.data( this, fullName, new object( options, this ) );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\treturn returnValue;\n\t};\n};\n\n$.Widget = function( /* options, element */ ) {};\n$.Widget._childConstructors = [];\n\n$.Widget.prototype = {\n\twidgetName: "widget",\n\twidgetEventPrefix: "",\n\tdefaultElement: "<div>",\n\n\toptions: {\n\t\tclasses: {},\n\t\tdisabled: false,\n\n\t\t// Callbacks\n\t\tcreate: null\n\t},\n\n\t_createWidget: function( options, element ) {\n\t\telement = $( element || this.defaultElement || this )[ 0 ];\n\t\tthis.element = $( element );\n\t\tthis.uuid = widgetUuid++;\n\t\tthis.eventNamespace = "." + this.widgetName + this.uuid;\n\n\t\tthis.bindings = $();\n\t\tthis.hoverable = $();\n\t\tthis.focusable = $();\n\t\tthis.classesElementLookup = {};\n\n\t\tif ( element !== this ) {\n\t\t\t$.data( element, this.widgetFullName, this );\n\t\t\tthis._on( true, this.element, {\n\t\t\t\tremove: function( event ) {\n\t\t\t\t\tif ( event.target === element ) {\n\t\t\t\t\t\tthis.destroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t\tthis.document = $( element.style ?\n\n\t\t\t\t// Element within the document\n\t\t\t\telement.ownerDocument :\n\n\t\t\t\t// Element is window or document\n\t\t\t\telement.document || element );\n\t\t\tthis.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );\n\t\t}\n\n\t\tthis.options = $.widget.extend( {},\n\t\t\tthis.options,\n\t\t\tthis._getCreateOptions(),\n\t\t\toptions );\n\n\t\tthis._create();\n\n\t\tif ( this.options.disabled ) {\n\t\t\tthis._setOptionDisabled( this.options.disabled );\n\t\t}\n\n\t\tthis._trigger( "create", null, this._getCreateEventData() );\n\t\tthis._init();\n\t},\n\n\t_getCreateOptions: function() {\n\t\treturn {};\n\t},\n\n\t_getCreateEventData: $.noop,\n\n\t_create: $.noop,\n\n\t_init: $.noop,\n\n\tdestroy: function() {\n\t\tvar that = this;\n\n\t\tthis._destroy();\n\t\t$.each( this.classesElementLookup, function( key, value ) {\n\t\t\tthat._removeClass( value, key );\n\t\t} );\n\n\t\t// We can probably remove the unbind calls in 2.0\n\t\t// all event bindings should go through this._on()\n\t\tthis.element\n\t\t\t.off( this.eventNamespace )\n\t\t\t.removeData( this.widgetFullName );\n\t\tthis.widget()\n\t\t\t.off( this.eventNamespace )\n\t\t\t.removeAttr( "aria-disabled" );\n\n\t\t// Clean up events and states\n\t\tthis.bindings.off( this.eventNamespace );\n\t},\n\n\t_destroy: $.noop,\n\n\twidget: function() {\n\t\treturn this.element;\n\t},\n\n\toption: function( key, value ) {\n\t\tvar options = key;\n\t\tvar parts;\n\t\tvar curOption;\n\t\tvar i;\n\n\t\tif ( arguments.length === 0 ) {\n\n\t\t\t// Don\'t return a reference to the internal hash\n\t\t\treturn $.widget.extend( {}, this.options );\n\t\t}\n\n\t\tif ( typeof key === "string" ) {\n\n\t\t\t// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }\n\t\t\toptions = {};\n\t\t\tparts = key.split( "." );\n\t\t\tkey = parts.shift();\n\t\t\tif ( parts.length ) {\n\t\t\t\tcurOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );\n\t\t\t\tfor ( i = 0; i < parts.length - 1; i++ ) {\n\t\t\t\t\tcurOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\n\t\t\t\t\tcurOption = curOption[ parts[ i ] ];\n\t\t\t\t}\n\t\t\t\tkey = parts.pop();\n\t\t\t\tif ( arguments.length === 1 ) {\n\t\t\t\t\treturn curOption[ key ] === undefined ? null : curOption[ key ];\n\t\t\t\t}\n\t\t\t\tcurOption[ key ] = value;\n\t\t\t} else {\n\t\t\t\tif ( arguments.length === 1 ) {\n\t\t\t\t\treturn this.options[ key ] === undefined ? null : this.options[ key ];\n\t\t\t\t}\n\t\t\t\toptions[ key ] = value;\n\t\t\t}\n\t\t}\n\n\t\tthis._setOptions( options );\n\n\t\treturn this;\n\t},\n\n\t_setOptions: function( options ) {\n\t\tvar key;\n\n\t\tfor ( key in options ) {\n\t\t\tthis._setOption( key, options[ key ] );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tif ( key === "classes" ) {\n\t\t\tthis._setOptionClasses( value );\n\t\t}\n\n\t\tthis.options[ key ] = value;\n\n\t\tif ( key === "disabled" ) {\n\t\t\tthis._setOptionDisabled( value );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_setOptionClasses: function( value ) {\n\t\tvar classKey, elements, currentElements;\n\n\t\tfor ( classKey in value ) {\n\t\t\tcurrentElements = this.classesElementLookup[ classKey ];\n\t\t\tif ( value[ classKey ] === this.options.classes[ classKey ] ||\n\t\t\t\t\t!currentElements ||\n\t\t\t\t\t!currentElements.length ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// We are doing this to create a new jQuery object because the _removeClass() call\n\t\t\t// on the next line is going to destroy the reference to the current elements being\n\t\t\t// tracked. We need to save a copy of this collection so that we can add the new classes\n\t\t\t// below.\n\t\t\telements = $( currentElements.get() );\n\t\t\tthis._removeClass( currentElements, classKey );\n\n\t\t\t// We don\'t use _addClass() here, because that uses this.options.classes\n\t\t\t// for generating the string of classes. We want to use the value passed in from\n\t\t\t// _setOption(), this is the new value of the classes option which was passed to\n\t\t\t// _setOption(). We pass this value directly to _classes().\n\t\t\telements.addClass( this._classes( {\n\t\t\t\telement: elements,\n\t\t\t\tkeys: classKey,\n\t\t\t\tclasses: value,\n\t\t\t\tadd: true\n\t\t\t} ) );\n\t\t}\n\t},\n\n\t_setOptionDisabled: function( value ) {\n\t\tthis._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );\n\n\t\t// If the widget is becoming disabled, then nothing is interactive\n\t\tif ( value ) {\n\t\t\tthis._removeClass( this.hoverable, null, "ui-state-hover" );\n\t\t\tthis._removeClass( this.focusable, null, "ui-state-focus" );\n\t\t}\n\t},\n\n\tenable: function() {\n\t\treturn this._setOptions( { disabled: false } );\n\t},\n\n\tdisable: function() {\n\t\treturn this._setOptions( { disabled: true } );\n\t},\n\n\t_classes: function( options ) {\n\t\tvar full = [];\n\t\tvar that = this;\n\n\t\toptions = $.extend( {\n\t\t\telement: this.element,\n\t\t\tclasses: this.options.classes || {}\n\t\t}, options );\n\n\t\tfunction bindRemoveEvent() {\n\t\t\tvar nodesToBind = [];\n\n\t\t\toptions.element.each( function( _, element ) {\n\t\t\t\tvar isTracked = $.map( that.classesElementLookup, function( elements ) {\n\t\t\t\t\treturn elements;\n\t\t\t\t} )\n\t\t\t\t\t.some( function( elements ) {\n\t\t\t\t\t\treturn elements.is( element );\n\t\t\t\t\t} );\n\n\t\t\t\tif ( !isTracked ) {\n\t\t\t\t\tnodesToBind.push( element );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tthat._on( $( nodesToBind ), {\n\t\t\t\tremove: "_untrackClassesElement"\n\t\t\t} );\n\t\t}\n\n\t\tfunction processClassString( classes, checkOption ) {\n\t\t\tvar current, i;\n\t\t\tfor ( i = 0; i < classes.length; i++ ) {\n\t\t\t\tcurrent = that.classesElementLookup[ classes[ i ] ] || $();\n\t\t\t\tif ( options.add ) {\n\t\t\t\t\tbindRemoveEvent();\n\t\t\t\t\tcurrent = $( $.uniqueSort( current.get().concat( options.element.get() ) ) );\n\t\t\t\t} else {\n\t\t\t\t\tcurrent = $( current.not( options.element ).get() );\n\t\t\t\t}\n\t\t\t\tthat.classesElementLookup[ classes[ i ] ] = current;\n\t\t\t\tfull.push( classes[ i ] );\n\t\t\t\tif ( checkOption && options.classes[ classes[ i ] ] ) {\n\t\t\t\t\tfull.push( options.classes[ classes[ i ] ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( options.keys ) {\n\t\t\tprocessClassString( options.keys.match( /\\S+/g ) || [], true );\n\t\t}\n\t\tif ( options.extra ) {\n\t\t\tprocessClassString( options.extra.match( /\\S+/g ) || [] );\n\t\t}\n\n\t\treturn full.join( " " );\n\t},\n\n\t_untrackClassesElement: function( event ) {\n\t\tvar that = this;\n\t\t$.each( that.classesElementLookup, function( key, value ) {\n\t\t\tif ( $.inArray( event.target, value ) !== -1 ) {\n\t\t\t\tthat.classesElementLookup[ key ] = $( value.not( event.target ).get() );\n\t\t\t}\n\t\t} );\n\n\t\tthis._off( $( event.target ) );\n\t},\n\n\t_removeClass: function( element, keys, extra ) {\n\t\treturn this._toggleClass( element, keys, extra, false );\n\t},\n\n\t_addClass: function( element, keys, extra ) {\n\t\treturn this._toggleClass( element, keys, extra, true );\n\t},\n\n\t_toggleClass: function( element, keys, extra, add ) {\n\t\tadd = ( typeof add === "boolean" ) ? add : extra;\n\t\tvar shift = ( typeof element === "string" || element === null ),\n\t\t\toptions = {\n\t\t\t\textra: shift ? keys : extra,\n\t\t\t\tkeys: shift ? element : keys,\n\t\t\t\telement: shift ? this.element : element,\n\t\t\t\tadd: add\n\t\t\t};\n\t\toptions.element.toggleClass( this._classes( options ), add );\n\t\treturn this;\n\t},\n\n\t_on: function( suppressDisabledCheck, element, handlers ) {\n\t\tvar delegateElement;\n\t\tvar instance = this;\n\n\t\t// No suppressDisabledCheck flag, shuffle arguments\n\t\tif ( typeof suppressDisabledCheck !== "boolean" ) {\n\t\t\thandlers = element;\n\t\t\telement = suppressDisabledCheck;\n\t\t\tsuppressDisabledCheck = false;\n\t\t}\n\n\t\t// No element argument, shuffle and use this.element\n\t\tif ( !handlers ) {\n\t\t\thandlers = element;\n\t\t\telement = this.element;\n\t\t\tdelegateElement = this.widget();\n\t\t} else {\n\t\t\telement = delegateElement = $( element );\n\t\t\tthis.bindings = this.bindings.add( element );\n\t\t}\n\n\t\t$.each( handlers, function( event, handler ) {\n\t\t\tfunction handlerProxy() {\n\n\t\t\t\t// Allow widgets to customize the disabled handling\n\t\t\t\t// - disabled as an array instead of boolean\n\t\t\t\t// - disabled class as method for disabling individual parts\n\t\t\t\tif ( !suppressDisabledCheck &&\n\t\t\t\t\t\t( instance.options.disabled === true ||\n\t\t\t\t\t\t$( this ).hasClass( "ui-state-disabled" ) ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn ( typeof handler === "string" ? instance[ handler ] : handler )\n\t\t\t\t\t.apply( instance, arguments );\n\t\t\t}\n\n\t\t\t// Copy the guid so direct unbinding works\n\t\t\tif ( typeof handler !== "string" ) {\n\t\t\t\thandlerProxy.guid = handler.guid =\n\t\t\t\t\thandler.guid || handlerProxy.guid || $.guid++;\n\t\t\t}\n\n\t\t\tvar match = event.match( /^([\\w:-]*)\\s*(.*)$/ );\n\t\t\tvar eventName = match[ 1 ] + instance.eventNamespace;\n\t\t\tvar selector = match[ 2 ];\n\n\t\t\tif ( selector ) {\n\t\t\t\tdelegateElement.on( eventName, selector, handlerProxy );\n\t\t\t} else {\n\t\t\t\telement.on( eventName, handlerProxy );\n\t\t\t}\n\t\t} );\n\t},\n\n\t_off: function( element, eventName ) {\n\t\teventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +\n\t\t\tthis.eventNamespace;\n\t\telement.off( eventName );\n\n\t\t// Clear the stack to avoid memory leaks (#10056)\n\t\tthis.bindings = $( this.bindings.not( element ).get() );\n\t\tthis.focusable = $( this.focusable.not( element ).get() );\n\t\tthis.hoverable = $( this.hoverable.not( element ).get() );\n\t},\n\n\t_delay: function( handler, delay ) {\n\t\tfunction handlerProxy() {\n\t\t\treturn ( typeof handler === "string" ? instance[ handler ] : handler )\n\t\t\t\t.apply( instance, arguments );\n\t\t}\n\t\tvar instance = this;\n\t\treturn setTimeout( handlerProxy, delay || 0 );\n\t},\n\n\t_hoverable: function( element ) {\n\t\tthis.hoverable = this.hoverable.add( element );\n\t\tthis._on( element, {\n\t\t\tmouseenter: function( event ) {\n\t\t\t\tthis._addClass( $( event.currentTarget ), null, "ui-state-hover" );\n\t\t\t},\n\t\t\tmouseleave: function( event ) {\n\t\t\t\tthis._removeClass( $( event.currentTarget ), null, "ui-state-hover" );\n\t\t\t}\n\t\t} );\n\t},\n\n\t_focusable: function( element ) {\n\t\tthis.focusable = this.focusable.add( element );\n\t\tthis._on( element, {\n\t\t\tfocusin: function( event ) {\n\t\t\t\tthis._addClass( $( event.currentTarget ), null, "ui-state-focus" );\n\t\t\t},\n\t\t\tfocusout: function( event ) {\n\t\t\t\tthis._removeClass( $( event.currentTarget ), null, "ui-state-focus" );\n\t\t\t}\n\t\t} );\n\t},\n\n\t_trigger: function( type, event, data ) {\n\t\tvar prop, orig;\n\t\tvar callback = this.options[ type ];\n\n\t\tdata = data || {};\n\t\tevent = $.Event( event );\n\t\tevent.type = ( type === this.widgetEventPrefix ?\n\t\t\ttype :\n\t\t\tthis.widgetEventPrefix + type ).toLowerCase();\n\n\t\t// The original event may come from any element\n\t\t// so we need to reset the target on the new event\n\t\tevent.target = this.element[ 0 ];\n\n\t\t// Copy original event properties over to the new event\n\t\torig = event.originalEvent;\n\t\tif ( orig ) {\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tif ( !( prop in event ) ) {\n\t\t\t\t\tevent[ prop ] = orig[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.element.trigger( event, data );\n\t\treturn !( typeof callback === "function" &&\n\t\t\tcallback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||\n\t\t\tevent.isDefaultPrevented() );\n\t}\n};\n\n$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {\n\t$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {\n\t\tif ( typeof options === "string" ) {\n\t\t\toptions = { effect: options };\n\t\t}\n\n\t\tvar hasOptions;\n\t\tvar effectName = !options ?\n\t\t\tmethod :\n\t\t\toptions === true || typeof options === "number" ?\n\t\t\t\tdefaultEffect :\n\t\t\t\toptions.effect || defaultEffect;\n\n\t\toptions = options || {};\n\t\tif ( typeof options === "number" ) {\n\t\t\toptions = { duration: options };\n\t\t} else if ( options === true ) {\n\t\t\toptions = {};\n\t\t}\n\n\t\thasOptions = !$.isEmptyObject( options );\n\t\toptions.complete = callback;\n\n\t\tif ( options.delay ) {\n\t\t\telement.delay( options.delay );\n\t\t}\n\n\t\tif ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {\n\t\t\telement[ method ]( options );\n\t\t} else if ( effectName !== method && element[ effectName ] ) {\n\t\t\telement[ effectName ]( options.duration, options.easing, callback );\n\t\t} else {\n\t\t\telement.queue( function( next ) {\n\t\t\t\t$( this )[ method ]();\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback.call( element[ 0 ] );\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t} );\n\t\t}\n\t};\n} );\n\nreturn $.widget;\n\n} );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS93aWRnZXQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS93aWRnZXQuanM/MGMwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBVSSBXaWRnZXQgMS4xMy4yXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IFdpZGdldFxuLy8+Pmdyb3VwOiBDb3JlXG4vLz4+ZGVzY3JpcHRpb246IFByb3ZpZGVzIGEgZmFjdG9yeSBmb3IgY3JlYXRpbmcgc3RhdGVmdWwgd2lkZ2V0cyB3aXRoIGEgY29tbW9uIEFQSS5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9qUXVlcnkud2lkZ2V0L1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL3dpZGdldC9cblxuKCBmdW5jdGlvbiggZmFjdG9yeSApIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoIFsgXCJqcXVlcnlcIiwgXCIuL3ZlcnNpb25cIiBdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufSApKCBmdW5jdGlvbiggJCApIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgd2lkZ2V0VXVpZCA9IDA7XG52YXIgd2lkZ2V0SGFzT3duUHJvcGVydHkgPSBBcnJheS5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgd2lkZ2V0U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiQuY2xlYW5EYXRhID0gKCBmdW5jdGlvbiggb3JpZyApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZXZlbnRzLCBlbGVtLCBpO1xuXHRcdGZvciAoIGkgPSAwOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXG5cdFx0XHQvLyBPbmx5IHRyaWdnZXIgcmVtb3ZlIHdoZW4gbmVjZXNzYXJ5IHRvIHNhdmUgdGltZVxuXHRcdFx0ZXZlbnRzID0gJC5fZGF0YSggZWxlbSwgXCJldmVudHNcIiApO1xuXHRcdFx0aWYgKCBldmVudHMgJiYgZXZlbnRzLnJlbW92ZSApIHtcblx0XHRcdFx0JCggZWxlbSApLnRyaWdnZXJIYW5kbGVyKCBcInJlbW92ZVwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdG9yaWcoIGVsZW1zICk7XG5cdH07XG59ICkoICQuY2xlYW5EYXRhICk7XG5cbiQud2lkZ2V0ID0gZnVuY3Rpb24oIG5hbWUsIGJhc2UsIHByb3RvdHlwZSApIHtcblx0dmFyIGV4aXN0aW5nQ29uc3RydWN0b3IsIGNvbnN0cnVjdG9yLCBiYXNlUHJvdG90eXBlO1xuXG5cdC8vIFByb3hpZWRQcm90b3R5cGUgYWxsb3dzIHRoZSBwcm92aWRlZCBwcm90b3R5cGUgdG8gcmVtYWluIHVubW9kaWZpZWRcblx0Ly8gc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBhcyBhIG1peGluIGZvciBtdWx0aXBsZSB3aWRnZXRzICgjODg3Nilcblx0dmFyIHByb3hpZWRQcm90b3R5cGUgPSB7fTtcblxuXHR2YXIgbmFtZXNwYWNlID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMCBdO1xuXHRuYW1lID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMSBdO1xuXHR2YXIgZnVsbE5hbWUgPSBuYW1lc3BhY2UgKyBcIi1cIiArIG5hbWU7XG5cblx0aWYgKCAhcHJvdG90eXBlICkge1xuXHRcdHByb3RvdHlwZSA9IGJhc2U7XG5cdFx0YmFzZSA9ICQuV2lkZ2V0O1xuXHR9XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBwcm90b3R5cGUgKSApIHtcblx0XHRwcm90b3R5cGUgPSAkLmV4dGVuZC5hcHBseSggbnVsbCwgWyB7fSBdLmNvbmNhdCggcHJvdG90eXBlICkgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBzZWxlY3RvciBmb3IgcGx1Z2luXG5cdCQuZXhwci5wc2V1ZG9zWyBmdWxsTmFtZS50b0xvd2VyQ2FzZSgpIF0gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIGZ1bGxOYW1lICk7XG5cdH07XG5cblx0JFsgbmFtZXNwYWNlIF0gPSAkWyBuYW1lc3BhY2UgXSB8fCB7fTtcblx0ZXhpc3RpbmdDb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF07XG5cdGNvbnN0cnVjdG9yID0gJFsgbmFtZXNwYWNlIF1bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zLCBlbGVtZW50ICkge1xuXG5cdFx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IFwibmV3XCIga2V5d29yZFxuXHRcdGlmICggIXRoaXMgfHwgIXRoaXMuX2NyZWF0ZVdpZGdldCApIHtcblx0XHRcdHJldHVybiBuZXcgY29uc3RydWN0b3IoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgaW5pdGlhbGl6aW5nIGZvciBzaW1wbGUgaW5oZXJpdGFuY2Vcblx0XHQvLyBtdXN0IHVzZSBcIm5ld1wiIGtleXdvcmQgKHRoZSBjb2RlIGFib3ZlIGFsd2F5cyBwYXNzZXMgYXJncylcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLl9jcmVhdGVXaWRnZXQoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gRXh0ZW5kIHdpdGggdGhlIGV4aXN0aW5nIGNvbnN0cnVjdG9yIHRvIGNhcnJ5IG92ZXIgYW55IHN0YXRpYyBwcm9wZXJ0aWVzXG5cdCQuZXh0ZW5kKCBjb25zdHJ1Y3RvciwgZXhpc3RpbmdDb25zdHJ1Y3Rvciwge1xuXHRcdHZlcnNpb246IHByb3RvdHlwZS52ZXJzaW9uLFxuXG5cdFx0Ly8gQ29weSB0aGUgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoZSBwcm90b3R5cGUgaW4gY2FzZSB3ZSBuZWVkIHRvXG5cdFx0Ly8gcmVkZWZpbmUgdGhlIHdpZGdldCBsYXRlclxuXHRcdF9wcm90bzogJC5leHRlbmQoIHt9LCBwcm90b3R5cGUgKSxcblxuXHRcdC8vIFRyYWNrIHdpZGdldHMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyB3aWRnZXQgaW4gY2FzZSB0aGlzIHdpZGdldCBpc1xuXHRcdC8vIHJlZGVmaW5lZCBhZnRlciBhIHdpZGdldCBpbmhlcml0cyBmcm9tIGl0XG5cdFx0X2NoaWxkQ29uc3RydWN0b3JzOiBbXVxuXHR9ICk7XG5cblx0YmFzZVByb3RvdHlwZSA9IG5ldyBiYXNlKCk7XG5cblx0Ly8gV2UgbmVlZCB0byBtYWtlIHRoZSBvcHRpb25zIGhhc2ggYSBwcm9wZXJ0eSBkaXJlY3RseSBvbiB0aGUgbmV3IGluc3RhbmNlXG5cdC8vIG90aGVyd2lzZSB3ZSdsbCBtb2RpZnkgdGhlIG9wdGlvbnMgaGFzaCBvbiB0aGUgcHJvdG90eXBlIHRoYXQgd2UncmVcblx0Ly8gaW5oZXJpdGluZyBmcm9tXG5cdGJhc2VQcm90b3R5cGUub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCgge30sIGJhc2VQcm90b3R5cGUub3B0aW9ucyApO1xuXHQkLmVhY2goIHByb3RvdHlwZSwgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdGlmICggdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSB2YWx1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cHJveGllZFByb3RvdHlwZVsgcHJvcCBdID0gKCBmdW5jdGlvbigpIHtcblx0XHRcdGZ1bmN0aW9uIF9zdXBlcigpIHtcblx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBfc3VwZXJBcHBseSggYXJncyApIHtcblx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgX19zdXBlciA9IHRoaXMuX3N1cGVyO1xuXHRcdFx0XHR2YXIgX19zdXBlckFwcGx5ID0gdGhpcy5fc3VwZXJBcHBseTtcblx0XHRcdFx0dmFyIHJldHVyblZhbHVlO1xuXG5cdFx0XHRcdHRoaXMuX3N1cGVyID0gX3N1cGVyO1xuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuVmFsdWUgPSB2YWx1ZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfX3N1cGVyO1xuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX19zdXBlckFwcGx5O1xuXG5cdFx0XHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0XHRcdH07XG5cdFx0fSApKCk7XG5cdH0gKTtcblx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gJC53aWRnZXQuZXh0ZW5kKCBiYXNlUHJvdG90eXBlLCB7XG5cblx0XHQvLyBUT0RPOiByZW1vdmUgc3VwcG9ydCBmb3Igd2lkZ2V0RXZlbnRQcmVmaXhcblx0XHQvLyBhbHdheXMgdXNlIHRoZSBuYW1lICsgYSBjb2xvbiBhcyB0aGUgcHJlZml4LCBlLmcuLCBkcmFnZ2FibGU6c3RhcnRcblx0XHQvLyBkb24ndCBwcmVmaXggZm9yIHdpZGdldHMgdGhhdCBhcmVuJ3QgRE9NLWJhc2VkXG5cdFx0d2lkZ2V0RXZlbnRQcmVmaXg6IGV4aXN0aW5nQ29uc3RydWN0b3IgPyAoIGJhc2VQcm90b3R5cGUud2lkZ2V0RXZlbnRQcmVmaXggfHwgbmFtZSApIDogbmFtZVxuXHR9LCBwcm94aWVkUHJvdG90eXBlLCB7XG5cdFx0Y29uc3RydWN0b3I6IGNvbnN0cnVjdG9yLFxuXHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuXHRcdHdpZGdldE5hbWU6IG5hbWUsXG5cdFx0d2lkZ2V0RnVsbE5hbWU6IGZ1bGxOYW1lXG5cdH0gKTtcblxuXHQvLyBJZiB0aGlzIHdpZGdldCBpcyBiZWluZyByZWRlZmluZWQgdGhlbiB3ZSBuZWVkIHRvIGZpbmQgYWxsIHdpZGdldHMgdGhhdFxuXHQvLyBhcmUgaW5oZXJpdGluZyBmcm9tIGl0IGFuZCByZWRlZmluZSBhbGwgb2YgdGhlbSBzbyB0aGF0IHRoZXkgaW5oZXJpdCBmcm9tXG5cdC8vIHRoZSBuZXcgdmVyc2lvbiBvZiB0aGlzIHdpZGdldC4gV2UncmUgZXNzZW50aWFsbHkgdHJ5aW5nIHRvIHJlcGxhY2Ugb25lXG5cdC8vIGxldmVsIGluIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5cdGlmICggZXhpc3RpbmdDb25zdHJ1Y3RvciApIHtcblx0XHQkLmVhY2goIGV4aXN0aW5nQ29uc3RydWN0b3IuX2NoaWxkQ29uc3RydWN0b3JzLCBmdW5jdGlvbiggaSwgY2hpbGQgKSB7XG5cdFx0XHR2YXIgY2hpbGRQcm90b3R5cGUgPSBjaGlsZC5wcm90b3R5cGU7XG5cblx0XHRcdC8vIFJlZGVmaW5lIHRoZSBjaGlsZCB3aWRnZXQgdXNpbmcgdGhlIHNhbWUgcHJvdG90eXBlIHRoYXQgd2FzXG5cdFx0XHQvLyBvcmlnaW5hbGx5IHVzZWQsIGJ1dCBpbmhlcml0IGZyb20gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoZSBiYXNlXG5cdFx0XHQkLndpZGdldCggY2hpbGRQcm90b3R5cGUubmFtZXNwYWNlICsgXCIuXCIgKyBjaGlsZFByb3RvdHlwZS53aWRnZXROYW1lLCBjb25zdHJ1Y3Rvcixcblx0XHRcdFx0Y2hpbGQuX3Byb3RvICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBsaXN0IG9mIGV4aXN0aW5nIGNoaWxkIGNvbnN0cnVjdG9ycyBmcm9tIHRoZSBvbGQgY29uc3RydWN0b3Jcblx0XHQvLyBzbyB0aGUgb2xkIGNoaWxkIGNvbnN0cnVjdG9ycyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcblx0XHRkZWxldGUgZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnM7XG5cdH0gZWxzZSB7XG5cdFx0YmFzZS5fY2hpbGRDb25zdHJ1Y3RvcnMucHVzaCggY29uc3RydWN0b3IgKTtcblx0fVxuXG5cdCQud2lkZ2V0LmJyaWRnZSggbmFtZSwgY29uc3RydWN0b3IgKTtcblxuXHRyZXR1cm4gY29uc3RydWN0b3I7XG59O1xuXG4kLndpZGdldC5leHRlbmQgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHR2YXIgaW5wdXQgPSB3aWRnZXRTbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblx0dmFyIGlucHV0SW5kZXggPSAwO1xuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdHZhciBrZXk7XG5cdHZhciB2YWx1ZTtcblxuXHRmb3IgKCA7IGlucHV0SW5kZXggPCBpbnB1dExlbmd0aDsgaW5wdXRJbmRleCsrICkge1xuXHRcdGZvciAoIGtleSBpbiBpbnB1dFsgaW5wdXRJbmRleCBdICkge1xuXHRcdFx0dmFsdWUgPSBpbnB1dFsgaW5wdXRJbmRleCBdWyBrZXkgXTtcblx0XHRcdGlmICggd2lkZ2V0SGFzT3duUHJvcGVydHkuY2FsbCggaW5wdXRbIGlucHV0SW5kZXggXSwga2V5ICkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBDbG9uZSBvYmplY3RzXG5cdFx0XHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHRcdHRhcmdldFsga2V5IF0gPSAkLmlzUGxhaW5PYmplY3QoIHRhcmdldFsga2V5IF0gKSA/XG5cdFx0XHRcdFx0XHQkLndpZGdldC5leHRlbmQoIHt9LCB0YXJnZXRbIGtleSBdLCB2YWx1ZSApIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgZXh0ZW5kIHN0cmluZ3MsIGFycmF5cywgZXRjLiB3aXRoIG9iamVjdHNcblx0XHRcdFx0XHRcdCQud2lkZ2V0LmV4dGVuZCgge30sIHZhbHVlICk7XG5cblx0XHRcdFx0Ly8gQ29weSBldmVyeXRoaW5nIGVsc2UgYnkgcmVmZXJlbmNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG4kLndpZGdldC5icmlkZ2UgPSBmdW5jdGlvbiggbmFtZSwgb2JqZWN0ICkge1xuXHR2YXIgZnVsbE5hbWUgPSBvYmplY3QucHJvdG90eXBlLndpZGdldEZ1bGxOYW1lIHx8IG5hbWU7XG5cdCQuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBpc01ldGhvZENhbGwgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIjtcblx0XHR2YXIgYXJncyA9IHdpZGdldFNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHRcdHZhciByZXR1cm5WYWx1ZSA9IHRoaXM7XG5cblx0XHRpZiAoIGlzTWV0aG9kQ2FsbCApIHtcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBlbXB0eSBjb2xsZWN0aW9uLCB3ZSBuZWVkIHRvIGhhdmUgdGhlIGluc3RhbmNlIG1ldGhvZFxuXHRcdFx0Ly8gcmV0dXJuIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHRoZSBqUXVlcnkgaW5zdGFuY2Vcblx0XHRcdGlmICggIXRoaXMubGVuZ3RoICYmIG9wdGlvbnMgPT09IFwiaW5zdGFuY2VcIiApIHtcblx0XHRcdFx0cmV0dXJuVmFsdWUgPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBtZXRob2RWYWx1ZTtcblx0XHRcdFx0XHR2YXIgaW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbnMgPT09IFwiaW5zdGFuY2VcIiApIHtcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlID0gaW5zdGFuY2U7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJjYW5ub3QgY2FsbCBtZXRob2RzIG9uIFwiICsgbmFtZSArXG5cdFx0XHRcdFx0XHRcdFwiIHByaW9yIHRvIGluaXRpYWxpemF0aW9uOyBcIiArXG5cdFx0XHRcdFx0XHRcdFwiYXR0ZW1wdGVkIHRvIGNhbGwgbWV0aG9kICdcIiArIG9wdGlvbnMgKyBcIidcIiApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdHlwZW9mIGluc3RhbmNlWyBvcHRpb25zIF0gIT09IFwiZnVuY3Rpb25cIiB8fFxuXHRcdFx0XHRcdFx0b3B0aW9ucy5jaGFyQXQoIDAgKSA9PT0gXCJfXCIgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJubyBzdWNoIG1ldGhvZCAnXCIgKyBvcHRpb25zICsgXCInIGZvciBcIiArIG5hbWUgK1xuXHRcdFx0XHRcdFx0XHRcIiB3aWRnZXQgaW5zdGFuY2VcIiApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1ldGhvZFZhbHVlID0gaW5zdGFuY2VbIG9wdGlvbnMgXS5hcHBseSggaW5zdGFuY2UsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggbWV0aG9kVmFsdWUgIT09IGluc3RhbmNlICYmIG1ldGhvZFZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IG1ldGhvZFZhbHVlICYmIG1ldGhvZFZhbHVlLmpxdWVyeSA/XG5cdFx0XHRcdFx0XHRcdHJldHVyblZhbHVlLnB1c2hTdGFjayggbWV0aG9kVmFsdWUuZ2V0KCkgKSA6XG5cdFx0XHRcdFx0XHRcdG1ldGhvZFZhbHVlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEFsbG93IG11bHRpcGxlIGhhc2hlcyB0byBiZSBwYXNzZWQgb24gaW5pdFxuXHRcdFx0aWYgKCBhcmdzLmxlbmd0aCApIHtcblx0XHRcdFx0b3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZC5hcHBseSggbnVsbCwgWyBvcHRpb25zIF0uY29uY2F0KCBhcmdzICkgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGluc3RhbmNlID0gJC5kYXRhKCB0aGlzLCBmdWxsTmFtZSApO1xuXHRcdFx0XHRpZiAoIGluc3RhbmNlICkge1xuXHRcdFx0XHRcdGluc3RhbmNlLm9wdGlvbiggb3B0aW9ucyB8fCB7fSApO1xuXHRcdFx0XHRcdGlmICggaW5zdGFuY2UuX2luaXQgKSB7XG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5faW5pdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lLCBuZXcgb2JqZWN0KCBvcHRpb25zLCB0aGlzICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fTtcbn07XG5cbiQuV2lkZ2V0ID0gZnVuY3Rpb24oIC8qIG9wdGlvbnMsIGVsZW1lbnQgKi8gKSB7fTtcbiQuV2lkZ2V0Ll9jaGlsZENvbnN0cnVjdG9ycyA9IFtdO1xuXG4kLldpZGdldC5wcm90b3R5cGUgPSB7XG5cdHdpZGdldE5hbWU6IFwid2lkZ2V0XCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcIlwiLFxuXHRkZWZhdWx0RWxlbWVudDogXCI8ZGl2PlwiLFxuXG5cdG9wdGlvbnM6IHtcblx0XHRjbGFzc2VzOiB7fSxcblx0XHRkaXNhYmxlZDogZmFsc2UsXG5cblx0XHQvLyBDYWxsYmFja3Ncblx0XHRjcmVhdGU6IG51bGxcblx0fSxcblxuXHRfY3JlYXRlV2lkZ2V0OiBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblx0XHRlbGVtZW50ID0gJCggZWxlbWVudCB8fCB0aGlzLmRlZmF1bHRFbGVtZW50IHx8IHRoaXMgKVsgMCBdO1xuXHRcdHRoaXMuZWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLnV1aWQgPSB3aWRnZXRVdWlkKys7XG5cdFx0dGhpcy5ldmVudE5hbWVzcGFjZSA9IFwiLlwiICsgdGhpcy53aWRnZXROYW1lICsgdGhpcy51dWlkO1xuXG5cdFx0dGhpcy5iaW5kaW5ncyA9ICQoKTtcblx0XHR0aGlzLmhvdmVyYWJsZSA9ICQoKTtcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoKTtcblx0XHR0aGlzLmNsYXNzZXNFbGVtZW50TG9va3VwID0ge307XG5cblx0XHRpZiAoIGVsZW1lbnQgIT09IHRoaXMgKSB7XG5cdFx0XHQkLmRhdGEoIGVsZW1lbnQsIHRoaXMud2lkZ2V0RnVsbE5hbWUsIHRoaXMgKTtcblx0XHRcdHRoaXMuX29uKCB0cnVlLCB0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0cmVtb3ZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCBldmVudC50YXJnZXQgPT09IGVsZW1lbnQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHRoaXMuZG9jdW1lbnQgPSAkKCBlbGVtZW50LnN0eWxlID9cblxuXHRcdFx0XHQvLyBFbGVtZW50IHdpdGhpbiB0aGUgZG9jdW1lbnRcblx0XHRcdFx0ZWxlbWVudC5vd25lckRvY3VtZW50IDpcblxuXHRcdFx0XHQvLyBFbGVtZW50IGlzIHdpbmRvdyBvciBkb2N1bWVudFxuXHRcdFx0XHRlbGVtZW50LmRvY3VtZW50IHx8IGVsZW1lbnQgKTtcblx0XHRcdHRoaXMud2luZG93ID0gJCggdGhpcy5kb2N1bWVudFsgMCBdLmRlZmF1bHRWaWV3IHx8IHRoaXMuZG9jdW1lbnRbIDAgXS5wYXJlbnRXaW5kb3cgKTtcblx0XHR9XG5cblx0XHR0aGlzLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LFxuXHRcdFx0dGhpcy5vcHRpb25zLFxuXHRcdFx0dGhpcy5fZ2V0Q3JlYXRlT3B0aW9ucygpLFxuXHRcdFx0b3B0aW9ucyApO1xuXG5cdFx0dGhpcy5fY3JlYXRlKCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX3NldE9wdGlvbkRpc2FibGVkKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKTtcblx0XHR9XG5cblx0XHR0aGlzLl90cmlnZ2VyKCBcImNyZWF0ZVwiLCBudWxsLCB0aGlzLl9nZXRDcmVhdGVFdmVudERhdGEoKSApO1xuXHRcdHRoaXMuX2luaXQoKTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9LFxuXG5cdF9nZXRDcmVhdGVFdmVudERhdGE6ICQubm9vcCxcblxuXHRfY3JlYXRlOiAkLm5vb3AsXG5cblx0X2luaXQ6ICQubm9vcCxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLl9kZXN0cm95KCk7XG5cdFx0JC5lYWNoKCB0aGlzLmNsYXNzZXNFbGVtZW50TG9va3VwLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdHRoYXQuX3JlbW92ZUNsYXNzKCB2YWx1ZSwga2V5ICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gV2UgY2FuIHByb2JhYmx5IHJlbW92ZSB0aGUgdW5iaW5kIGNhbGxzIGluIDIuMFxuXHRcdC8vIGFsbCBldmVudCBiaW5kaW5ncyBzaG91bGQgZ28gdGhyb3VnaCB0aGlzLl9vbigpXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQub2ZmKCB0aGlzLmV2ZW50TmFtZXNwYWNlIClcblx0XHRcdC5yZW1vdmVEYXRhKCB0aGlzLndpZGdldEZ1bGxOYW1lICk7XG5cdFx0dGhpcy53aWRnZXQoKVxuXHRcdFx0Lm9mZiggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKTtcblxuXHRcdC8vIENsZWFuIHVwIGV2ZW50cyBhbmQgc3RhdGVzXG5cdFx0dGhpcy5iaW5kaW5ncy5vZmYoIHRoaXMuZXZlbnROYW1lc3BhY2UgKTtcblx0fSxcblxuXHRfZGVzdHJveTogJC5ub29wLFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0fSxcblxuXHRvcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBvcHRpb25zID0ga2V5O1xuXHRcdHZhciBwYXJ0cztcblx0XHR2YXIgY3VyT3B0aW9uO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHQvLyBEb24ndCByZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIGhhc2hcblx0XHRcdHJldHVybiAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vIEhhbmRsZSBuZXN0ZWQga2V5cywgZS5nLiwgXCJmb28uYmFyXCIgPT4geyBmb286IHsgYmFyOiBfX18gfSB9XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHRwYXJ0cyA9IGtleS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdGtleSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0XHRpZiAoIHBhcnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y3VyT3B0aW9uID0gb3B0aW9uc1sga2V5IF0gPSAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnNbIGtleSBdICk7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrICkge1xuXHRcdFx0XHRcdGN1ck9wdGlvblsgcGFydHNbIGkgXSBdID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF0gfHwge307XG5cdFx0XHRcdFx0Y3VyT3B0aW9uID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5ID0gcGFydHMucG9wKCk7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gY3VyT3B0aW9uWyBrZXkgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGN1ck9wdGlvblsga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3VyT3B0aW9uWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnNbIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogdGhpcy5vcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3NldE9wdGlvbnMoIG9wdGlvbnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0Zm9yICgga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb24oIGtleSwgb3B0aW9uc1sga2V5IF0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRpZiAoIGtleSA9PT0gXCJjbGFzc2VzXCIgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb25DbGFzc2VzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdHRoaXMub3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblxuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb25EaXNhYmxlZCggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2V0T3B0aW9uQ2xhc3NlczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc0tleSwgZWxlbWVudHMsIGN1cnJlbnRFbGVtZW50cztcblxuXHRcdGZvciAoIGNsYXNzS2V5IGluIHZhbHVlICkge1xuXHRcdFx0Y3VycmVudEVsZW1lbnRzID0gdGhpcy5jbGFzc2VzRWxlbWVudExvb2t1cFsgY2xhc3NLZXkgXTtcblx0XHRcdGlmICggdmFsdWVbIGNsYXNzS2V5IF0gPT09IHRoaXMub3B0aW9ucy5jbGFzc2VzWyBjbGFzc0tleSBdIHx8XG5cdFx0XHRcdFx0IWN1cnJlbnRFbGVtZW50cyB8fFxuXHRcdFx0XHRcdCFjdXJyZW50RWxlbWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2UgYXJlIGRvaW5nIHRoaXMgdG8gY3JlYXRlIGEgbmV3IGpRdWVyeSBvYmplY3QgYmVjYXVzZSB0aGUgX3JlbW92ZUNsYXNzKCkgY2FsbFxuXHRcdFx0Ly8gb24gdGhlIG5leHQgbGluZSBpcyBnb2luZyB0byBkZXN0cm95IHRoZSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZWxlbWVudHMgYmVpbmdcblx0XHRcdC8vIHRyYWNrZWQuIFdlIG5lZWQgdG8gc2F2ZSBhIGNvcHkgb2YgdGhpcyBjb2xsZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCB0aGUgbmV3IGNsYXNzZXNcblx0XHRcdC8vIGJlbG93LlxuXHRcdFx0ZWxlbWVudHMgPSAkKCBjdXJyZW50RWxlbWVudHMuZ2V0KCkgKTtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBjdXJyZW50RWxlbWVudHMsIGNsYXNzS2V5ICk7XG5cblx0XHRcdC8vIFdlIGRvbid0IHVzZSBfYWRkQ2xhc3MoKSBoZXJlLCBiZWNhdXNlIHRoYXQgdXNlcyB0aGlzLm9wdGlvbnMuY2xhc3Nlc1xuXHRcdFx0Ly8gZm9yIGdlbmVyYXRpbmcgdGhlIHN0cmluZyBvZiBjbGFzc2VzLiBXZSB3YW50IHRvIHVzZSB0aGUgdmFsdWUgcGFzc2VkIGluIGZyb21cblx0XHRcdC8vIF9zZXRPcHRpb24oKSwgdGhpcyBpcyB0aGUgbmV3IHZhbHVlIG9mIHRoZSBjbGFzc2VzIG9wdGlvbiB3aGljaCB3YXMgcGFzc2VkIHRvXG5cdFx0XHQvLyBfc2V0T3B0aW9uKCkuIFdlIHBhc3MgdGhpcyB2YWx1ZSBkaXJlY3RseSB0byBfY2xhc3NlcygpLlxuXHRcdFx0ZWxlbWVudHMuYWRkQ2xhc3MoIHRoaXMuX2NsYXNzZXMoIHtcblx0XHRcdFx0ZWxlbWVudDogZWxlbWVudHMsXG5cdFx0XHRcdGtleXM6IGNsYXNzS2V5LFxuXHRcdFx0XHRjbGFzc2VzOiB2YWx1ZSxcblx0XHRcdFx0YWRkOiB0cnVlXG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbkRpc2FibGVkOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dGhpcy5fdG9nZ2xlQ2xhc3MoIHRoaXMud2lkZ2V0KCksIHRoaXMud2lkZ2V0RnVsbE5hbWUgKyBcIi1kaXNhYmxlZFwiLCBudWxsLCAhIXZhbHVlICk7XG5cblx0XHQvLyBJZiB0aGUgd2lkZ2V0IGlzIGJlY29taW5nIGRpc2FibGVkLCB0aGVuIG5vdGhpbmcgaXMgaW50ZXJhY3RpdmVcblx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIHRoaXMuaG92ZXJhYmxlLCBudWxsLCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmZvY3VzYWJsZSwgbnVsbCwgXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGVuYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbnMoIHsgZGlzYWJsZWQ6IGZhbHNlIH0gKTtcblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0T3B0aW9ucyggeyBkaXNhYmxlZDogdHJ1ZSB9ICk7XG5cdH0sXG5cblx0X2NsYXNzZXM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBmdWxsID0gW107XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0b3B0aW9ucyA9ICQuZXh0ZW5kKCB7XG5cdFx0XHRlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG5cdFx0XHRjbGFzc2VzOiB0aGlzLm9wdGlvbnMuY2xhc3NlcyB8fCB7fVxuXHRcdH0sIG9wdGlvbnMgKTtcblxuXHRcdGZ1bmN0aW9uIGJpbmRSZW1vdmVFdmVudCgpIHtcblx0XHRcdHZhciBub2Rlc1RvQmluZCA9IFtdO1xuXG5cdFx0XHRvcHRpb25zLmVsZW1lbnQuZWFjaCggZnVuY3Rpb24oIF8sIGVsZW1lbnQgKSB7XG5cdFx0XHRcdHZhciBpc1RyYWNrZWQgPSAkLm1hcCggdGhhdC5jbGFzc2VzRWxlbWVudExvb2t1cCwgZnVuY3Rpb24oIGVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50cztcblx0XHRcdFx0fSApXG5cdFx0XHRcdFx0LnNvbWUoIGZ1bmN0aW9uKCBlbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtZW50cy5pcyggZWxlbWVudCApO1xuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRpZiAoICFpc1RyYWNrZWQgKSB7XG5cdFx0XHRcdFx0bm9kZXNUb0JpbmQucHVzaCggZWxlbWVudCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHRcdHRoYXQuX29uKCAkKCBub2Rlc1RvQmluZCApLCB7XG5cdFx0XHRcdHJlbW92ZTogXCJfdW50cmFja0NsYXNzZXNFbGVtZW50XCJcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwcm9jZXNzQ2xhc3NTdHJpbmcoIGNsYXNzZXMsIGNoZWNrT3B0aW9uICkge1xuXHRcdFx0dmFyIGN1cnJlbnQsIGk7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGN1cnJlbnQgPSB0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwWyBjbGFzc2VzWyBpIF0gXSB8fCAkKCk7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5hZGQgKSB7XG5cdFx0XHRcdFx0YmluZFJlbW92ZUV2ZW50KCk7XG5cdFx0XHRcdFx0Y3VycmVudCA9ICQoICQudW5pcXVlU29ydCggY3VycmVudC5nZXQoKS5jb25jYXQoIG9wdGlvbnMuZWxlbWVudC5nZXQoKSApICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdXJyZW50ID0gJCggY3VycmVudC5ub3QoIG9wdGlvbnMuZWxlbWVudCApLmdldCgpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhhdC5jbGFzc2VzRWxlbWVudExvb2t1cFsgY2xhc3Nlc1sgaSBdIF0gPSBjdXJyZW50O1xuXHRcdFx0XHRmdWxsLnB1c2goIGNsYXNzZXNbIGkgXSApO1xuXHRcdFx0XHRpZiAoIGNoZWNrT3B0aW9uICYmIG9wdGlvbnMuY2xhc3Nlc1sgY2xhc3Nlc1sgaSBdIF0gKSB7XG5cdFx0XHRcdFx0ZnVsbC5wdXNoKCBvcHRpb25zLmNsYXNzZXNbIGNsYXNzZXNbIGkgXSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMua2V5cyApIHtcblx0XHRcdHByb2Nlc3NDbGFzc1N0cmluZyggb3B0aW9ucy5rZXlzLm1hdGNoKCAvXFxTKy9nICkgfHwgW10sIHRydWUgKTtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmV4dHJhICkge1xuXHRcdFx0cHJvY2Vzc0NsYXNzU3RyaW5nKCBvcHRpb25zLmV4dHJhLm1hdGNoKCAvXFxTKy9nICkgfHwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZnVsbC5qb2luKCBcIiBcIiApO1xuXHR9LFxuXG5cdF91bnRyYWNrQ2xhc3Nlc0VsZW1lbnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0JC5lYWNoKCB0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdGlmICggJC5pbkFycmF5KCBldmVudC50YXJnZXQsIHZhbHVlICkgIT09IC0xICkge1xuXHRcdFx0XHR0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwWyBrZXkgXSA9ICQoIHZhbHVlLm5vdCggZXZlbnQudGFyZ2V0ICkuZ2V0KCkgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHR0aGlzLl9vZmYoICQoIGV2ZW50LnRhcmdldCApICk7XG5cdH0sXG5cblx0X3JlbW92ZUNsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwga2V5cywgZXh0cmEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RvZ2dsZUNsYXNzKCBlbGVtZW50LCBrZXlzLCBleHRyYSwgZmFsc2UgKTtcblx0fSxcblxuXHRfYWRkQ2xhc3M6IGZ1bmN0aW9uKCBlbGVtZW50LCBrZXlzLCBleHRyYSApIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9nZ2xlQ2xhc3MoIGVsZW1lbnQsIGtleXMsIGV4dHJhLCB0cnVlICk7XG5cdH0sXG5cblx0X3RvZ2dsZUNsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwga2V5cywgZXh0cmEsIGFkZCApIHtcblx0XHRhZGQgPSAoIHR5cGVvZiBhZGQgPT09IFwiYm9vbGVhblwiICkgPyBhZGQgOiBleHRyYTtcblx0XHR2YXIgc2hpZnQgPSAoIHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiIHx8IGVsZW1lbnQgPT09IG51bGwgKSxcblx0XHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRcdGV4dHJhOiBzaGlmdCA/IGtleXMgOiBleHRyYSxcblx0XHRcdFx0a2V5czogc2hpZnQgPyBlbGVtZW50IDoga2V5cyxcblx0XHRcdFx0ZWxlbWVudDogc2hpZnQgPyB0aGlzLmVsZW1lbnQgOiBlbGVtZW50LFxuXHRcdFx0XHRhZGQ6IGFkZFxuXHRcdFx0fTtcblx0XHRvcHRpb25zLmVsZW1lbnQudG9nZ2xlQ2xhc3MoIHRoaXMuX2NsYXNzZXMoIG9wdGlvbnMgKSwgYWRkICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X29uOiBmdW5jdGlvbiggc3VwcHJlc3NEaXNhYmxlZENoZWNrLCBlbGVtZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgZGVsZWdhdGVFbGVtZW50O1xuXHRcdHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cblx0XHQvLyBObyBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgZmxhZywgc2h1ZmZsZSBhcmd1bWVudHNcblx0XHRpZiAoIHR5cGVvZiBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgIT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0aGFuZGxlcnMgPSBlbGVtZW50O1xuXHRcdFx0ZWxlbWVudCA9IHN1cHByZXNzRGlzYWJsZWRDaGVjaztcblx0XHRcdHN1cHByZXNzRGlzYWJsZWRDaGVjayA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIE5vIGVsZW1lbnQgYXJndW1lbnQsIHNodWZmbGUgYW5kIHVzZSB0aGlzLmVsZW1lbnRcblx0XHRpZiAoICFoYW5kbGVycyApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRkZWxlZ2F0ZUVsZW1lbnQgPSB0aGlzLndpZGdldCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtZW50ID0gZGVsZWdhdGVFbGVtZW50ID0gJCggZWxlbWVudCApO1xuXHRcdFx0dGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuYWRkKCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0JC5lYWNoKCBoYW5kbGVycywgZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVyICkge1xuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXG5cdFx0XHRcdC8vIEFsbG93IHdpZGdldHMgdG8gY3VzdG9taXplIHRoZSBkaXNhYmxlZCBoYW5kbGluZ1xuXHRcdFx0XHQvLyAtIGRpc2FibGVkIGFzIGFuIGFycmF5IGluc3RlYWQgb2YgYm9vbGVhblxuXHRcdFx0XHQvLyAtIGRpc2FibGVkIGNsYXNzIGFzIG1ldGhvZCBmb3IgZGlzYWJsaW5nIGluZGl2aWR1YWwgcGFydHNcblx0XHRcdFx0aWYgKCAhc3VwcHJlc3NEaXNhYmxlZENoZWNrICYmXG5cdFx0XHRcdFx0XHQoIGluc3RhbmNlLm9wdGlvbnMuZGlzYWJsZWQgPT09IHRydWUgfHxcblx0XHRcdFx0XHRcdCQoIHRoaXMgKS5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvcHkgdGhlIGd1aWQgc28gZGlyZWN0IHVuYmluZGluZyB3b3Jrc1xuXHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0aGFuZGxlclByb3h5Lmd1aWQgPSBoYW5kbGVyLmd1aWQgPVxuXHRcdFx0XHRcdGhhbmRsZXIuZ3VpZCB8fCBoYW5kbGVyUHJveHkuZ3VpZCB8fCAkLmd1aWQrKztcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1hdGNoID0gZXZlbnQubWF0Y2goIC9eKFtcXHc6LV0qKVxccyooLiopJC8gKTtcblx0XHRcdHZhciBldmVudE5hbWUgPSBtYXRjaFsgMSBdICsgaW5zdGFuY2UuZXZlbnROYW1lc3BhY2U7XG5cdFx0XHR2YXIgc2VsZWN0b3IgPSBtYXRjaFsgMiBdO1xuXG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRkZWxlZ2F0ZUVsZW1lbnQub24oIGV2ZW50TmFtZSwgc2VsZWN0b3IsIGhhbmRsZXJQcm94eSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudC5vbiggZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0X29mZjogZnVuY3Rpb24oIGVsZW1lbnQsIGV2ZW50TmFtZSApIHtcblx0XHRldmVudE5hbWUgPSAoIGV2ZW50TmFtZSB8fCBcIlwiICkuc3BsaXQoIFwiIFwiICkuam9pbiggdGhpcy5ldmVudE5hbWVzcGFjZSArIFwiIFwiICkgK1xuXHRcdFx0dGhpcy5ldmVudE5hbWVzcGFjZTtcblx0XHRlbGVtZW50Lm9mZiggZXZlbnROYW1lICk7XG5cblx0XHQvLyBDbGVhciB0aGUgc3RhY2sgdG8gYXZvaWQgbWVtb3J5IGxlYWtzICgjMTAwNTYpXG5cdFx0dGhpcy5iaW5kaW5ncyA9ICQoIHRoaXMuYmluZGluZ3Mubm90KCBlbGVtZW50ICkuZ2V0KCkgKTtcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoIHRoaXMuZm9jdXNhYmxlLm5vdCggZWxlbWVudCApLmdldCgpICk7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSAkKCB0aGlzLmhvdmVyYWJsZS5ub3QoIGVsZW1lbnQgKS5nZXQoKSApO1xuXHR9LFxuXG5cdF9kZWxheTogZnVuY3Rpb24oIGhhbmRsZXIsIGRlbGF5ICkge1xuXHRcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcblx0XHRcdHJldHVybiAoIHR5cGVvZiBoYW5kbGVyID09PSBcInN0cmluZ1wiID8gaW5zdGFuY2VbIGhhbmRsZXIgXSA6IGhhbmRsZXIgKVxuXHRcdFx0XHQuYXBwbHkoIGluc3RhbmNlLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdFx0dmFyIGluc3RhbmNlID0gdGhpcztcblx0XHRyZXR1cm4gc2V0VGltZW91dCggaGFuZGxlclByb3h5LCBkZWxheSB8fCAwICk7XG5cdH0sXG5cblx0X2hvdmVyYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSB0aGlzLmhvdmVyYWJsZS5hZGQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLl9vbiggZWxlbWVudCwge1xuXHRcdFx0bW91c2VlbnRlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR0aGlzLl9hZGRDbGFzcyggJCggZXZlbnQuY3VycmVudFRhcmdldCApLCBudWxsLCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRtb3VzZWxlYXZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRfZm9jdXNhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR0aGlzLmZvY3VzYWJsZSA9IHRoaXMuZm9jdXNhYmxlLmFkZCggZWxlbWVudCApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50LCB7XG5cdFx0XHRmb2N1c2luOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fSxcblx0XHRcdGZvY3Vzb3V0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRfdHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCBkYXRhICkge1xuXHRcdHZhciBwcm9wLCBvcmlnO1xuXHRcdHZhciBjYWxsYmFjayA9IHRoaXMub3B0aW9uc1sgdHlwZSBdO1xuXG5cdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cdFx0ZXZlbnQgPSAkLkV2ZW50KCBldmVudCApO1xuXHRcdGV2ZW50LnR5cGUgPSAoIHR5cGUgPT09IHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggP1xuXHRcdFx0dHlwZSA6XG5cdFx0XHR0aGlzLndpZGdldEV2ZW50UHJlZml4ICsgdHlwZSApLnRvTG93ZXJDYXNlKCk7XG5cblx0XHQvLyBUaGUgb3JpZ2luYWwgZXZlbnQgbWF5IGNvbWUgZnJvbSBhbnkgZWxlbWVudFxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHRhcmdldCBvbiB0aGUgbmV3IGV2ZW50XG5cdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcy5lbGVtZW50WyAwIF07XG5cblx0XHQvLyBDb3B5IG9yaWdpbmFsIGV2ZW50IHByb3BlcnRpZXMgb3ZlciB0byB0aGUgbmV3IGV2ZW50XG5cdFx0b3JpZyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cdFx0aWYgKCBvcmlnICkge1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRpZiAoICEoIHByb3AgaW4gZXZlbnQgKSApIHtcblx0XHRcdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ1sgcHJvcCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIGV2ZW50LCBkYXRhICk7XG5cdFx0cmV0dXJuICEoIHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcy5lbGVtZW50WyAwIF0sIFsgZXZlbnQgXS5jb25jYXQoIGRhdGEgKSApID09PSBmYWxzZSB8fFxuXHRcdFx0ZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKTtcblx0fVxufTtcblxuJC5lYWNoKCB7IHNob3c6IFwiZmFkZUluXCIsIGhpZGU6IFwiZmFkZU91dFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIGRlZmF1bHRFZmZlY3QgKSB7XG5cdCQuV2lkZ2V0LnByb3RvdHlwZVsgXCJfXCIgKyBtZXRob2QgXSA9IGZ1bmN0aW9uKCBlbGVtZW50LCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b3B0aW9ucyA9IHsgZWZmZWN0OiBvcHRpb25zIH07XG5cdFx0fVxuXG5cdFx0dmFyIGhhc09wdGlvbnM7XG5cdFx0dmFyIGVmZmVjdE5hbWUgPSAhb3B0aW9ucyA/XG5cdFx0XHRtZXRob2QgOlxuXHRcdFx0b3B0aW9ucyA9PT0gdHJ1ZSB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiA/XG5cdFx0XHRcdGRlZmF1bHRFZmZlY3QgOlxuXHRcdFx0XHRvcHRpb25zLmVmZmVjdCB8fCBkZWZhdWx0RWZmZWN0O1xuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB7IGR1cmF0aW9uOiBvcHRpb25zIH07XG5cdFx0fSBlbHNlIGlmICggb3B0aW9ucyA9PT0gdHJ1ZSApIHtcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHR9XG5cblx0XHRoYXNPcHRpb25zID0gISQuaXNFbXB0eU9iamVjdCggb3B0aW9ucyApO1xuXHRcdG9wdGlvbnMuY29tcGxldGUgPSBjYWxsYmFjaztcblxuXHRcdGlmICggb3B0aW9ucy5kZWxheSApIHtcblx0XHRcdGVsZW1lbnQuZGVsYXkoIG9wdGlvbnMuZGVsYXkgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhhc09wdGlvbnMgJiYgJC5lZmZlY3RzICYmICQuZWZmZWN0cy5lZmZlY3RbIGVmZmVjdE5hbWUgXSApIHtcblx0XHRcdGVsZW1lbnRbIG1ldGhvZCBdKCBvcHRpb25zICk7XG5cdFx0fSBlbHNlIGlmICggZWZmZWN0TmFtZSAhPT0gbWV0aG9kICYmIGVsZW1lbnRbIGVmZmVjdE5hbWUgXSApIHtcblx0XHRcdGVsZW1lbnRbIGVmZmVjdE5hbWUgXSggb3B0aW9ucy5kdXJhdGlvbiwgb3B0aW9ucy5lYXNpbmcsIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW1lbnQucXVldWUoIGZ1bmN0aW9uKCBuZXh0ICkge1xuXHRcdFx0XHQkKCB0aGlzIClbIG1ldGhvZCBdKCk7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCggZWxlbWVudFsgMCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV4dCgpO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxucmV0dXJuICQud2lkZ2V0O1xuXG59ICk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsVUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/jquery-ui/ui/widget.js\n')},"../node_modules/jquery-ui/ui/widgets/tabs.js":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery UI Tabs 1.13.2\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n */\n\n//>>label: Tabs\n//>>group: Widgets\n//>>description: Transforms a set of container elements into a tab structure.\n//>>docs: http://api.jqueryui.com/tabs/\n//>>demos: http://jqueryui.com/tabs/\n//>>css.structure: ../../themes/base/core.css\n//>>css.structure: ../../themes/base/tabs.css\n//>>css.theme: ../../themes/base/theme.css\n\n( function( factory ) {\n\t"use strict";\n\n\tif ( true ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t\t\t__webpack_require__(/*! jquery */ "../node_modules/jquery/dist/jquery.js"),\n\t\t\t__webpack_require__(/*! ../keycode */ "../node_modules/jquery-ui/ui/keycode.js"),\n\t\t\t__webpack_require__(/*! ../safe-active-element */ "../node_modules/jquery-ui/ui/safe-active-element.js"),\n\t\t\t__webpack_require__(/*! ../unique-id */ "../node_modules/jquery-ui/ui/unique-id.js"),\n\t\t\t__webpack_require__(/*! ../version */ "../node_modules/jquery-ui/ui/version.js"),\n\t\t\t__webpack_require__(/*! ../widget */ "../node_modules/jquery-ui/ui/widget.js")\n\t\t], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n} )( function( $ ) {\n"use strict";\n\n$.widget( "ui.tabs", {\n\tversion: "1.13.2",\n\tdelay: 300,\n\toptions: {\n\t\tactive: null,\n\t\tclasses: {\n\t\t\t"ui-tabs": "ui-corner-all",\n\t\t\t"ui-tabs-nav": "ui-corner-all",\n\t\t\t"ui-tabs-panel": "ui-corner-bottom",\n\t\t\t"ui-tabs-tab": "ui-corner-top"\n\t\t},\n\t\tcollapsible: false,\n\t\tevent: "click",\n\t\theightStyle: "content",\n\t\thide: null,\n\t\tshow: null,\n\n\t\t// Callbacks\n\t\tactivate: null,\n\t\tbeforeActivate: null,\n\t\tbeforeLoad: null,\n\t\tload: null\n\t},\n\n\t_isLocal: ( function() {\n\t\tvar rhash = /#.*$/;\n\n\t\treturn function( anchor ) {\n\t\t\tvar anchorUrl, locationUrl;\n\n\t\t\tanchorUrl = anchor.href.replace( rhash, "" );\n\t\t\tlocationUrl = location.href.replace( rhash, "" );\n\n\t\t\t// Decoding may throw an error if the URL isn\'t UTF-8 (#9518)\n\t\t\ttry {\n\t\t\t\tanchorUrl = decodeURIComponent( anchorUrl );\n\t\t\t} catch ( error ) {}\n\t\t\ttry {\n\t\t\t\tlocationUrl = decodeURIComponent( locationUrl );\n\t\t\t} catch ( error ) {}\n\n\t\t\treturn anchor.hash.length > 1 && anchorUrl === locationUrl;\n\t\t};\n\t} )(),\n\n\t_create: function() {\n\t\tvar that = this,\n\t\t\toptions = this.options;\n\n\t\tthis.running = false;\n\n\t\tthis._addClass( "ui-tabs", "ui-widget ui-widget-content" );\n\t\tthis._toggleClass( "ui-tabs-collapsible", null, options.collapsible );\n\n\t\tthis._processTabs();\n\t\toptions.active = this._initialActive();\n\n\t\t// Take disabling tabs via class attribute from HTML\n\t\t// into account and update option properly.\n\t\tif ( Array.isArray( options.disabled ) ) {\n\t\t\toptions.disabled = $.uniqueSort( options.disabled.concat(\n\t\t\t\t$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {\n\t\t\t\t\treturn that.tabs.index( li );\n\t\t\t\t} )\n\t\t\t) ).sort();\n\t\t}\n\n\t\t// Check for length avoids error when initializing empty list\n\t\tif ( this.options.active !== false && this.anchors.length ) {\n\t\t\tthis.active = this._findActive( options.active );\n\t\t} else {\n\t\t\tthis.active = $();\n\t\t}\n\n\t\tthis._refresh();\n\n\t\tif ( this.active.length ) {\n\t\t\tthis.load( options.active );\n\t\t}\n\t},\n\n\t_initialActive: function() {\n\t\tvar active = this.options.active,\n\t\t\tcollapsible = this.options.collapsible,\n\t\t\tlocationHash = location.hash.substring( 1 );\n\n\t\tif ( active === null ) {\n\n\t\t\t// check the fragment identifier in the URL\n\t\t\tif ( locationHash ) {\n\t\t\t\tthis.tabs.each( function( i, tab ) {\n\t\t\t\t\tif ( $( tab ).attr( "aria-controls" ) === locationHash ) {\n\t\t\t\t\t\tactive = i;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Check for a tab marked active via a class\n\t\t\tif ( active === null ) {\n\t\t\t\tactive = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );\n\t\t\t}\n\n\t\t\t// No active tab, set to false\n\t\t\tif ( active === null || active === -1 ) {\n\t\t\t\tactive = this.tabs.length ? 0 : false;\n\t\t\t}\n\t\t}\n\n\t\t// Handle numbers: negative, out of range\n\t\tif ( active !== false ) {\n\t\t\tactive = this.tabs.index( this.tabs.eq( active ) );\n\t\t\tif ( active === -1 ) {\n\t\t\t\tactive = collapsible ? false : 0;\n\t\t\t}\n\t\t}\n\n\t\t// Don\'t allow collapsible: false and active: false\n\t\tif ( !collapsible && active === false && this.anchors.length ) {\n\t\t\tactive = 0;\n\t\t}\n\n\t\treturn active;\n\t},\n\n\t_getCreateEventData: function() {\n\t\treturn {\n\t\t\ttab: this.active,\n\t\t\tpanel: !this.active.length ? $() : this._getPanelForTab( this.active )\n\t\t};\n\t},\n\n\t_tabKeydown: function( event ) {\n\t\tvar focusedTab = $( $.ui.safeActiveElement( this.document[ 0 ] ) ).closest( "li" ),\n\t\t\tselectedIndex = this.tabs.index( focusedTab ),\n\t\t\tgoingForward = true;\n\n\t\tif ( this._handlePageNav( event ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch ( event.keyCode ) {\n\t\tcase $.ui.keyCode.RIGHT:\n\t\tcase $.ui.keyCode.DOWN:\n\t\t\tselectedIndex++;\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.UP:\n\t\tcase $.ui.keyCode.LEFT:\n\t\t\tgoingForward = false;\n\t\t\tselectedIndex--;\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.END:\n\t\t\tselectedIndex = this.anchors.length - 1;\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.HOME:\n\t\t\tselectedIndex = 0;\n\t\t\tbreak;\n\t\tcase $.ui.keyCode.SPACE:\n\n\t\t\t// Activate only, no collapsing\n\t\t\tevent.preventDefault();\n\t\t\tclearTimeout( this.activating );\n\t\t\tthis._activate( selectedIndex );\n\t\t\treturn;\n\t\tcase $.ui.keyCode.ENTER:\n\n\t\t\t// Toggle (cancel delayed activation, allow collapsing)\n\t\t\tevent.preventDefault();\n\t\t\tclearTimeout( this.activating );\n\n\t\t\t// Determine if we should collapse or activate\n\t\t\tthis._activate( selectedIndex === this.options.active ? false : selectedIndex );\n\t\t\treturn;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\n\t\t// Focus the appropriate tab, based on which key was pressed\n\t\tevent.preventDefault();\n\t\tclearTimeout( this.activating );\n\t\tselectedIndex = this._focusNextTab( selectedIndex, goingForward );\n\n\t\t// Navigating with control/command key will prevent automatic activation\n\t\tif ( !event.ctrlKey && !event.metaKey ) {\n\n\t\t\t// Update aria-selected immediately so that AT think the tab is already selected.\n\t\t\t// Otherwise AT may confuse the user by stating that they need to activate the tab,\n\t\t\t// but the tab will already be activated by the time the announcement finishes.\n\t\t\tfocusedTab.attr( "aria-selected", "false" );\n\t\t\tthis.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );\n\n\t\t\tthis.activating = this._delay( function() {\n\t\t\t\tthis.option( "active", selectedIndex );\n\t\t\t}, this.delay );\n\t\t}\n\t},\n\n\t_panelKeydown: function( event ) {\n\t\tif ( this._handlePageNav( event ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Ctrl+up moves focus to the current tab\n\t\tif ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {\n\t\t\tevent.preventDefault();\n\t\t\tthis.active.trigger( "focus" );\n\t\t}\n\t},\n\n\t// Alt+page up/down moves focus to the previous/next tab (and activates)\n\t_handlePageNav: function( event ) {\n\t\tif ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {\n\t\t\tthis._activate( this._focusNextTab( this.options.active - 1, false ) );\n\t\t\treturn true;\n\t\t}\n\t\tif ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {\n\t\t\tthis._activate( this._focusNextTab( this.options.active + 1, true ) );\n\t\t\treturn true;\n\t\t}\n\t},\n\n\t_findNextTab: function( index, goingForward ) {\n\t\tvar lastTabIndex = this.tabs.length - 1;\n\n\t\tfunction constrain() {\n\t\t\tif ( index > lastTabIndex ) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tif ( index < 0 ) {\n\t\t\t\tindex = lastTabIndex;\n\t\t\t}\n\t\t\treturn index;\n\t\t}\n\n\t\twhile ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {\n\t\t\tindex = goingForward ? index + 1 : index - 1;\n\t\t}\n\n\t\treturn index;\n\t},\n\n\t_focusNextTab: function( index, goingForward ) {\n\t\tindex = this._findNextTab( index, goingForward );\n\t\tthis.tabs.eq( index ).trigger( "focus" );\n\t\treturn index;\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tif ( key === "active" ) {\n\n\t\t\t// _activate() will handle invalid values and update this.options\n\t\t\tthis._activate( value );\n\t\t\treturn;\n\t\t}\n\n\t\tthis._super( key, value );\n\n\t\tif ( key === "collapsible" ) {\n\t\t\tthis._toggleClass( "ui-tabs-collapsible", null, value );\n\n\t\t\t// Setting collapsible: false while collapsed; open first panel\n\t\t\tif ( !value && this.options.active === false ) {\n\t\t\t\tthis._activate( 0 );\n\t\t\t}\n\t\t}\n\n\t\tif ( key === "event" ) {\n\t\t\tthis._setupEvents( value );\n\t\t}\n\n\t\tif ( key === "heightStyle" ) {\n\t\t\tthis._setupHeightStyle( value );\n\t\t}\n\t},\n\n\t_sanitizeSelector: function( hash ) {\n\t\treturn hash ? hash.replace( /[!"$%&\'()*+,.\\/:;<=>?@\\[\\]\\^`{|}~]/g, "\\\\$&" ) : "";\n\t},\n\n\trefresh: function() {\n\t\tvar options = this.options,\n\t\t\tlis = this.tablist.children( ":has(a[href])" );\n\n\t\t// Get disabled tabs from class attribute from HTML\n\t\t// this will get converted to a boolean if needed in _refresh()\n\t\toptions.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {\n\t\t\treturn lis.index( tab );\n\t\t} );\n\n\t\tthis._processTabs();\n\n\t\t// Was collapsed or no tabs\n\t\tif ( options.active === false || !this.anchors.length ) {\n\t\t\toptions.active = false;\n\t\t\tthis.active = $();\n\n\t\t// was active, but active tab is gone\n\t\t} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {\n\n\t\t\t// all remaining tabs are disabled\n\t\t\tif ( this.tabs.length === options.disabled.length ) {\n\t\t\t\toptions.active = false;\n\t\t\t\tthis.active = $();\n\n\t\t\t// activate previous tab\n\t\t\t} else {\n\t\t\t\tthis._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );\n\t\t\t}\n\n\t\t// was active, active tab still exists\n\t\t} else {\n\n\t\t\t// make sure active index is correct\n\t\t\toptions.active = this.tabs.index( this.active );\n\t\t}\n\n\t\tthis._refresh();\n\t},\n\n\t_refresh: function() {\n\t\tthis._setOptionDisabled( this.options.disabled );\n\t\tthis._setupEvents( this.options.event );\n\t\tthis._setupHeightStyle( this.options.heightStyle );\n\n\t\tthis.tabs.not( this.active ).attr( {\n\t\t\t"aria-selected": "false",\n\t\t\t"aria-expanded": "false",\n\t\t\ttabIndex: -1\n\t\t} );\n\t\tthis.panels.not( this._getPanelForTab( this.active ) )\n\t\t\t.hide()\n\t\t\t.attr( {\n\t\t\t\t"aria-hidden": "true"\n\t\t\t} );\n\n\t\t// Make sure one tab is in the tab order\n\t\tif ( !this.active.length ) {\n\t\t\tthis.tabs.eq( 0 ).attr( "tabIndex", 0 );\n\t\t} else {\n\t\t\tthis.active\n\t\t\t\t.attr( {\n\t\t\t\t\t"aria-selected": "true",\n\t\t\t\t\t"aria-expanded": "true",\n\t\t\t\t\ttabIndex: 0\n\t\t\t\t} );\n\t\t\tthis._addClass( this.active, "ui-tabs-active", "ui-state-active" );\n\t\t\tthis._getPanelForTab( this.active )\n\t\t\t\t.show()\n\t\t\t\t.attr( {\n\t\t\t\t\t"aria-hidden": "false"\n\t\t\t\t} );\n\t\t}\n\t},\n\n\t_processTabs: function() {\n\t\tvar that = this,\n\t\t\tprevTabs = this.tabs,\n\t\t\tprevAnchors = this.anchors,\n\t\t\tprevPanels = this.panels;\n\n\t\tthis.tablist = this._getList().attr( "role", "tablist" );\n\t\tthis._addClass( this.tablist, "ui-tabs-nav",\n\t\t\t"ui-helper-reset ui-helper-clearfix ui-widget-header" );\n\n\t\t// Prevent users from focusing disabled tabs via click\n\t\tthis.tablist\n\t\t\t.on( "mousedown" + this.eventNamespace, "> li", function( event ) {\n\t\t\t\tif ( $( this ).is( ".ui-state-disabled" ) ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t} )\n\n\t\t\t// Support: IE <9\n\t\t\t// Preventing the default action in mousedown doesn\'t prevent IE\n\t\t\t// from focusing the element, so if the anchor gets focused, blur.\n\t\t\t// We don\'t have to worry about focusing the previously focused\n\t\t\t// element since clicking on a non-focusable element should focus\n\t\t\t// the body anyway.\n\t\t\t.on( "focus" + this.eventNamespace, ".ui-tabs-anchor", function() {\n\t\t\t\tif ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t}\n\t\t\t} );\n\n\t\tthis.tabs = this.tablist.find( "> li:has(a[href])" )\n\t\t\t.attr( {\n\t\t\t\trole: "tab",\n\t\t\t\ttabIndex: -1\n\t\t\t} );\n\t\tthis._addClass( this.tabs, "ui-tabs-tab", "ui-state-default" );\n\n\t\tthis.anchors = this.tabs.map( function() {\n\t\t\treturn $( "a", this )[ 0 ];\n\t\t} )\n\t\t\t.attr( {\n\t\t\t\ttabIndex: -1\n\t\t\t} );\n\t\tthis._addClass( this.anchors, "ui-tabs-anchor" );\n\n\t\tthis.panels = $();\n\n\t\tthis.anchors.each( function( i, anchor ) {\n\t\t\tvar selector, panel, panelId,\n\t\t\t\tanchorId = $( anchor ).uniqueId().attr( "id" ),\n\t\t\t\ttab = $( anchor ).closest( "li" ),\n\t\t\t\toriginalAriaControls = tab.attr( "aria-controls" );\n\n\t\t\t// Inline tab\n\t\t\tif ( that._isLocal( anchor ) ) {\n\t\t\t\tselector = anchor.hash;\n\t\t\t\tpanelId = selector.substring( 1 );\n\t\t\t\tpanel = that.element.find( that._sanitizeSelector( selector ) );\n\n\t\t\t// remote tab\n\t\t\t} else {\n\n\t\t\t\t// If the tab doesn\'t already have aria-controls,\n\t\t\t\t// generate an id by using a throw-away element\n\t\t\t\tpanelId = tab.attr( "aria-controls" ) || $( {} ).uniqueId()[ 0 ].id;\n\t\t\t\tselector = "#" + panelId;\n\t\t\t\tpanel = that.element.find( selector );\n\t\t\t\tif ( !panel.length ) {\n\t\t\t\t\tpanel = that._createPanel( panelId );\n\t\t\t\t\tpanel.insertAfter( that.panels[ i - 1 ] || that.tablist );\n\t\t\t\t}\n\t\t\t\tpanel.attr( "aria-live", "polite" );\n\t\t\t}\n\n\t\t\tif ( panel.length ) {\n\t\t\t\tthat.panels = that.panels.add( panel );\n\t\t\t}\n\t\t\tif ( originalAriaControls ) {\n\t\t\t\ttab.data( "ui-tabs-aria-controls", originalAriaControls );\n\t\t\t}\n\t\t\ttab.attr( {\n\t\t\t\t"aria-controls": panelId,\n\t\t\t\t"aria-labelledby": anchorId\n\t\t\t} );\n\t\t\tpanel.attr( "aria-labelledby", anchorId );\n\t\t} );\n\n\t\tthis.panels.attr( "role", "tabpanel" );\n\t\tthis._addClass( this.panels, "ui-tabs-panel", "ui-widget-content" );\n\n\t\t// Avoid memory leaks (#10056)\n\t\tif ( prevTabs ) {\n\t\t\tthis._off( prevTabs.not( this.tabs ) );\n\t\t\tthis._off( prevAnchors.not( this.anchors ) );\n\t\t\tthis._off( prevPanels.not( this.panels ) );\n\t\t}\n\t},\n\n\t// Allow overriding how to find the list for rare usage scenarios (#7715)\n\t_getList: function() {\n\t\treturn this.tablist || this.element.find( "ol, ul" ).eq( 0 );\n\t},\n\n\t_createPanel: function( id ) {\n\t\treturn $( "<div>" )\n\t\t\t.attr( "id", id )\n\t\t\t.data( "ui-tabs-destroy", true );\n\t},\n\n\t_setOptionDisabled: function( disabled ) {\n\t\tvar currentItem, li, i;\n\n\t\tif ( Array.isArray( disabled ) ) {\n\t\t\tif ( !disabled.length ) {\n\t\t\t\tdisabled = false;\n\t\t\t} else if ( disabled.length === this.anchors.length ) {\n\t\t\t\tdisabled = true;\n\t\t\t}\n\t\t}\n\n\t\t// Disable tabs\n\t\tfor ( i = 0; ( li = this.tabs[ i ] ); i++ ) {\n\t\t\tcurrentItem = $( li );\n\t\t\tif ( disabled === true || $.inArray( i, disabled ) !== -1 ) {\n\t\t\t\tcurrentItem.attr( "aria-disabled", "true" );\n\t\t\t\tthis._addClass( currentItem, null, "ui-state-disabled" );\n\t\t\t} else {\n\t\t\t\tcurrentItem.removeAttr( "aria-disabled" );\n\t\t\t\tthis._removeClass( currentItem, null, "ui-state-disabled" );\n\t\t\t}\n\t\t}\n\n\t\tthis.options.disabled = disabled;\n\n\t\tthis._toggleClass( this.widget(), this.widgetFullName + "-disabled", null,\n\t\t\tdisabled === true );\n\t},\n\n\t_setupEvents: function( event ) {\n\t\tvar events = {};\n\t\tif ( event ) {\n\t\t\t$.each( event.split( " " ), function( index, eventName ) {\n\t\t\t\tevents[ eventName ] = "_eventHandler";\n\t\t\t} );\n\t\t}\n\n\t\tthis._off( this.anchors.add( this.tabs ).add( this.panels ) );\n\n\t\t// Always prevent the default action, even when disabled\n\t\tthis._on( true, this.anchors, {\n\t\t\tclick: function( event ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t} );\n\t\tthis._on( this.anchors, events );\n\t\tthis._on( this.tabs, { keydown: "_tabKeydown" } );\n\t\tthis._on( this.panels, { keydown: "_panelKeydown" } );\n\n\t\tthis._focusable( this.tabs );\n\t\tthis._hoverable( this.tabs );\n\t},\n\n\t_setupHeightStyle: function( heightStyle ) {\n\t\tvar maxHeight,\n\t\t\tparent = this.element.parent();\n\n\t\tif ( heightStyle === "fill" ) {\n\t\t\tmaxHeight = parent.height();\n\t\t\tmaxHeight -= this.element.outerHeight() - this.element.height();\n\n\t\t\tthis.element.siblings( ":visible" ).each( function() {\n\t\t\t\tvar elem = $( this ),\n\t\t\t\t\tposition = elem.css( "position" );\n\n\t\t\t\tif ( position === "absolute" || position === "fixed" ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmaxHeight -= elem.outerHeight( true );\n\t\t\t} );\n\n\t\t\tthis.element.children().not( this.panels ).each( function() {\n\t\t\t\tmaxHeight -= $( this ).outerHeight( true );\n\t\t\t} );\n\n\t\t\tthis.panels.each( function() {\n\t\t\t\t$( this ).height( Math.max( 0, maxHeight -\n\t\t\t\t\t$( this ).innerHeight() + $( this ).height() ) );\n\t\t\t} )\n\t\t\t\t.css( "overflow", "auto" );\n\t\t} else if ( heightStyle === "auto" ) {\n\t\t\tmaxHeight = 0;\n\t\t\tthis.panels.each( function() {\n\t\t\t\tmaxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );\n\t\t\t} ).height( maxHeight );\n\t\t}\n\t},\n\n\t_eventHandler: function( event ) {\n\t\tvar options = this.options,\n\t\t\tactive = this.active,\n\t\t\tanchor = $( event.currentTarget ),\n\t\t\ttab = anchor.closest( "li" ),\n\t\t\tclickedIsActive = tab[ 0 ] === active[ 0 ],\n\t\t\tcollapsing = clickedIsActive && options.collapsible,\n\t\t\ttoShow = collapsing ? $() : this._getPanelForTab( tab ),\n\t\t\ttoHide = !active.length ? $() : this._getPanelForTab( active ),\n\t\t\teventData = {\n\t\t\t\toldTab: active,\n\t\t\t\toldPanel: toHide,\n\t\t\t\tnewTab: collapsing ? $() : tab,\n\t\t\t\tnewPanel: toShow\n\t\t\t};\n\n\t\tevent.preventDefault();\n\n\t\tif ( tab.hasClass( "ui-state-disabled" ) ||\n\n\t\t\t\t// tab is already loading\n\t\t\t\ttab.hasClass( "ui-tabs-loading" ) ||\n\n\t\t\t\t// can\'t switch durning an animation\n\t\t\t\tthis.running ||\n\n\t\t\t\t// click on active header, but not collapsible\n\t\t\t\t( clickedIsActive && !options.collapsible ) ||\n\n\t\t\t\t// allow canceling activation\n\t\t\t\t( this._trigger( "beforeActivate", event, eventData ) === false ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\toptions.active = collapsing ? false : this.tabs.index( tab );\n\n\t\tthis.active = clickedIsActive ? $() : tab;\n\t\tif ( this.xhr ) {\n\t\t\tthis.xhr.abort();\n\t\t}\n\n\t\tif ( !toHide.length && !toShow.length ) {\n\t\t\t$.error( "jQuery UI Tabs: Mismatching fragment identifier." );\n\t\t}\n\n\t\tif ( toShow.length ) {\n\t\t\tthis.load( this.tabs.index( tab ), event );\n\t\t}\n\t\tthis._toggle( event, eventData );\n\t},\n\n\t// Handles show/hide for selecting tabs\n\t_toggle: function( event, eventData ) {\n\t\tvar that = this,\n\t\t\ttoShow = eventData.newPanel,\n\t\t\ttoHide = eventData.oldPanel;\n\n\t\tthis.running = true;\n\n\t\tfunction complete() {\n\t\t\tthat.running = false;\n\t\t\tthat._trigger( "activate", event, eventData );\n\t\t}\n\n\t\tfunction show() {\n\t\t\tthat._addClass( eventData.newTab.closest( "li" ), "ui-tabs-active", "ui-state-active" );\n\n\t\t\tif ( toShow.length && that.options.show ) {\n\t\t\t\tthat._show( toShow, that.options.show, complete );\n\t\t\t} else {\n\t\t\t\ttoShow.show();\n\t\t\t\tcomplete();\n\t\t\t}\n\t\t}\n\n\t\t// Start out by hiding, then showing, then completing\n\t\tif ( toHide.length && this.options.hide ) {\n\t\t\tthis._hide( toHide, this.options.hide, function() {\n\t\t\t\tthat._removeClass( eventData.oldTab.closest( "li" ),\n\t\t\t\t\t"ui-tabs-active", "ui-state-active" );\n\t\t\t\tshow();\n\t\t\t} );\n\t\t} else {\n\t\t\tthis._removeClass( eventData.oldTab.closest( "li" ),\n\t\t\t\t"ui-tabs-active", "ui-state-active" );\n\t\t\ttoHide.hide();\n\t\t\tshow();\n\t\t}\n\n\t\ttoHide.attr( "aria-hidden", "true" );\n\t\teventData.oldTab.attr( {\n\t\t\t"aria-selected": "false",\n\t\t\t"aria-expanded": "false"\n\t\t} );\n\n\t\t// If we\'re switching tabs, remove the old tab from the tab order.\n\t\t// If we\'re opening from collapsed state, remove the previous tab from the tab order.\n\t\t// If we\'re collapsing, then keep the collapsing tab in the tab order.\n\t\tif ( toShow.length && toHide.length ) {\n\t\t\teventData.oldTab.attr( "tabIndex", -1 );\n\t\t} else if ( toShow.length ) {\n\t\t\tthis.tabs.filter( function() {\n\t\t\t\treturn $( this ).attr( "tabIndex" ) === 0;\n\t\t\t} )\n\t\t\t\t.attr( "tabIndex", -1 );\n\t\t}\n\n\t\ttoShow.attr( "aria-hidden", "false" );\n\t\teventData.newTab.attr( {\n\t\t\t"aria-selected": "true",\n\t\t\t"aria-expanded": "true",\n\t\t\ttabIndex: 0\n\t\t} );\n\t},\n\n\t_activate: function( index ) {\n\t\tvar anchor,\n\t\t\tactive = this._findActive( index );\n\n\t\t// Trying to activate the already active panel\n\t\tif ( active[ 0 ] === this.active[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Trying to collapse, simulate a click on the current active header\n\t\tif ( !active.length ) {\n\t\t\tactive = this.active;\n\t\t}\n\n\t\tanchor = active.find( ".ui-tabs-anchor" )[ 0 ];\n\t\tthis._eventHandler( {\n\t\t\ttarget: anchor,\n\t\t\tcurrentTarget: anchor,\n\t\t\tpreventDefault: $.noop\n\t\t} );\n\t},\n\n\t_findActive: function( index ) {\n\t\treturn index === false ? $() : this.tabs.eq( index );\n\t},\n\n\t_getIndex: function( index ) {\n\n\t\t// meta-function to give users option to provide a href string instead of a numerical index.\n\t\tif ( typeof index === "string" ) {\n\t\t\tindex = this.anchors.index( this.anchors.filter( "[href$=\'" +\n\t\t\t\t$.escapeSelector( index ) + "\']" ) );\n\t\t}\n\n\t\treturn index;\n\t},\n\n\t_destroy: function() {\n\t\tif ( this.xhr ) {\n\t\t\tthis.xhr.abort();\n\t\t}\n\n\t\tthis.tablist\n\t\t\t.removeAttr( "role" )\n\t\t\t.off( this.eventNamespace );\n\n\t\tthis.anchors\n\t\t\t.removeAttr( "role tabIndex" )\n\t\t\t.removeUniqueId();\n\n\t\tthis.tabs.add( this.panels ).each( function() {\n\t\t\tif ( $.data( this, "ui-tabs-destroy" ) ) {\n\t\t\t\t$( this ).remove();\n\t\t\t} else {\n\t\t\t\t$( this ).removeAttr( "role tabIndex " +\n\t\t\t\t\t"aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded" );\n\t\t\t}\n\t\t} );\n\n\t\tthis.tabs.each( function() {\n\t\t\tvar li = $( this ),\n\t\t\t\tprev = li.data( "ui-tabs-aria-controls" );\n\t\t\tif ( prev ) {\n\t\t\t\tli\n\t\t\t\t\t.attr( "aria-controls", prev )\n\t\t\t\t\t.removeData( "ui-tabs-aria-controls" );\n\t\t\t} else {\n\t\t\t\tli.removeAttr( "aria-controls" );\n\t\t\t}\n\t\t} );\n\n\t\tthis.panels.show();\n\n\t\tif ( this.options.heightStyle !== "content" ) {\n\t\t\tthis.panels.css( "height", "" );\n\t\t}\n\t},\n\n\tenable: function( index ) {\n\t\tvar disabled = this.options.disabled;\n\t\tif ( disabled === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( index === undefined ) {\n\t\t\tdisabled = false;\n\t\t} else {\n\t\t\tindex = this._getIndex( index );\n\t\t\tif ( Array.isArray( disabled ) ) {\n\t\t\t\tdisabled = $.map( disabled, function( num ) {\n\t\t\t\t\treturn num !== index ? num : null;\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\tdisabled = $.map( this.tabs, function( li, num ) {\n\t\t\t\t\treturn num !== index ? num : null;\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t\tthis._setOptionDisabled( disabled );\n\t},\n\n\tdisable: function( index ) {\n\t\tvar disabled = this.options.disabled;\n\t\tif ( disabled === true ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( index === undefined ) {\n\t\t\tdisabled = true;\n\t\t} else {\n\t\t\tindex = this._getIndex( index );\n\t\t\tif ( $.inArray( index, disabled ) !== -1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( Array.isArray( disabled ) ) {\n\t\t\t\tdisabled = $.merge( [ index ], disabled ).sort();\n\t\t\t} else {\n\t\t\t\tdisabled = [ index ];\n\t\t\t}\n\t\t}\n\t\tthis._setOptionDisabled( disabled );\n\t},\n\n\tload: function( index, event ) {\n\t\tindex = this._getIndex( index );\n\t\tvar that = this,\n\t\t\ttab = this.tabs.eq( index ),\n\t\t\tanchor = tab.find( ".ui-tabs-anchor" ),\n\t\t\tpanel = this._getPanelForTab( tab ),\n\t\t\teventData = {\n\t\t\t\ttab: tab,\n\t\t\t\tpanel: panel\n\t\t\t},\n\t\t\tcomplete = function( jqXHR, status ) {\n\t\t\t\tif ( status === "abort" ) {\n\t\t\t\t\tthat.panels.stop( false, true );\n\t\t\t\t}\n\n\t\t\t\tthat._removeClass( tab, "ui-tabs-loading" );\n\t\t\t\tpanel.removeAttr( "aria-busy" );\n\n\t\t\t\tif ( jqXHR === that.xhr ) {\n\t\t\t\t\tdelete that.xhr;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Not remote\n\t\tif ( this._isLocal( anchor[ 0 ] ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );\n\n\t\t// Support: jQuery <1.8\n\t\t// jQuery <1.8 returns false if the request is canceled in beforeSend,\n\t\t// but as of 1.8, $.ajax() always returns a jqXHR object.\n\t\tif ( this.xhr && this.xhr.statusText !== "canceled" ) {\n\t\t\tthis._addClass( tab, "ui-tabs-loading" );\n\t\t\tpanel.attr( "aria-busy", "true" );\n\n\t\t\tthis.xhr\n\t\t\t\t.done( function( response, status, jqXHR ) {\n\n\t\t\t\t\t// support: jQuery <1.8\n\t\t\t\t\t// http://bugs.jquery.com/ticket/11778\n\t\t\t\t\tsetTimeout( function() {\n\t\t\t\t\t\tpanel.html( response );\n\t\t\t\t\t\tthat._trigger( "load", event, eventData );\n\n\t\t\t\t\t\tcomplete( jqXHR, status );\n\t\t\t\t\t}, 1 );\n\t\t\t\t} )\n\t\t\t\t.fail( function( jqXHR, status ) {\n\n\t\t\t\t\t// support: jQuery <1.8\n\t\t\t\t\t// http://bugs.jquery.com/ticket/11778\n\t\t\t\t\tsetTimeout( function() {\n\t\t\t\t\t\tcomplete( jqXHR, status );\n\t\t\t\t\t}, 1 );\n\t\t\t\t} );\n\t\t}\n\t},\n\n\t_ajaxSettings: function( anchor, event, eventData ) {\n\t\tvar that = this;\n\t\treturn {\n\n\t\t\t// Support: IE <11 only\n\t\t\t// Strip any hash that exists to prevent errors with the Ajax request\n\t\t\turl: anchor.attr( "href" ).replace( /#.*$/, "" ),\n\t\t\tbeforeSend: function( jqXHR, settings ) {\n\t\t\t\treturn that._trigger( "beforeLoad", event,\n\t\t\t\t\t$.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );\n\t\t\t}\n\t\t};\n\t},\n\n\t_getPanelForTab: function( tab ) {\n\t\tvar id = $( tab ).attr( "aria-controls" );\n\t\treturn this.element.find( this._sanitizeSelector( "#" + id ) );\n\t}\n} );\n\n// DEPRECATED\n// TODO: Switch return back to widget declaration at top of file when this is removed\nif ( $.uiBackCompat !== false ) {\n\n\t// Backcompat for ui-tab class (now ui-tabs-tab)\n\t$.widget( "ui.tabs", $.ui.tabs, {\n\t\t_processTabs: function() {\n\t\t\tthis._superApply( arguments );\n\t\t\tthis._addClass( this.tabs, "ui-tab" );\n\t\t}\n\t} );\n}\n\nreturn $.ui.tabs;\n\n} );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS93aWRnZXRzL3RhYnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS93aWRnZXRzL3RhYnMuanM/ZjljYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBVSSBUYWJzIDEuMTMuMlxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBUYWJzXG4vLz4+Z3JvdXA6IFdpZGdldHNcbi8vPj5kZXNjcmlwdGlvbjogVHJhbnNmb3JtcyBhIHNldCBvZiBjb250YWluZXIgZWxlbWVudHMgaW50byBhIHRhYiBzdHJ1Y3R1cmUuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vdGFicy9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS90YWJzL1xuLy8+PmNzcy5zdHJ1Y3R1cmU6IC4uLy4uL3RoZW1lcy9iYXNlL2NvcmUuY3NzXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2UvdGFicy5jc3Ncbi8vPj5jc3MudGhlbWU6IC4uLy4uL3RoZW1lcy9iYXNlL3RoZW1lLmNzc1xuXG4oIGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZSggW1xuXHRcdFx0XCJqcXVlcnlcIixcblx0XHRcdFwiLi4va2V5Y29kZVwiLFxuXHRcdFx0XCIuLi9zYWZlLWFjdGl2ZS1lbGVtZW50XCIsXG5cdFx0XHRcIi4uL3VuaXF1ZS1pZFwiLFxuXHRcdFx0XCIuLi92ZXJzaW9uXCIsXG5cdFx0XHRcIi4uL3dpZGdldFwiXG5cdFx0XSwgZmFjdG9yeSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeSggalF1ZXJ5ICk7XG5cdH1cbn0gKSggZnVuY3Rpb24oICQgKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuJC53aWRnZXQoIFwidWkudGFic1wiLCB7XG5cdHZlcnNpb246IFwiMS4xMy4yXCIsXG5cdGRlbGF5OiAzMDAsXG5cdG9wdGlvbnM6IHtcblx0XHRhY3RpdmU6IG51bGwsXG5cdFx0Y2xhc3Nlczoge1xuXHRcdFx0XCJ1aS10YWJzXCI6IFwidWktY29ybmVyLWFsbFwiLFxuXHRcdFx0XCJ1aS10YWJzLW5hdlwiOiBcInVpLWNvcm5lci1hbGxcIixcblx0XHRcdFwidWktdGFicy1wYW5lbFwiOiBcInVpLWNvcm5lci1ib3R0b21cIixcblx0XHRcdFwidWktdGFicy10YWJcIjogXCJ1aS1jb3JuZXItdG9wXCJcblx0XHR9LFxuXHRcdGNvbGxhcHNpYmxlOiBmYWxzZSxcblx0XHRldmVudDogXCJjbGlja1wiLFxuXHRcdGhlaWdodFN0eWxlOiBcImNvbnRlbnRcIixcblx0XHRoaWRlOiBudWxsLFxuXHRcdHNob3c6IG51bGwsXG5cblx0XHQvLyBDYWxsYmFja3Ncblx0XHRhY3RpdmF0ZTogbnVsbCxcblx0XHRiZWZvcmVBY3RpdmF0ZTogbnVsbCxcblx0XHRiZWZvcmVMb2FkOiBudWxsLFxuXHRcdGxvYWQ6IG51bGxcblx0fSxcblxuXHRfaXNMb2NhbDogKCBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmhhc2ggPSAvIy4qJC87XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGFuY2hvciApIHtcblx0XHRcdHZhciBhbmNob3JVcmwsIGxvY2F0aW9uVXJsO1xuXG5cdFx0XHRhbmNob3JVcmwgPSBhbmNob3IuaHJlZi5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXHRcdFx0bG9jYXRpb25VcmwgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHRcdC8vIERlY29kaW5nIG1heSB0aHJvdyBhbiBlcnJvciBpZiB0aGUgVVJMIGlzbid0IFVURi04ICgjOTUxOClcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGFuY2hvclVybCA9IGRlY29kZVVSSUNvbXBvbmVudCggYW5jaG9yVXJsICk7XG5cdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7fVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bG9jYXRpb25VcmwgPSBkZWNvZGVVUklDb21wb25lbnQoIGxvY2F0aW9uVXJsICk7XG5cdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7fVxuXG5cdFx0XHRyZXR1cm4gYW5jaG9yLmhhc2gubGVuZ3RoID4gMSAmJiBhbmNob3JVcmwgPT09IGxvY2F0aW9uVXJsO1xuXHRcdH07XG5cdH0gKSgpLFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuX2FkZENsYXNzKCBcInVpLXRhYnNcIiwgXCJ1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnRcIiApO1xuXHRcdHRoaXMuX3RvZ2dsZUNsYXNzKCBcInVpLXRhYnMtY29sbGFwc2libGVcIiwgbnVsbCwgb3B0aW9ucy5jb2xsYXBzaWJsZSApO1xuXG5cdFx0dGhpcy5fcHJvY2Vzc1RhYnMoKTtcblx0XHRvcHRpb25zLmFjdGl2ZSA9IHRoaXMuX2luaXRpYWxBY3RpdmUoKTtcblxuXHRcdC8vIFRha2UgZGlzYWJsaW5nIHRhYnMgdmlhIGNsYXNzIGF0dHJpYnV0ZSBmcm9tIEhUTUxcblx0XHQvLyBpbnRvIGFjY291bnQgYW5kIHVwZGF0ZSBvcHRpb24gcHJvcGVybHkuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBvcHRpb25zLmRpc2FibGVkICkgKSB7XG5cdFx0XHRvcHRpb25zLmRpc2FibGVkID0gJC51bmlxdWVTb3J0KCBvcHRpb25zLmRpc2FibGVkLmNvbmNhdChcblx0XHRcdFx0JC5tYXAoIHRoaXMudGFicy5maWx0ZXIoIFwiLnVpLXN0YXRlLWRpc2FibGVkXCIgKSwgZnVuY3Rpb24oIGxpICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGF0LnRhYnMuaW5kZXgoIGxpICk7XG5cdFx0XHRcdH0gKVxuXHRcdFx0KSApLnNvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3IgbGVuZ3RoIGF2b2lkcyBlcnJvciB3aGVuIGluaXRpYWxpemluZyBlbXB0eSBsaXN0XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuYWN0aXZlICE9PSBmYWxzZSAmJiB0aGlzLmFuY2hvcnMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5hY3RpdmUgPSB0aGlzLl9maW5kQWN0aXZlKCBvcHRpb25zLmFjdGl2ZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFjdGl2ZSA9ICQoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cblx0XHRpZiAoIHRoaXMuYWN0aXZlLmxlbmd0aCApIHtcblx0XHRcdHRoaXMubG9hZCggb3B0aW9ucy5hY3RpdmUgKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRpYWxBY3RpdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhY3RpdmUgPSB0aGlzLm9wdGlvbnMuYWN0aXZlLFxuXHRcdFx0Y29sbGFwc2libGUgPSB0aGlzLm9wdGlvbnMuY29sbGFwc2libGUsXG5cdFx0XHRsb2NhdGlvbkhhc2ggPSBsb2NhdGlvbi5oYXNoLnN1YnN0cmluZyggMSApO1xuXG5cdFx0aWYgKCBhY3RpdmUgPT09IG51bGwgKSB7XG5cblx0XHRcdC8vIGNoZWNrIHRoZSBmcmFnbWVudCBpZGVudGlmaWVyIGluIHRoZSBVUkxcblx0XHRcdGlmICggbG9jYXRpb25IYXNoICkge1xuXHRcdFx0XHR0aGlzLnRhYnMuZWFjaCggZnVuY3Rpb24oIGksIHRhYiApIHtcblx0XHRcdFx0XHRpZiAoICQoIHRhYiApLmF0dHIoIFwiYXJpYS1jb250cm9sc1wiICkgPT09IGxvY2F0aW9uSGFzaCApIHtcblx0XHRcdFx0XHRcdGFjdGl2ZSA9IGk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGZvciBhIHRhYiBtYXJrZWQgYWN0aXZlIHZpYSBhIGNsYXNzXG5cdFx0XHRpZiAoIGFjdGl2ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0YWN0aXZlID0gdGhpcy50YWJzLmluZGV4KCB0aGlzLnRhYnMuZmlsdGVyKCBcIi51aS10YWJzLWFjdGl2ZVwiICkgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gYWN0aXZlIHRhYiwgc2V0IHRvIGZhbHNlXG5cdFx0XHRpZiAoIGFjdGl2ZSA9PT0gbnVsbCB8fCBhY3RpdmUgPT09IC0xICkge1xuXHRcdFx0XHRhY3RpdmUgPSB0aGlzLnRhYnMubGVuZ3RoID8gMCA6IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBudW1iZXJzOiBuZWdhdGl2ZSwgb3V0IG9mIHJhbmdlXG5cdFx0aWYgKCBhY3RpdmUgIT09IGZhbHNlICkge1xuXHRcdFx0YWN0aXZlID0gdGhpcy50YWJzLmluZGV4KCB0aGlzLnRhYnMuZXEoIGFjdGl2ZSApICk7XG5cdFx0XHRpZiAoIGFjdGl2ZSA9PT0gLTEgKSB7XG5cdFx0XHRcdGFjdGl2ZSA9IGNvbGxhcHNpYmxlID8gZmFsc2UgOiAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIERvbid0IGFsbG93IGNvbGxhcHNpYmxlOiBmYWxzZSBhbmQgYWN0aXZlOiBmYWxzZVxuXHRcdGlmICggIWNvbGxhcHNpYmxlICYmIGFjdGl2ZSA9PT0gZmFsc2UgJiYgdGhpcy5hbmNob3JzLmxlbmd0aCApIHtcblx0XHRcdGFjdGl2ZSA9IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjdGl2ZTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlRXZlbnREYXRhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dGFiOiB0aGlzLmFjdGl2ZSxcblx0XHRcdHBhbmVsOiAhdGhpcy5hY3RpdmUubGVuZ3RoID8gJCgpIDogdGhpcy5fZ2V0UGFuZWxGb3JUYWIoIHRoaXMuYWN0aXZlIClcblx0XHR9O1xuXHR9LFxuXG5cdF90YWJLZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGZvY3VzZWRUYWIgPSAkKCAkLnVpLnNhZmVBY3RpdmVFbGVtZW50KCB0aGlzLmRvY3VtZW50WyAwIF0gKSApLmNsb3Nlc3QoIFwibGlcIiApLFxuXHRcdFx0c2VsZWN0ZWRJbmRleCA9IHRoaXMudGFicy5pbmRleCggZm9jdXNlZFRhYiApLFxuXHRcdFx0Z29pbmdGb3J3YXJkID0gdHJ1ZTtcblxuXHRcdGlmICggdGhpcy5faGFuZGxlUGFnZU5hdiggZXZlbnQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLlJJR0hUOlxuXHRcdGNhc2UgJC51aS5rZXlDb2RlLkRPV046XG5cdFx0XHRzZWxlY3RlZEluZGV4Kys7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5VUDpcblx0XHRjYXNlICQudWkua2V5Q29kZS5MRUZUOlxuXHRcdFx0Z29pbmdGb3J3YXJkID0gZmFsc2U7XG5cdFx0XHRzZWxlY3RlZEluZGV4LS07XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5FTkQ6XG5cdFx0XHRzZWxlY3RlZEluZGV4ID0gdGhpcy5hbmNob3JzLmxlbmd0aCAtIDE7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5IT01FOlxuXHRcdFx0c2VsZWN0ZWRJbmRleCA9IDA7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5TUEFDRTpcblxuXHRcdFx0Ly8gQWN0aXZhdGUgb25seSwgbm8gY29sbGFwc2luZ1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5hY3RpdmF0aW5nICk7XG5cdFx0XHR0aGlzLl9hY3RpdmF0ZSggc2VsZWN0ZWRJbmRleCApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLkVOVEVSOlxuXG5cdFx0XHQvLyBUb2dnbGUgKGNhbmNlbCBkZWxheWVkIGFjdGl2YXRpb24sIGFsbG93IGNvbGxhcHNpbmcpXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLmFjdGl2YXRpbmcgKTtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBjb2xsYXBzZSBvciBhY3RpdmF0ZVxuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIHNlbGVjdGVkSW5kZXggPT09IHRoaXMub3B0aW9ucy5hY3RpdmUgPyBmYWxzZSA6IHNlbGVjdGVkSW5kZXggKTtcblx0XHRcdHJldHVybjtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZvY3VzIHRoZSBhcHByb3ByaWF0ZSB0YWIsIGJhc2VkIG9uIHdoaWNoIGtleSB3YXMgcHJlc3NlZFxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLmFjdGl2YXRpbmcgKTtcblx0XHRzZWxlY3RlZEluZGV4ID0gdGhpcy5fZm9jdXNOZXh0VGFiKCBzZWxlY3RlZEluZGV4LCBnb2luZ0ZvcndhcmQgKTtcblxuXHRcdC8vIE5hdmlnYXRpbmcgd2l0aCBjb250cm9sL2NvbW1hbmQga2V5IHdpbGwgcHJldmVudCBhdXRvbWF0aWMgYWN0aXZhdGlvblxuXHRcdGlmICggIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50Lm1ldGFLZXkgKSB7XG5cblx0XHRcdC8vIFVwZGF0ZSBhcmlhLXNlbGVjdGVkIGltbWVkaWF0ZWx5IHNvIHRoYXQgQVQgdGhpbmsgdGhlIHRhYiBpcyBhbHJlYWR5IHNlbGVjdGVkLlxuXHRcdFx0Ly8gT3RoZXJ3aXNlIEFUIG1heSBjb25mdXNlIHRoZSB1c2VyIGJ5IHN0YXRpbmcgdGhhdCB0aGV5IG5lZWQgdG8gYWN0aXZhdGUgdGhlIHRhYixcblx0XHRcdC8vIGJ1dCB0aGUgdGFiIHdpbGwgYWxyZWFkeSBiZSBhY3RpdmF0ZWQgYnkgdGhlIHRpbWUgdGhlIGFubm91bmNlbWVudCBmaW5pc2hlcy5cblx0XHRcdGZvY3VzZWRUYWIuYXR0ciggXCJhcmlhLXNlbGVjdGVkXCIsIFwiZmFsc2VcIiApO1xuXHRcdFx0dGhpcy50YWJzLmVxKCBzZWxlY3RlZEluZGV4ICkuYXR0ciggXCJhcmlhLXNlbGVjdGVkXCIsIFwidHJ1ZVwiICk7XG5cblx0XHRcdHRoaXMuYWN0aXZhdGluZyA9IHRoaXMuX2RlbGF5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5vcHRpb24oIFwiYWN0aXZlXCIsIHNlbGVjdGVkSW5kZXggKTtcblx0XHRcdH0sIHRoaXMuZGVsYXkgKTtcblx0XHR9XG5cdH0sXG5cblx0X3BhbmVsS2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggdGhpcy5faGFuZGxlUGFnZU5hdiggZXZlbnQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDdHJsK3VwIG1vdmVzIGZvY3VzIHRvIHRoZSBjdXJyZW50IHRhYlxuXHRcdGlmICggZXZlbnQuY3RybEtleSAmJiBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuVVAgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dGhpcy5hY3RpdmUudHJpZ2dlciggXCJmb2N1c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEFsdCtwYWdlIHVwL2Rvd24gbW92ZXMgZm9jdXMgdG8gdGhlIHByZXZpb3VzL25leHQgdGFiIChhbmQgYWN0aXZhdGVzKVxuXHRfaGFuZGxlUGFnZU5hdjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggZXZlbnQuYWx0S2V5ICYmIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5QQUdFX1VQICkge1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIHRoaXMuX2ZvY3VzTmV4dFRhYiggdGhpcy5vcHRpb25zLmFjdGl2ZSAtIDEsIGZhbHNlICkgKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRpZiAoIGV2ZW50LmFsdEtleSAmJiBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuUEFHRV9ET1dOICkge1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIHRoaXMuX2ZvY3VzTmV4dFRhYiggdGhpcy5vcHRpb25zLmFjdGl2ZSArIDEsIHRydWUgKSApO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdF9maW5kTmV4dFRhYjogZnVuY3Rpb24oIGluZGV4LCBnb2luZ0ZvcndhcmQgKSB7XG5cdFx0dmFyIGxhc3RUYWJJbmRleCA9IHRoaXMudGFicy5sZW5ndGggLSAxO1xuXG5cdFx0ZnVuY3Rpb24gY29uc3RyYWluKCkge1xuXHRcdFx0aWYgKCBpbmRleCA+IGxhc3RUYWJJbmRleCApIHtcblx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdGluZGV4ID0gbGFzdFRhYkluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGluZGV4O1xuXHRcdH1cblxuXHRcdHdoaWxlICggJC5pbkFycmF5KCBjb25zdHJhaW4oKSwgdGhpcy5vcHRpb25zLmRpc2FibGVkICkgIT09IC0xICkge1xuXHRcdFx0aW5kZXggPSBnb2luZ0ZvcndhcmQgPyBpbmRleCArIDEgOiBpbmRleCAtIDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9LFxuXG5cdF9mb2N1c05leHRUYWI6IGZ1bmN0aW9uKCBpbmRleCwgZ29pbmdGb3J3YXJkICkge1xuXHRcdGluZGV4ID0gdGhpcy5fZmluZE5leHRUYWIoIGluZGV4LCBnb2luZ0ZvcndhcmQgKTtcblx0XHR0aGlzLnRhYnMuZXEoIGluZGV4ICkudHJpZ2dlciggXCJmb2N1c1wiICk7XG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdGlmICgga2V5ID09PSBcImFjdGl2ZVwiICkge1xuXG5cdFx0XHQvLyBfYWN0aXZhdGUoKSB3aWxsIGhhbmRsZSBpbnZhbGlkIHZhbHVlcyBhbmQgdXBkYXRlIHRoaXMub3B0aW9uc1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIHZhbHVlICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblxuXHRcdGlmICgga2V5ID09PSBcImNvbGxhcHNpYmxlXCIgKSB7XG5cdFx0XHR0aGlzLl90b2dnbGVDbGFzcyggXCJ1aS10YWJzLWNvbGxhcHNpYmxlXCIsIG51bGwsIHZhbHVlICk7XG5cblx0XHRcdC8vIFNldHRpbmcgY29sbGFwc2libGU6IGZhbHNlIHdoaWxlIGNvbGxhcHNlZDsgb3BlbiBmaXJzdCBwYW5lbFxuXHRcdFx0aWYgKCAhdmFsdWUgJiYgdGhpcy5vcHRpb25zLmFjdGl2ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2YXRlKCAwICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwiZXZlbnRcIiApIHtcblx0XHRcdHRoaXMuX3NldHVwRXZlbnRzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ID09PSBcImhlaWdodFN0eWxlXCIgKSB7XG5cdFx0XHR0aGlzLl9zZXR1cEhlaWdodFN0eWxlKCB2YWx1ZSApO1xuXHRcdH1cblx0fSxcblxuXHRfc2FuaXRpemVTZWxlY3RvcjogZnVuY3Rpb24oIGhhc2ggKSB7XG5cdFx0cmV0dXJuIGhhc2ggPyBoYXNoLnJlcGxhY2UoIC9bIVwiJCUmJygpKissLlxcLzo7PD0+P0BcXFtcXF1cXF5ge3x9fl0vZywgXCJcXFxcJCZcIiApIDogXCJcIjtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGxpcyA9IHRoaXMudGFibGlzdC5jaGlsZHJlbiggXCI6aGFzKGFbaHJlZl0pXCIgKTtcblxuXHRcdC8vIEdldCBkaXNhYmxlZCB0YWJzIGZyb20gY2xhc3MgYXR0cmlidXRlIGZyb20gSFRNTFxuXHRcdC8vIHRoaXMgd2lsbCBnZXQgY29udmVydGVkIHRvIGEgYm9vbGVhbiBpZiBuZWVkZWQgaW4gX3JlZnJlc2goKVxuXHRcdG9wdGlvbnMuZGlzYWJsZWQgPSAkLm1hcCggbGlzLmZpbHRlciggXCIudWktc3RhdGUtZGlzYWJsZWRcIiApLCBmdW5jdGlvbiggdGFiICkge1xuXHRcdFx0cmV0dXJuIGxpcy5pbmRleCggdGFiICk7XG5cdFx0fSApO1xuXG5cdFx0dGhpcy5fcHJvY2Vzc1RhYnMoKTtcblxuXHRcdC8vIFdhcyBjb2xsYXBzZWQgb3Igbm8gdGFic1xuXHRcdGlmICggb3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlIHx8ICF0aGlzLmFuY2hvcnMubGVuZ3RoICkge1xuXHRcdFx0b3B0aW9ucy5hY3RpdmUgPSBmYWxzZTtcblx0XHRcdHRoaXMuYWN0aXZlID0gJCgpO1xuXG5cdFx0Ly8gd2FzIGFjdGl2ZSwgYnV0IGFjdGl2ZSB0YWIgaXMgZ29uZVxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuYWN0aXZlLmxlbmd0aCAmJiAhJC5jb250YWlucyggdGhpcy50YWJsaXN0WyAwIF0sIHRoaXMuYWN0aXZlWyAwIF0gKSApIHtcblxuXHRcdFx0Ly8gYWxsIHJlbWFpbmluZyB0YWJzIGFyZSBkaXNhYmxlZFxuXHRcdFx0aWYgKCB0aGlzLnRhYnMubGVuZ3RoID09PSBvcHRpb25zLmRpc2FibGVkLmxlbmd0aCApIHtcblx0XHRcdFx0b3B0aW9ucy5hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5hY3RpdmUgPSAkKCk7XG5cblx0XHRcdC8vIGFjdGl2YXRlIHByZXZpb3VzIHRhYlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZhdGUoIHRoaXMuX2ZpbmROZXh0VGFiKCBNYXRoLm1heCggMCwgb3B0aW9ucy5hY3RpdmUgLSAxICksIGZhbHNlICkgKTtcblx0XHRcdH1cblxuXHRcdC8vIHdhcyBhY3RpdmUsIGFjdGl2ZSB0YWIgc3RpbGwgZXhpc3RzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gbWFrZSBzdXJlIGFjdGl2ZSBpbmRleCBpcyBjb3JyZWN0XG5cdFx0XHRvcHRpb25zLmFjdGl2ZSA9IHRoaXMudGFicy5pbmRleCggdGhpcy5hY3RpdmUgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdH0sXG5cblx0X3JlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NldE9wdGlvbkRpc2FibGVkKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKTtcblx0XHR0aGlzLl9zZXR1cEV2ZW50cyggdGhpcy5vcHRpb25zLmV2ZW50ICk7XG5cdFx0dGhpcy5fc2V0dXBIZWlnaHRTdHlsZSggdGhpcy5vcHRpb25zLmhlaWdodFN0eWxlICk7XG5cblx0XHR0aGlzLnRhYnMubm90KCB0aGlzLmFjdGl2ZSApLmF0dHIoIHtcblx0XHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBcImZhbHNlXCIsXG5cdFx0XHRcImFyaWEtZXhwYW5kZWRcIjogXCJmYWxzZVwiLFxuXHRcdFx0dGFiSW5kZXg6IC0xXG5cdFx0fSApO1xuXHRcdHRoaXMucGFuZWxzLm5vdCggdGhpcy5fZ2V0UGFuZWxGb3JUYWIoIHRoaXMuYWN0aXZlICkgKVxuXHRcdFx0LmhpZGUoKVxuXHRcdFx0LmF0dHIoIHtcblx0XHRcdFx0XCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuXHRcdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIG9uZSB0YWIgaXMgaW4gdGhlIHRhYiBvcmRlclxuXHRcdGlmICggIXRoaXMuYWN0aXZlLmxlbmd0aCApIHtcblx0XHRcdHRoaXMudGFicy5lcSggMCApLmF0dHIoIFwidGFiSW5kZXhcIiwgMCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFjdGl2ZVxuXHRcdFx0XHQuYXR0cigge1xuXHRcdFx0XHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBcInRydWVcIixcblx0XHRcdFx0XHRcImFyaWEtZXhwYW5kZWRcIjogXCJ0cnVlXCIsXG5cdFx0XHRcdFx0dGFiSW5kZXg6IDBcblx0XHRcdFx0fSApO1xuXHRcdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMuYWN0aXZlLCBcInVpLXRhYnMtYWN0aXZlXCIsIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdHRoaXMuX2dldFBhbmVsRm9yVGFiKCB0aGlzLmFjdGl2ZSApXG5cdFx0XHRcdC5zaG93KClcblx0XHRcdFx0LmF0dHIoIHtcblx0XHRcdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwiZmFsc2VcIlxuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9wcm9jZXNzVGFiczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0cHJldlRhYnMgPSB0aGlzLnRhYnMsXG5cdFx0XHRwcmV2QW5jaG9ycyA9IHRoaXMuYW5jaG9ycyxcblx0XHRcdHByZXZQYW5lbHMgPSB0aGlzLnBhbmVscztcblxuXHRcdHRoaXMudGFibGlzdCA9IHRoaXMuX2dldExpc3QoKS5hdHRyKCBcInJvbGVcIiwgXCJ0YWJsaXN0XCIgKTtcblx0XHR0aGlzLl9hZGRDbGFzcyggdGhpcy50YWJsaXN0LCBcInVpLXRhYnMtbmF2XCIsXG5cdFx0XHRcInVpLWhlbHBlci1yZXNldCB1aS1oZWxwZXItY2xlYXJmaXggdWktd2lkZ2V0LWhlYWRlclwiICk7XG5cblx0XHQvLyBQcmV2ZW50IHVzZXJzIGZyb20gZm9jdXNpbmcgZGlzYWJsZWQgdGFicyB2aWEgY2xpY2tcblx0XHR0aGlzLnRhYmxpc3Rcblx0XHRcdC5vbiggXCJtb3VzZWRvd25cIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIFwiPiBsaVwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggJCggdGhpcyApLmlzKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5XG5cdFx0XHQvLyBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGFjdGlvbiBpbiBtb3VzZWRvd24gZG9lc24ndCBwcmV2ZW50IElFXG5cdFx0XHQvLyBmcm9tIGZvY3VzaW5nIHRoZSBlbGVtZW50LCBzbyBpZiB0aGUgYW5jaG9yIGdldHMgZm9jdXNlZCwgYmx1ci5cblx0XHRcdC8vIFdlIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgZm9jdXNpbmcgdGhlIHByZXZpb3VzbHkgZm9jdXNlZFxuXHRcdFx0Ly8gZWxlbWVudCBzaW5jZSBjbGlja2luZyBvbiBhIG5vbi1mb2N1c2FibGUgZWxlbWVudCBzaG91bGQgZm9jdXNcblx0XHRcdC8vIHRoZSBib2R5IGFueXdheS5cblx0XHRcdC5vbiggXCJmb2N1c1wiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgXCIudWktdGFicy1hbmNob3JcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggJCggdGhpcyApLmNsb3Nlc3QoIFwibGlcIiApLmlzKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblxuXHRcdHRoaXMudGFicyA9IHRoaXMudGFibGlzdC5maW5kKCBcIj4gbGk6aGFzKGFbaHJlZl0pXCIgKVxuXHRcdFx0LmF0dHIoIHtcblx0XHRcdFx0cm9sZTogXCJ0YWJcIixcblx0XHRcdFx0dGFiSW5kZXg6IC0xXG5cdFx0XHR9ICk7XG5cdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMudGFicywgXCJ1aS10YWJzLXRhYlwiLCBcInVpLXN0YXRlLWRlZmF1bHRcIiApO1xuXG5cdFx0dGhpcy5hbmNob3JzID0gdGhpcy50YWJzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gJCggXCJhXCIsIHRoaXMgKVsgMCBdO1xuXHRcdH0gKVxuXHRcdFx0LmF0dHIoIHtcblx0XHRcdFx0dGFiSW5kZXg6IC0xXG5cdFx0XHR9ICk7XG5cdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMuYW5jaG9ycywgXCJ1aS10YWJzLWFuY2hvclwiICk7XG5cblx0XHR0aGlzLnBhbmVscyA9ICQoKTtcblxuXHRcdHRoaXMuYW5jaG9ycy5lYWNoKCBmdW5jdGlvbiggaSwgYW5jaG9yICkge1xuXHRcdFx0dmFyIHNlbGVjdG9yLCBwYW5lbCwgcGFuZWxJZCxcblx0XHRcdFx0YW5jaG9ySWQgPSAkKCBhbmNob3IgKS51bmlxdWVJZCgpLmF0dHIoIFwiaWRcIiApLFxuXHRcdFx0XHR0YWIgPSAkKCBhbmNob3IgKS5jbG9zZXN0KCBcImxpXCIgKSxcblx0XHRcdFx0b3JpZ2luYWxBcmlhQ29udHJvbHMgPSB0YWIuYXR0ciggXCJhcmlhLWNvbnRyb2xzXCIgKTtcblxuXHRcdFx0Ly8gSW5saW5lIHRhYlxuXHRcdFx0aWYgKCB0aGF0Ll9pc0xvY2FsKCBhbmNob3IgKSApIHtcblx0XHRcdFx0c2VsZWN0b3IgPSBhbmNob3IuaGFzaDtcblx0XHRcdFx0cGFuZWxJZCA9IHNlbGVjdG9yLnN1YnN0cmluZyggMSApO1xuXHRcdFx0XHRwYW5lbCA9IHRoYXQuZWxlbWVudC5maW5kKCB0aGF0Ll9zYW5pdGl6ZVNlbGVjdG9yKCBzZWxlY3RvciApICk7XG5cblx0XHRcdC8vIHJlbW90ZSB0YWJcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIHRhYiBkb2Vzbid0IGFscmVhZHkgaGF2ZSBhcmlhLWNvbnRyb2xzLFxuXHRcdFx0XHQvLyBnZW5lcmF0ZSBhbiBpZCBieSB1c2luZyBhIHRocm93LWF3YXkgZWxlbWVudFxuXHRcdFx0XHRwYW5lbElkID0gdGFiLmF0dHIoIFwiYXJpYS1jb250cm9sc1wiICkgfHwgJCgge30gKS51bmlxdWVJZCgpWyAwIF0uaWQ7XG5cdFx0XHRcdHNlbGVjdG9yID0gXCIjXCIgKyBwYW5lbElkO1xuXHRcdFx0XHRwYW5lbCA9IHRoYXQuZWxlbWVudC5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0XHRpZiAoICFwYW5lbC5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cGFuZWwgPSB0aGF0Ll9jcmVhdGVQYW5lbCggcGFuZWxJZCApO1xuXHRcdFx0XHRcdHBhbmVsLmluc2VydEFmdGVyKCB0aGF0LnBhbmVsc1sgaSAtIDEgXSB8fCB0aGF0LnRhYmxpc3QgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYW5lbC5hdHRyKCBcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggcGFuZWwubGVuZ3RoICkge1xuXHRcdFx0XHR0aGF0LnBhbmVscyA9IHRoYXQucGFuZWxzLmFkZCggcGFuZWwgKTtcblx0XHRcdH1cblx0XHRcdGlmICggb3JpZ2luYWxBcmlhQ29udHJvbHMgKSB7XG5cdFx0XHRcdHRhYi5kYXRhKCBcInVpLXRhYnMtYXJpYS1jb250cm9sc1wiLCBvcmlnaW5hbEFyaWFDb250cm9scyApO1xuXHRcdFx0fVxuXHRcdFx0dGFiLmF0dHIoIHtcblx0XHRcdFx0XCJhcmlhLWNvbnRyb2xzXCI6IHBhbmVsSWQsXG5cdFx0XHRcdFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFuY2hvcklkXG5cdFx0XHR9ICk7XG5cdFx0XHRwYW5lbC5hdHRyKCBcImFyaWEtbGFiZWxsZWRieVwiLCBhbmNob3JJZCApO1xuXHRcdH0gKTtcblxuXHRcdHRoaXMucGFuZWxzLmF0dHIoIFwicm9sZVwiLCBcInRhYnBhbmVsXCIgKTtcblx0XHR0aGlzLl9hZGRDbGFzcyggdGhpcy5wYW5lbHMsIFwidWktdGFicy1wYW5lbFwiLCBcInVpLXdpZGdldC1jb250ZW50XCIgKTtcblxuXHRcdC8vIEF2b2lkIG1lbW9yeSBsZWFrcyAoIzEwMDU2KVxuXHRcdGlmICggcHJldlRhYnMgKSB7XG5cdFx0XHR0aGlzLl9vZmYoIHByZXZUYWJzLm5vdCggdGhpcy50YWJzICkgKTtcblx0XHRcdHRoaXMuX29mZiggcHJldkFuY2hvcnMubm90KCB0aGlzLmFuY2hvcnMgKSApO1xuXHRcdFx0dGhpcy5fb2ZmKCBwcmV2UGFuZWxzLm5vdCggdGhpcy5wYW5lbHMgKSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBBbGxvdyBvdmVycmlkaW5nIGhvdyB0byBmaW5kIHRoZSBsaXN0IGZvciByYXJlIHVzYWdlIHNjZW5hcmlvcyAoIzc3MTUpXG5cdF9nZXRMaXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50YWJsaXN0IHx8IHRoaXMuZWxlbWVudC5maW5kKCBcIm9sLCB1bFwiICkuZXEoIDAgKTtcblx0fSxcblxuXHRfY3JlYXRlUGFuZWw6IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRyZXR1cm4gJCggXCI8ZGl2PlwiIClcblx0XHRcdC5hdHRyKCBcImlkXCIsIGlkIClcblx0XHRcdC5kYXRhKCBcInVpLXRhYnMtZGVzdHJveVwiLCB0cnVlICk7XG5cdH0sXG5cblx0X3NldE9wdGlvbkRpc2FibGVkOiBmdW5jdGlvbiggZGlzYWJsZWQgKSB7XG5cdFx0dmFyIGN1cnJlbnRJdGVtLCBsaSwgaTtcblxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggZGlzYWJsZWQgKSApIHtcblx0XHRcdGlmICggIWRpc2FibGVkLmxlbmd0aCApIHtcblx0XHRcdFx0ZGlzYWJsZWQgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIGRpc2FibGVkLmxlbmd0aCA9PT0gdGhpcy5hbmNob3JzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIERpc2FibGUgdGFic1xuXHRcdGZvciAoIGkgPSAwOyAoIGxpID0gdGhpcy50YWJzWyBpIF0gKTsgaSsrICkge1xuXHRcdFx0Y3VycmVudEl0ZW0gPSAkKCBsaSApO1xuXHRcdFx0aWYgKCBkaXNhYmxlZCA9PT0gdHJ1ZSB8fCAkLmluQXJyYXkoIGksIGRpc2FibGVkICkgIT09IC0xICkge1xuXHRcdFx0XHRjdXJyZW50SXRlbS5hdHRyKCBcImFyaWEtZGlzYWJsZWRcIiwgXCJ0cnVlXCIgKTtcblx0XHRcdFx0dGhpcy5fYWRkQ2xhc3MoIGN1cnJlbnRJdGVtLCBudWxsLCBcInVpLXN0YXRlLWRpc2FibGVkXCIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1cnJlbnRJdGVtLnJlbW92ZUF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiICk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBjdXJyZW50SXRlbSwgbnVsbCwgXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5vcHRpb25zLmRpc2FibGVkID0gZGlzYWJsZWQ7XG5cblx0XHR0aGlzLl90b2dnbGVDbGFzcyggdGhpcy53aWRnZXQoKSwgdGhpcy53aWRnZXRGdWxsTmFtZSArIFwiLWRpc2FibGVkXCIsIG51bGwsXG5cdFx0XHRkaXNhYmxlZCA9PT0gdHJ1ZSApO1xuXHR9LFxuXG5cdF9zZXR1cEV2ZW50czogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBldmVudHMgPSB7fTtcblx0XHRpZiAoIGV2ZW50ICkge1xuXHRcdFx0JC5lYWNoKCBldmVudC5zcGxpdCggXCIgXCIgKSwgZnVuY3Rpb24oIGluZGV4LCBldmVudE5hbWUgKSB7XG5cdFx0XHRcdGV2ZW50c1sgZXZlbnROYW1lIF0gPSBcIl9ldmVudEhhbmRsZXJcIjtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR0aGlzLl9vZmYoIHRoaXMuYW5jaG9ycy5hZGQoIHRoaXMudGFicyApLmFkZCggdGhpcy5wYW5lbHMgKSApO1xuXG5cdFx0Ly8gQWx3YXlzIHByZXZlbnQgdGhlIGRlZmF1bHQgYWN0aW9uLCBldmVuIHdoZW4gZGlzYWJsZWRcblx0XHR0aGlzLl9vbiggdHJ1ZSwgdGhpcy5hbmNob3JzLCB7XG5cdFx0XHRjbGljazogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHR0aGlzLl9vbiggdGhpcy5hbmNob3JzLCBldmVudHMgKTtcblx0XHR0aGlzLl9vbiggdGhpcy50YWJzLCB7IGtleWRvd246IFwiX3RhYktleWRvd25cIiB9ICk7XG5cdFx0dGhpcy5fb24oIHRoaXMucGFuZWxzLCB7IGtleWRvd246IFwiX3BhbmVsS2V5ZG93blwiIH0gKTtcblxuXHRcdHRoaXMuX2ZvY3VzYWJsZSggdGhpcy50YWJzICk7XG5cdFx0dGhpcy5faG92ZXJhYmxlKCB0aGlzLnRhYnMgKTtcblx0fSxcblxuXHRfc2V0dXBIZWlnaHRTdHlsZTogZnVuY3Rpb24oIGhlaWdodFN0eWxlICkge1xuXHRcdHZhciBtYXhIZWlnaHQsXG5cdFx0XHRwYXJlbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50KCk7XG5cblx0XHRpZiAoIGhlaWdodFN0eWxlID09PSBcImZpbGxcIiApIHtcblx0XHRcdG1heEhlaWdodCA9IHBhcmVudC5oZWlnaHQoKTtcblx0XHRcdG1heEhlaWdodCAtPSB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKSAtIHRoaXMuZWxlbWVudC5oZWlnaHQoKTtcblxuXHRcdFx0dGhpcy5lbGVtZW50LnNpYmxpbmdzKCBcIjp2aXNpYmxlXCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSAkKCB0aGlzICksXG5cdFx0XHRcdFx0cG9zaXRpb24gPSBlbGVtLmNzcyggXCJwb3NpdGlvblwiICk7XG5cblx0XHRcdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1heEhlaWdodCAtPSBlbGVtLm91dGVySGVpZ2h0KCB0cnVlICk7XG5cdFx0XHR9ICk7XG5cblx0XHRcdHRoaXMuZWxlbWVudC5jaGlsZHJlbigpLm5vdCggdGhpcy5wYW5lbHMgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0bWF4SGVpZ2h0IC09ICQoIHRoaXMgKS5vdXRlckhlaWdodCggdHJ1ZSApO1xuXHRcdFx0fSApO1xuXG5cdFx0XHR0aGlzLnBhbmVscy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLmhlaWdodCggTWF0aC5tYXgoIDAsIG1heEhlaWdodCAtXG5cdFx0XHRcdFx0JCggdGhpcyApLmlubmVySGVpZ2h0KCkgKyAkKCB0aGlzICkuaGVpZ2h0KCkgKSApO1xuXHRcdFx0fSApXG5cdFx0XHRcdC5jc3MoIFwib3ZlcmZsb3dcIiwgXCJhdXRvXCIgKTtcblx0XHR9IGVsc2UgaWYgKCBoZWlnaHRTdHlsZSA9PT0gXCJhdXRvXCIgKSB7XG5cdFx0XHRtYXhIZWlnaHQgPSAwO1xuXHRcdFx0dGhpcy5wYW5lbHMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdG1heEhlaWdodCA9IE1hdGgubWF4KCBtYXhIZWlnaHQsICQoIHRoaXMgKS5oZWlnaHQoIFwiXCIgKS5oZWlnaHQoKSApO1xuXHRcdFx0fSApLmhlaWdodCggbWF4SGVpZ2h0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9ldmVudEhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGFjdGl2ZSA9IHRoaXMuYWN0aXZlLFxuXHRcdFx0YW5jaG9yID0gJCggZXZlbnQuY3VycmVudFRhcmdldCApLFxuXHRcdFx0dGFiID0gYW5jaG9yLmNsb3Nlc3QoIFwibGlcIiApLFxuXHRcdFx0Y2xpY2tlZElzQWN0aXZlID0gdGFiWyAwIF0gPT09IGFjdGl2ZVsgMCBdLFxuXHRcdFx0Y29sbGFwc2luZyA9IGNsaWNrZWRJc0FjdGl2ZSAmJiBvcHRpb25zLmNvbGxhcHNpYmxlLFxuXHRcdFx0dG9TaG93ID0gY29sbGFwc2luZyA/ICQoKSA6IHRoaXMuX2dldFBhbmVsRm9yVGFiKCB0YWIgKSxcblx0XHRcdHRvSGlkZSA9ICFhY3RpdmUubGVuZ3RoID8gJCgpIDogdGhpcy5fZ2V0UGFuZWxGb3JUYWIoIGFjdGl2ZSApLFxuXHRcdFx0ZXZlbnREYXRhID0ge1xuXHRcdFx0XHRvbGRUYWI6IGFjdGl2ZSxcblx0XHRcdFx0b2xkUGFuZWw6IHRvSGlkZSxcblx0XHRcdFx0bmV3VGFiOiBjb2xsYXBzaW5nID8gJCgpIDogdGFiLFxuXHRcdFx0XHRuZXdQYW5lbDogdG9TaG93XG5cdFx0XHR9O1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdGlmICggdGFiLmhhc0NsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIgKSB8fFxuXG5cdFx0XHRcdC8vIHRhYiBpcyBhbHJlYWR5IGxvYWRpbmdcblx0XHRcdFx0dGFiLmhhc0NsYXNzKCBcInVpLXRhYnMtbG9hZGluZ1wiICkgfHxcblxuXHRcdFx0XHQvLyBjYW4ndCBzd2l0Y2ggZHVybmluZyBhbiBhbmltYXRpb25cblx0XHRcdFx0dGhpcy5ydW5uaW5nIHx8XG5cblx0XHRcdFx0Ly8gY2xpY2sgb24gYWN0aXZlIGhlYWRlciwgYnV0IG5vdCBjb2xsYXBzaWJsZVxuXHRcdFx0XHQoIGNsaWNrZWRJc0FjdGl2ZSAmJiAhb3B0aW9ucy5jb2xsYXBzaWJsZSApIHx8XG5cblx0XHRcdFx0Ly8gYWxsb3cgY2FuY2VsaW5nIGFjdGl2YXRpb25cblx0XHRcdFx0KCB0aGlzLl90cmlnZ2VyKCBcImJlZm9yZUFjdGl2YXRlXCIsIGV2ZW50LCBldmVudERhdGEgKSA9PT0gZmFsc2UgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRvcHRpb25zLmFjdGl2ZSA9IGNvbGxhcHNpbmcgPyBmYWxzZSA6IHRoaXMudGFicy5pbmRleCggdGFiICk7XG5cblx0XHR0aGlzLmFjdGl2ZSA9IGNsaWNrZWRJc0FjdGl2ZSA/ICQoKSA6IHRhYjtcblx0XHRpZiAoIHRoaXMueGhyICkge1xuXHRcdFx0dGhpcy54aHIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHRpZiAoICF0b0hpZGUubGVuZ3RoICYmICF0b1Nob3cubGVuZ3RoICkge1xuXHRcdFx0JC5lcnJvciggXCJqUXVlcnkgVUkgVGFiczogTWlzbWF0Y2hpbmcgZnJhZ21lbnQgaWRlbnRpZmllci5cIiApO1xuXHRcdH1cblxuXHRcdGlmICggdG9TaG93Lmxlbmd0aCApIHtcblx0XHRcdHRoaXMubG9hZCggdGhpcy50YWJzLmluZGV4KCB0YWIgKSwgZXZlbnQgKTtcblx0XHR9XG5cdFx0dGhpcy5fdG9nZ2xlKCBldmVudCwgZXZlbnREYXRhICk7XG5cdH0sXG5cblx0Ly8gSGFuZGxlcyBzaG93L2hpZGUgZm9yIHNlbGVjdGluZyB0YWJzXG5cdF90b2dnbGU6IGZ1bmN0aW9uKCBldmVudCwgZXZlbnREYXRhICkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdHRvU2hvdyA9IGV2ZW50RGF0YS5uZXdQYW5lbCxcblx0XHRcdHRvSGlkZSA9IGV2ZW50RGF0YS5vbGRQYW5lbDtcblxuXHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cblx0XHRmdW5jdGlvbiBjb21wbGV0ZSgpIHtcblx0XHRcdHRoYXQucnVubmluZyA9IGZhbHNlO1xuXHRcdFx0dGhhdC5fdHJpZ2dlciggXCJhY3RpdmF0ZVwiLCBldmVudCwgZXZlbnREYXRhICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2hvdygpIHtcblx0XHRcdHRoYXQuX2FkZENsYXNzKCBldmVudERhdGEubmV3VGFiLmNsb3Nlc3QoIFwibGlcIiApLCBcInVpLXRhYnMtYWN0aXZlXCIsIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblxuXHRcdFx0aWYgKCB0b1Nob3cubGVuZ3RoICYmIHRoYXQub3B0aW9ucy5zaG93ICkge1xuXHRcdFx0XHR0aGF0Ll9zaG93KCB0b1Nob3csIHRoYXQub3B0aW9ucy5zaG93LCBjb21wbGV0ZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG9TaG93LnNob3coKTtcblx0XHRcdFx0Y29tcGxldGUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdGFydCBvdXQgYnkgaGlkaW5nLCB0aGVuIHNob3dpbmcsIHRoZW4gY29tcGxldGluZ1xuXHRcdGlmICggdG9IaWRlLmxlbmd0aCAmJiB0aGlzLm9wdGlvbnMuaGlkZSApIHtcblx0XHRcdHRoaXMuX2hpZGUoIHRvSGlkZSwgdGhpcy5vcHRpb25zLmhpZGUsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGF0Ll9yZW1vdmVDbGFzcyggZXZlbnREYXRhLm9sZFRhYi5jbG9zZXN0KCBcImxpXCIgKSxcblx0XHRcdFx0XHRcInVpLXRhYnMtYWN0aXZlXCIsIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0c2hvdygpO1xuXHRcdFx0fSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggZXZlbnREYXRhLm9sZFRhYi5jbG9zZXN0KCBcImxpXCIgKSxcblx0XHRcdFx0XCJ1aS10YWJzLWFjdGl2ZVwiLCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHR0b0hpZGUuaGlkZSgpO1xuXHRcdFx0c2hvdygpO1xuXHRcdH1cblxuXHRcdHRvSGlkZS5hdHRyKCBcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiICk7XG5cdFx0ZXZlbnREYXRhLm9sZFRhYi5hdHRyKCB7XG5cdFx0XHRcImFyaWEtc2VsZWN0ZWRcIjogXCJmYWxzZVwiLFxuXHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwiZmFsc2VcIlxuXHRcdH0gKTtcblxuXHRcdC8vIElmIHdlJ3JlIHN3aXRjaGluZyB0YWJzLCByZW1vdmUgdGhlIG9sZCB0YWIgZnJvbSB0aGUgdGFiIG9yZGVyLlxuXHRcdC8vIElmIHdlJ3JlIG9wZW5pbmcgZnJvbSBjb2xsYXBzZWQgc3RhdGUsIHJlbW92ZSB0aGUgcHJldmlvdXMgdGFiIGZyb20gdGhlIHRhYiBvcmRlci5cblx0XHQvLyBJZiB3ZSdyZSBjb2xsYXBzaW5nLCB0aGVuIGtlZXAgdGhlIGNvbGxhcHNpbmcgdGFiIGluIHRoZSB0YWIgb3JkZXIuXG5cdFx0aWYgKCB0b1Nob3cubGVuZ3RoICYmIHRvSGlkZS5sZW5ndGggKSB7XG5cdFx0XHRldmVudERhdGEub2xkVGFiLmF0dHIoIFwidGFiSW5kZXhcIiwgLTEgKTtcblx0XHR9IGVsc2UgaWYgKCB0b1Nob3cubGVuZ3RoICkge1xuXHRcdFx0dGhpcy50YWJzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAkKCB0aGlzICkuYXR0ciggXCJ0YWJJbmRleFwiICkgPT09IDA7XG5cdFx0XHR9IClcblx0XHRcdFx0LmF0dHIoIFwidGFiSW5kZXhcIiwgLTEgKTtcblx0XHR9XG5cblx0XHR0b1Nob3cuYXR0ciggXCJhcmlhLWhpZGRlblwiLCBcImZhbHNlXCIgKTtcblx0XHRldmVudERhdGEubmV3VGFiLmF0dHIoIHtcblx0XHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBcInRydWVcIixcblx0XHRcdFwiYXJpYS1leHBhbmRlZFwiOiBcInRydWVcIixcblx0XHRcdHRhYkluZGV4OiAwXG5cdFx0fSApO1xuXHR9LFxuXG5cdF9hY3RpdmF0ZTogZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdHZhciBhbmNob3IsXG5cdFx0XHRhY3RpdmUgPSB0aGlzLl9maW5kQWN0aXZlKCBpbmRleCApO1xuXG5cdFx0Ly8gVHJ5aW5nIHRvIGFjdGl2YXRlIHRoZSBhbHJlYWR5IGFjdGl2ZSBwYW5lbFxuXHRcdGlmICggYWN0aXZlWyAwIF0gPT09IHRoaXMuYWN0aXZlWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gVHJ5aW5nIHRvIGNvbGxhcHNlLCBzaW11bGF0ZSBhIGNsaWNrIG9uIHRoZSBjdXJyZW50IGFjdGl2ZSBoZWFkZXJcblx0XHRpZiAoICFhY3RpdmUubGVuZ3RoICkge1xuXHRcdFx0YWN0aXZlID0gdGhpcy5hY3RpdmU7XG5cdFx0fVxuXG5cdFx0YW5jaG9yID0gYWN0aXZlLmZpbmQoIFwiLnVpLXRhYnMtYW5jaG9yXCIgKVsgMCBdO1xuXHRcdHRoaXMuX2V2ZW50SGFuZGxlcigge1xuXHRcdFx0dGFyZ2V0OiBhbmNob3IsXG5cdFx0XHRjdXJyZW50VGFyZ2V0OiBhbmNob3IsXG5cdFx0XHRwcmV2ZW50RGVmYXVsdDogJC5ub29wXG5cdFx0fSApO1xuXHR9LFxuXG5cdF9maW5kQWN0aXZlOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0cmV0dXJuIGluZGV4ID09PSBmYWxzZSA/ICQoKSA6IHRoaXMudGFicy5lcSggaW5kZXggKTtcblx0fSxcblxuXHRfZ2V0SW5kZXg6IGZ1bmN0aW9uKCBpbmRleCApIHtcblxuXHRcdC8vIG1ldGEtZnVuY3Rpb24gdG8gZ2l2ZSB1c2VycyBvcHRpb24gdG8gcHJvdmlkZSBhIGhyZWYgc3RyaW5nIGluc3RlYWQgb2YgYSBudW1lcmljYWwgaW5kZXguXG5cdFx0aWYgKCB0eXBlb2YgaW5kZXggPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpbmRleCA9IHRoaXMuYW5jaG9ycy5pbmRleCggdGhpcy5hbmNob3JzLmZpbHRlciggXCJbaHJlZiQ9J1wiICtcblx0XHRcdFx0JC5lc2NhcGVTZWxlY3RvciggaW5kZXggKSArIFwiJ11cIiApICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMueGhyICkge1xuXHRcdFx0dGhpcy54aHIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHR0aGlzLnRhYmxpc3Rcblx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApXG5cdFx0XHQub2ZmKCB0aGlzLmV2ZW50TmFtZXNwYWNlICk7XG5cblx0XHR0aGlzLmFuY2hvcnNcblx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGUgdGFiSW5kZXhcIiApXG5cdFx0XHQucmVtb3ZlVW5pcXVlSWQoKTtcblxuXHRcdHRoaXMudGFicy5hZGQoIHRoaXMucGFuZWxzICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICQuZGF0YSggdGhpcywgXCJ1aS10YWJzLWRlc3Ryb3lcIiApICkge1xuXHRcdFx0XHQkKCB0aGlzICkucmVtb3ZlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkKCB0aGlzICkucmVtb3ZlQXR0ciggXCJyb2xlIHRhYkluZGV4IFwiICtcblx0XHRcdFx0XHRcImFyaWEtbGl2ZSBhcmlhLWJ1c3kgYXJpYS1zZWxlY3RlZCBhcmlhLWxhYmVsbGVkYnkgYXJpYS1oaWRkZW4gYXJpYS1leHBhbmRlZFwiICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0dGhpcy50YWJzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGxpID0gJCggdGhpcyApLFxuXHRcdFx0XHRwcmV2ID0gbGkuZGF0YSggXCJ1aS10YWJzLWFyaWEtY29udHJvbHNcIiApO1xuXHRcdFx0aWYgKCBwcmV2ICkge1xuXHRcdFx0XHRsaVxuXHRcdFx0XHRcdC5hdHRyKCBcImFyaWEtY29udHJvbHNcIiwgcHJldiApXG5cdFx0XHRcdFx0LnJlbW92ZURhdGEoIFwidWktdGFicy1hcmlhLWNvbnRyb2xzXCIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxpLnJlbW92ZUF0dHIoIFwiYXJpYS1jb250cm9sc1wiICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0dGhpcy5wYW5lbHMuc2hvdygpO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuaGVpZ2h0U3R5bGUgIT09IFwiY29udGVudFwiICkge1xuXHRcdFx0dGhpcy5wYW5lbHMuY3NzKCBcImhlaWdodFwiLCBcIlwiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGVuYWJsZTogZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdHZhciBkaXNhYmxlZCA9IHRoaXMub3B0aW9ucy5kaXNhYmxlZDtcblx0XHRpZiAoIGRpc2FibGVkID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRkaXNhYmxlZCA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbmRleCA9IHRoaXMuX2dldEluZGV4KCBpbmRleCApO1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBkaXNhYmxlZCApICkge1xuXHRcdFx0XHRkaXNhYmxlZCA9ICQubWFwKCBkaXNhYmxlZCwgZnVuY3Rpb24oIG51bSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVtICE9PSBpbmRleCA/IG51bSA6IG51bGw7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpc2FibGVkID0gJC5tYXAoIHRoaXMudGFicywgZnVuY3Rpb24oIGxpLCBudW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bSAhPT0gaW5kZXggPyBudW0gOiBudWxsO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX3NldE9wdGlvbkRpc2FibGVkKCBkaXNhYmxlZCApO1xuXHR9LFxuXG5cdGRpc2FibGU6IGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHR2YXIgZGlzYWJsZWQgPSB0aGlzLm9wdGlvbnMuZGlzYWJsZWQ7XG5cdFx0aWYgKCBkaXNhYmxlZCA9PT0gdHJ1ZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRkaXNhYmxlZCA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgoIGluZGV4ICk7XG5cdFx0XHRpZiAoICQuaW5BcnJheSggaW5kZXgsIGRpc2FibGVkICkgIT09IC0xICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGRpc2FibGVkICkgKSB7XG5cdFx0XHRcdGRpc2FibGVkID0gJC5tZXJnZSggWyBpbmRleCBdLCBkaXNhYmxlZCApLnNvcnQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpc2FibGVkID0gWyBpbmRleCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9zZXRPcHRpb25EaXNhYmxlZCggZGlzYWJsZWQgKTtcblx0fSxcblxuXHRsb2FkOiBmdW5jdGlvbiggaW5kZXgsIGV2ZW50ICkge1xuXHRcdGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgoIGluZGV4ICk7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0dGFiID0gdGhpcy50YWJzLmVxKCBpbmRleCApLFxuXHRcdFx0YW5jaG9yID0gdGFiLmZpbmQoIFwiLnVpLXRhYnMtYW5jaG9yXCIgKSxcblx0XHRcdHBhbmVsID0gdGhpcy5fZ2V0UGFuZWxGb3JUYWIoIHRhYiApLFxuXHRcdFx0ZXZlbnREYXRhID0ge1xuXHRcdFx0XHR0YWI6IHRhYixcblx0XHRcdFx0cGFuZWw6IHBhbmVsXG5cdFx0XHR9LFxuXHRcdFx0Y29tcGxldGUgPSBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHR0aGF0LnBhbmVscy5zdG9wKCBmYWxzZSwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhhdC5fcmVtb3ZlQ2xhc3MoIHRhYiwgXCJ1aS10YWJzLWxvYWRpbmdcIiApO1xuXHRcdFx0XHRwYW5lbC5yZW1vdmVBdHRyKCBcImFyaWEtYnVzeVwiICk7XG5cblx0XHRcdFx0aWYgKCBqcVhIUiA9PT0gdGhhdC54aHIgKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoYXQueGhyO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gTm90IHJlbW90ZVxuXHRcdGlmICggdGhpcy5faXNMb2NhbCggYW5jaG9yWyAwIF0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnhociA9ICQuYWpheCggdGhpcy5fYWpheFNldHRpbmdzKCBhbmNob3IsIGV2ZW50LCBldmVudERhdGEgKSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogalF1ZXJ5IDwxLjhcblx0XHQvLyBqUXVlcnkgPDEuOCByZXR1cm5zIGZhbHNlIGlmIHRoZSByZXF1ZXN0IGlzIGNhbmNlbGVkIGluIGJlZm9yZVNlbmQsXG5cdFx0Ly8gYnV0IGFzIG9mIDEuOCwgJC5hamF4KCkgYWx3YXlzIHJldHVybnMgYSBqcVhIUiBvYmplY3QuXG5cdFx0aWYgKCB0aGlzLnhociAmJiB0aGlzLnhoci5zdGF0dXNUZXh0ICE9PSBcImNhbmNlbGVkXCIgKSB7XG5cdFx0XHR0aGlzLl9hZGRDbGFzcyggdGFiLCBcInVpLXRhYnMtbG9hZGluZ1wiICk7XG5cdFx0XHRwYW5lbC5hdHRyKCBcImFyaWEtYnVzeVwiLCBcInRydWVcIiApO1xuXG5cdFx0XHR0aGlzLnhoclxuXHRcdFx0XHQuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlLCBzdGF0dXMsIGpxWEhSICkge1xuXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcblx0XHRcdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMTc3OFxuXHRcdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cGFuZWwuaHRtbCggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdHRoYXQuX3RyaWdnZXIoIFwibG9hZFwiLCBldmVudCwgZXZlbnREYXRhICk7XG5cblx0XHRcdFx0XHRcdGNvbXBsZXRlKCBqcVhIUiwgc3RhdHVzICk7XG5cdFx0XHRcdFx0fSwgMSApO1xuXHRcdFx0XHR9IClcblx0XHRcdFx0LmZhaWwoIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcblx0XHRcdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMTc3OFxuXHRcdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0Y29tcGxldGUoIGpxWEhSLCBzdGF0dXMgKTtcblx0XHRcdFx0XHR9LCAxICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cdH0sXG5cblx0X2FqYXhTZXR0aW5nczogZnVuY3Rpb24oIGFuY2hvciwgZXZlbnQsIGV2ZW50RGF0YSApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPDExIG9ubHlcblx0XHRcdC8vIFN0cmlwIGFueSBoYXNoIHRoYXQgZXhpc3RzIHRvIHByZXZlbnQgZXJyb3JzIHdpdGggdGhlIEFqYXggcmVxdWVzdFxuXHRcdFx0dXJsOiBhbmNob3IuYXR0ciggXCJocmVmXCIgKS5yZXBsYWNlKCAvIy4qJC8sIFwiXCIgKSxcblx0XHRcdGJlZm9yZVNlbmQ6IGZ1bmN0aW9uKCBqcVhIUiwgc2V0dGluZ3MgKSB7XG5cdFx0XHRcdHJldHVybiB0aGF0Ll90cmlnZ2VyKCBcImJlZm9yZUxvYWRcIiwgZXZlbnQsXG5cdFx0XHRcdFx0JC5leHRlbmQoIHsganFYSFI6IGpxWEhSLCBhamF4U2V0dGluZ3M6IHNldHRpbmdzIH0sIGV2ZW50RGF0YSApICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSxcblxuXHRfZ2V0UGFuZWxGb3JUYWI6IGZ1bmN0aW9uKCB0YWIgKSB7XG5cdFx0dmFyIGlkID0gJCggdGFiICkuYXR0ciggXCJhcmlhLWNvbnRyb2xzXCIgKTtcblx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmZpbmQoIHRoaXMuX3Nhbml0aXplU2VsZWN0b3IoIFwiI1wiICsgaWQgKSApO1xuXHR9XG59ICk7XG5cbi8vIERFUFJFQ0FURURcbi8vIFRPRE86IFN3aXRjaCByZXR1cm4gYmFjayB0byB3aWRnZXQgZGVjbGFyYXRpb24gYXQgdG9wIG9mIGZpbGUgd2hlbiB0aGlzIGlzIHJlbW92ZWRcbmlmICggJC51aUJhY2tDb21wYXQgIT09IGZhbHNlICkge1xuXG5cdC8vIEJhY2tjb21wYXQgZm9yIHVpLXRhYiBjbGFzcyAobm93IHVpLXRhYnMtdGFiKVxuXHQkLndpZGdldCggXCJ1aS50YWJzXCIsICQudWkudGFicywge1xuXHRcdF9wcm9jZXNzVGFiczogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlckFwcGx5KCBhcmd1bWVudHMgKTtcblx0XHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLnRhYnMsIFwidWktdGFiXCIgKTtcblx0XHR9XG5cdH0gKTtcbn1cblxucmV0dXJuICQudWkudGFicztcblxufSApO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsVUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/jquery-ui/ui/widgets/tabs.js\n')},"../node_modules/jquery/dist/jquery.js":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.6.0\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2021-03-02T17:08Z\n */\n( function( global, factory ) {\n\n\t"use strict";\n\n\tif (  true && typeof module.exports === "object" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require("jquery")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( "jQuery requires a window with a document" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n"use strict";\n\nvar arr = [];\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar flat = arr.flat ? function( array ) {\n\treturn arr.flat.call( array );\n} : function( array ) {\n\treturn arr.concat.apply( [], array );\n};\n\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\nvar isFunction = function isFunction( obj ) {\n\n\t\t// Support: Chrome <=57, Firefox <=52\n\t\t// In some browsers, typeof returns "function" for HTML <object> elements\n\t\t// (i.e., `typeof document.createElement( "object" ) === "function"`).\n\t\t// We don\'t want to classify *any* DOM node as a function.\n\t\t// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5\n\t\t// Plus for old WebKit, typeof returns "function" for HTML collections\n\t\t// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)\n\t\treturn typeof obj === "function" && typeof obj.nodeType !== "number" &&\n\t\t\ttypeof obj.item !== "function";\n\t};\n\n\nvar isWindow = function isWindow( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t};\n\n\nvar document = window.document;\n\n\n\n\tvar preservedScriptAttributes = {\n\t\ttype: true,\n\t\tsrc: true,\n\t\tnonce: true,\n\t\tnoModule: true\n\t};\n\n\tfunction DOMEval( code, node, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar i, val,\n\t\t\tscript = doc.createElement( "script" );\n\n\t\tscript.text = code;\n\t\tif ( node ) {\n\t\t\tfor ( i in preservedScriptAttributes ) {\n\n\t\t\t\t// Support: Firefox 64+, Edge 18+\n\t\t\t\t// Some browsers don\'t support the "nonce" property on scripts.\n\t\t\t\t// On the other hand, just using `getAttribute` is not enough as\n\t\t\t\t// the `nonce` attribute is reset to an empty string whenever it\n\t\t\t\t// becomes browsing-context connected.\n\t\t\t\t// See https://github.com/whatwg/html/issues/2369\n\t\t\t\t// See https://html.spec.whatwg.org/#nonce-attributes\n\t\t\t\t// The `node.getAttribute` check was added for the sake of\n\t\t\t\t// `jQuery.globalEval` so that it can fake a nonce-containing node\n\t\t\t\t// via an object.\n\t\t\t\tval = node[ i ] || node.getAttribute && node.getAttribute( i );\n\t\t\t\tif ( val ) {\n\t\t\t\t\tscript.setAttribute( i, val );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + "";\n\t}\n\n\t// Support: Android <=2.3 only (functionish RegExp)\n\treturn typeof obj === "object" || typeof obj === "function" ?\n\t\tclass2type[ toString.call( obj ) ] || "object" :\n\t\ttypeof obj;\n}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = "3.6.0",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor \'enhanced\'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teven: function() {\n\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n\t\t\treturn ( i + 1 ) % 2;\n\t\t} ) );\n\t},\n\n\todd: function() {\n\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n\t\t\treturn i % 2;\n\t\t} ) );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array\'s method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === "boolean" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== "object" && !isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent Object.prototype pollution\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( name === "__proto__" || target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we\'re merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\t\t\t\t\tsrc = target[ name ];\n\n\t\t\t\t\t// Ensure proper type for the source value\n\t\t\t\t\tif ( copyIsArray && !Array.isArray( src ) ) {\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {\n\t\t\t\t\t\tclone = {};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src;\n\t\t\t\t\t}\n\t\t\t\t\tcopyIsArray = false;\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don\'t bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: "jQuery" + ( version + Math.random() ).replace( /\\D/g, "" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== "[object Object]" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, "constructor" ) && proto.constructor;\n\t\treturn typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t// Evaluates a script in a provided context; falls back to the global one\n\t// if not specified.\n\tglobalEval: function( code, options, doc ) {\n\t\tDOMEval( code, { nonce: options && options.nonce }, doc );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === "string" ?\n\t\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn flat( ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === "function" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),\n\tfunction( _i, name ) {\n\t\tclass2type[ "[object " + name + "]" ] = name.toLowerCase();\n\t} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn\'t used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && "length" in obj && obj.length,\n\t\ttype = toType( obj );\n\n\tif ( isFunction( obj ) || isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === "array" || length === 0 ||\n\t\ttypeof length === "number" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.6\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://js.foundation/\n *\n * Date: 2021-02-16\n */\n( function( window ) {\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = "sizzle" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tnonnativeSelectorCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ( {} ).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpushNative = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\n\t// Use a stripped-down indexOf as it\'s faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[ i ] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +\n\t\t"ismap|loop|multiple|open|readonly|required|scoped",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]",\n\n\t// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n\tidentifier = "(?:\\\\\\\\[\\\\da-fA-F]{1,6}" + whitespace +\n\t\t"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = "\\\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +\n\n\t\t// Operator (capture 2)\n\t\t"*([*^$|!~]?=)" + whitespace +\n\n\t\t// "Attribute values must be CSS identifiers [capture 5]\n\t\t// or strings [capture 3 or capture 4]"\n\t\t"*(?:\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\"|(" + identifier + "))|)" +\n\t\twhitespace + "*\\\\]",\n\n\tpseudos = ":(" + identifier + ")(?:\\\\((" +\n\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t"(\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\")|" +\n\n\t\t// 2. simple (capture 6)\n\t\t"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|" + attributes + ")*)|" +\n\n\t\t// 3. anything else (capture 2)\n\t\t".*" +\n\t\t")\\\\)|)",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + "+", "g" ),\n\trtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)" +\n\t\twhitespace + "+$", "g" ),\n\n\trcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),\n\trcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +\n\t\t"*" ),\n\trdescend = new RegExp( whitespace + "|>" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( "^" + identifier + "$" ),\n\n\tmatchExpr = {\n\t\t"ID": new RegExp( "^#(" + identifier + ")" ),\n\t\t"CLASS": new RegExp( "^\\\\.(" + identifier + ")" ),\n\t\t"TAG": new RegExp( "^(" + identifier + "|[*])" ),\n\t\t"ATTR": new RegExp( "^" + attributes ),\n\t\t"PSEUDO": new RegExp( "^" + pseudos ),\n\t\t"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(" +\n\t\t\twhitespace + "*(even|odd|(([+-]|)(\\\\d*)n|)" + whitespace + "*(?:([+-]|)" +\n\t\t\twhitespace + "*(\\\\d+)|))" + whitespace + "*\\\\)|)", "i" ),\n\t\t"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),\n\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t"needsContext": new RegExp( "^" + whitespace +\n\t\t\t"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(" + whitespace +\n\t\t\t"*((?:-\\\\d)?\\\\d*)" + whitespace + "*\\\\)|)(?=[^-]|$)", "i" )\n\t},\n\n\trhtml = /HTML$/i,\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( "\\\\\\\\[\\\\da-fA-F]{1,6}" + whitespace + "?|\\\\\\\\([^\\\\r\\\\n\\\\f])", "g" ),\n\tfunescape = function( escape, nonHex ) {\n\t\tvar high = "0x" + escape.slice( 1 ) - 0x10000;\n\n\t\treturn nonHex ?\n\n\t\t\t// Strip the backslash prefix from a non-hex escape sequence\n\t\t\tnonHex :\n\n\t\t\t// Replace a hexadecimal escape sequence with the encoded Unicode code point\n\t\t\t// Support: IE <=11+\n\t\t\t// For values outside the Basic Multilingual Plane (BMP), manually construct a\n\t\t\t// surrogate pair\n\t\t\thigh < 0 ?\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === "\\0" ) {\n\t\t\t\treturn "\\uFFFD";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + "\\\\" +\n\t\t\t\tch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn "\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a "Permission Denied"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tinDisabledFieldset = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";\n\t\t},\n\t\t{ dir: "parentNode", next: "legend" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t( arr = slice.call( preferredDoc.childNodes ) ),\n\t\tpreferredDoc.childNodes\n\t);\n\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\t// eslint-disable-next-line no-unused-expressions\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpushNative.apply( target, slice.call( els ) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\n\t\t\t// Can\'t trust NodeList.length\n\t\t\twhile ( ( target[ j++ ] = els[ i++ ] ) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== "string" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\t\tsetDocument( context );\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a "get*By*" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don\'t exist)\n\t\t\tif ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( ( m = match[ 1 ] ) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( ( elem = context.getElementById( m ) ) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && ( elem = newContext.getElementById( m ) ) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[ 2 ] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!nonnativeSelectorCache[ selector + " " ] &&\n\t\t\t\t( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&\n\n\t\t\t\t// Support: IE 8 only\n\t\t\t\t// Exclude object elements\n\t\t\t\t( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {\n\n\t\t\t\tnewSelector = selector;\n\t\t\t\tnewContext = context;\n\n\t\t\t\t// qSA considers elements outside a scoping root when evaluating child or\n\t\t\t\t// descendant combinators, which is not what we want.\n\t\t\t\t// In such cases, we work around the behavior by prefixing every selector in the\n\t\t\t\t// list with an ID selector referencing the scope context.\n\t\t\t\t// The technique has to be used as well when a leading combinator is used\n\t\t\t\t// as such selectors are not recognized by querySelectorAll.\n\t\t\t\t// Thanks to Andrew Dupont for this technique.\n\t\t\t\tif ( nodeType === 1 &&\n\t\t\t\t\t( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\n\t\t\t\t\t// We can use :scope instead of the ID hack if the browser\n\t\t\t\t\t// supports it & if we\'re not changing the context.\n\t\t\t\t\tif ( newContext !== context || !support.scope ) {\n\n\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\t\tif ( ( nid = context.getAttribute( "id" ) ) ) {\n\t\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.setAttribute( "id", ( nid = expando ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +\n\t\t\t\t\t\t\ttoSelector( groups[ i ] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( "," );\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\tnonnativeSelectorCache( selector, true );\n\t\t\t\t} finally {\n\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\tcontext.removeAttribute( "id" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, "$1" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\n\t\t// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + " " ) > Expr.cacheLength ) {\n\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn ( cache[ key + " " ] = value );\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement( "fieldset" );\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch ( e ) {\n\t\treturn false;\n\t} finally {\n\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split( "|" ),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[ i ] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( ( cur = cur.nextSibling ) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === "input" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn ( name === "input" || name === "button" ) && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( "form" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a "form" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( "label" in elem ) {\n\t\t\t\t\tif ( "label" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can\'t be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn\'t\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( "label" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction( function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction( function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ ( j = matchIndexes[ i ] ) ] ) {\n\t\t\t\t\tseed[ j ] = !( matches[ j ] = seed[ j ] );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t} );\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== "undefined" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\tvar namespace = elem && elem.namespaceURI,\n\t\tdocElem = elem && ( elem.ownerDocument || elem ).documentElement;\n\n\t// Support: IE <=8\n\t// Assume HTML when documentElement doesn\'t yet exist, such as inside loading iframes\n\t// https://bugs.jquery.com/ticket/4833\n\treturn !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a "Permission denied" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+\n\t// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a "Permission denied" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( preferredDoc != document &&\n\t\t( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( "unload", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( "onunload", unloadHandler );\n\t\t}\n\t}\n\n\t// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\n\t// Safari 4 - 5 only, Opera <=11.6 - 12.x only\n\t// IE/Edge & older browsers don\'t support the :scope pseudo-class.\n\t// Support: Safari 6.0 only\n\t// Safari 6.0 supports :scope but it\'s an alias of :root there.\n\tsupport.scope = assert( function( el ) {\n\t\tdocElem.appendChild( el ).appendChild( document.createElement( "div" ) );\n\t\treturn typeof el.querySelectorAll !== "undefined" &&\n\t\t\t!el.querySelectorAll( ":scope fieldset div" ).length;\n\t} );\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert( function( el ) {\n\t\tel.className = "i";\n\t\treturn !el.getAttribute( "className" );\n\t} );\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName("*") returns only elements\n\tsupport.getElementsByTagName = assert( function( el ) {\n\t\tel.appendChild( document.createComment( "" ) );\n\t\treturn !el.getElementsByTagName( "*" ).length;\n\t} );\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don\'t pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert( function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t} );\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[ "ID" ] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute( "id" ) === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[ "ID" ] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== "undefined" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[ "ID" ] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== "undefined" &&\n\t\t\t\t\telem.getAttributeNode( "id" );\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[ "ID" ] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== "undefined" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode( "id" );\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( ( elem = elems[ i++ ] ) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode( "id" );\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[ "TAG" ] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== "undefined" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don\'t have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === "*" ) {\n\t\t\t\twhile ( ( elem = results[ i++ ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {\n\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert( function( el ) {\n\n\t\t\tvar input;\n\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE\'s treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = "<a id=\'" + expando + "\'></a>" +\n\t\t\t\t"<select id=\'" + expando + "-\\r\\\\\' msallowcapture=\'\'>" +\n\t\t\t\t"<option selected=\'\'></option></select>";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but "safe" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll( "[msallowcapture^=\'\']" ).length ) {\n\t\t\t\trbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\'\'|\\"\\")" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and "value" are not treated correctly\n\t\t\tif ( !el.querySelectorAll( "[selected]" ).length ) {\n\t\t\t\trbuggyQSA.push( "\\\\[" + whitespace + "*(?:value|" + booleans + ")" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {\n\t\t\t\trbuggyQSA.push( "~=" );\n\t\t\t}\n\n\t\t\t// Support: IE 11+, Edge 15 - 18+\n\t\t\t// IE 11/Edge don\'t find elements on a `[name=\'\']` query in some cases.\n\t\t\t// Adding a temporary attribute to the document before the selection works\n\t\t\t// around the issue.\n\t\t\t// Interestingly, IE 10 & older don\'t seem to have the issue.\n\t\t\tinput = document.createElement( "input" );\n\t\t\tinput.setAttribute( "name", "" );\n\t\t\tel.appendChild( input );\n\t\t\tif ( !el.querySelectorAll( "[name=\'\']" ).length ) {\n\t\t\t\trbuggyQSA.push( "\\\\[" + whitespace + "*name" + whitespace + "*=" +\n\t\t\t\t\twhitespace + "*(?:\'\'|\\"\\")" );\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll( ":checked" ).length ) {\n\t\t\t\trbuggyQSA.push( ":checked" );\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {\n\t\t\t\trbuggyQSA.push( ".#.+[+~]" );\n\t\t\t}\n\n\t\t\t// Support: Firefox <=3.6 - 5 only\n\t\t\t// Old Firefox doesn\'t throw on a badly-escaped identifier.\n\t\t\tel.querySelectorAll( "\\\\\\f" );\n\t\t\trbuggyQSA.push( "[\\\\r\\\\n\\\\f]" );\n\t\t} );\n\n\t\tassert( function( el ) {\n\t\t\tel.innerHTML = "<a href=\'\' disabled=\'disabled\'></a>" +\n\t\t\t\t"<select disabled=\'disabled\'><option/></select>";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement( "input" );\n\t\t\tinput.setAttribute( "type", "hidden" );\n\t\t\tel.appendChild( input ).setAttribute( "name", "D" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll( "[name=d]" ).length ) {\n\t\t\t\trbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll( ":enabled" ).length !== 2 ) {\n\t\t\t\trbuggyQSA.push( ":enabled", ":disabled" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE\'s :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll( ":disabled" ).length !== 2 ) {\n\t\t\t\trbuggyQSA.push( ":enabled", ":disabled" );\n\t\t\t}\n\n\t\t\t// Support: Opera 10 - 11 only\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll( "*,:x" );\n\t\t\trbuggyQSA.push( ",.*:" );\n\t\t} );\n\t}\n\n\tif ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector ) ) ) ) {\n\n\t\tassert( function( el ) {\n\n\t\t\t// Check to see if it\'s possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, "*" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, "[s!=\'\']:x" );\n\t\t\trbuggyMatches.push( "!=", pseudos );\n\t\t} );\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t) );\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( ( b = b.parentNode ) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t// IE/Edge sometimes throw a "Permission denied" error when strict-comparing\n\t\t// two documents; shallow comparisons work.\n\t\t// eslint-disable-next-line eqeqeq\n\t\tcompare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a "Permission denied" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tif ( a == document || a.ownerDocument == preferredDoc &&\n\t\t\t\tcontains( preferredDoc, a ) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a "Permission denied" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tif ( b == document || b.ownerDocument == preferredDoc &&\n\t\t\t\tcontains( preferredDoc, b ) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a "Permission denied" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t/* eslint-disable eqeqeq */\n\t\t\treturn a == document ? -1 :\n\t\t\t\tb == document ? 1 :\n\t\t\t\t/* eslint-enable eqeqeq */\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( ( cur = cur.parentNode ) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( ( cur = cur.parentNode ) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[ i ] === bp[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[ i ], bp[ i ] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a "Permission denied" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t/* eslint-disable eqeqeq */\n\t\t\tap[ i ] == preferredDoc ? -1 :\n\t\t\tbp[ i ] == preferredDoc ? 1 :\n\t\t\t/* eslint-enable eqeqeq */\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\tsetDocument( elem );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!nonnativeSelectorCache[ expr + " " ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9\'s matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\n\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t// fragment in IE 9\n\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\tnonnativeSelectorCache( expr, true );\n\t\t}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\n\t// Set document vars if needed\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a "Permission denied" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( ( context.ownerDocument || context ) != document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\n\t// Set document vars if needed\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a "Permission denied" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( ( elem.ownerDocument || elem ) != document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\n\t\t// Don\'t get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn ( sel + "" ).replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( "Syntax error, unrecognized expression: " + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( ( elem = results[ i++ ] ) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = "",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( ( node = elem[ i++ ] ) ) {\n\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === "string" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t">": { dir: "parentNode", first: true },\n\t\t" ": { dir: "parentNode" },\n\t\t"+": { dir: "previousSibling", first: true },\n\t\t"~": { dir: "previousSibling" }\n\t},\n\n\tpreFilter: {\n\t\t"ATTR": function( match ) {\n\t\t\tmatch[ 1 ] = match[ 1 ].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[ 3 ] = ( match[ 3 ] || match[ 4 ] ||\n\t\t\t\tmatch[ 5 ] || "" ).replace( runescape, funescape );\n\n\t\t\tif ( match[ 2 ] === "~=" ) {\n\t\t\t\tmatch[ 3 ] = " " + match[ 3 ] + " ";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t"CHILD": function( match ) {\n\n\t\t\t/* matches from matchExpr["CHILD"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[ 1 ] = match[ 1 ].toLowerCase();\n\n\t\t\tif ( match[ 1 ].slice( 0, 3 ) === "nth" ) {\n\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[ 3 ] ) {\n\t\t\t\t\tSizzle.error( match[ 0 ] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[ 4 ] = +( match[ 4 ] ?\n\t\t\t\t\tmatch[ 5 ] + ( match[ 6 ] || 1 ) :\n\t\t\t\t\t2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );\n\t\t\t\tmatch[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );\n\n\t\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[ 3 ] ) {\n\t\t\t\tSizzle.error( match[ 0 ] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t"PSEUDO": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[ 6 ] && match[ 2 ];\n\n\t\t\tif ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[ 3 ] ) {\n\t\t\t\tmatch[ 2 ] = match[ 4 ] || match[ 5 ] || "";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t( excess = tokenize( unquoted, true ) ) &&\n\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[ 0 ] = match[ 0 ].slice( 0, excess );\n\t\t\t\tmatch[ 2 ] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t"TAG": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === "*" ?\n\t\t\t\tfunction() {\n\t\t\t\t\treturn true;\n\t\t\t\t} :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t"CLASS": function( className ) {\n\t\t\tvar pattern = classCache[ className + " " ];\n\n\t\t\treturn pattern ||\n\t\t\t\t( pattern = new RegExp( "(^|" + whitespace +\n\t\t\t\t\t")" + className + "(" + whitespace + "|$)" ) ) && classCache(\n\t\t\t\t\t\tclassName, function( elem ) {\n\t\t\t\t\t\t\treturn pattern.test(\n\t\t\t\t\t\t\t\ttypeof elem.className === "string" && elem.className ||\n\t\t\t\t\t\t\t\ttypeof elem.getAttribute !== "undefined" &&\n\t\t\t\t\t\t\t\t\telem.getAttribute( "class" ) ||\n\t\t\t\t\t\t\t\t""\n\t\t\t\t\t\t\t);\n\t\t\t\t} );\n\t\t},\n\n\t\t"ATTR": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === "!=";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += "";\n\n\t\t\t\t/* eslint-disable max-len */\n\n\t\t\t\treturn operator === "=" ? result === check :\n\t\t\t\t\toperator === "!=" ? result !== check :\n\t\t\t\t\toperator === "^=" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === "*=" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === "$=" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :\n\t\t\t\t\tfalse;\n\t\t\t\t/* eslint-enable max-len */\n\n\t\t\t};\n\t\t},\n\n\t\t"CHILD": function( type, what, _argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== "nth",\n\t\t\t\tforward = type.slice( -4 ) !== "last",\n\t\t\t\tofType = what === "of-type";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, _context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? "nextSibling" : "previousSibling",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( ( node = node[ dir ] ) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven\'t yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === "only" && !start && "nextSibling";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t"PSEUDO": function( pseudo, argument ) {\n\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( "unsupported pseudo: " + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, "", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction( function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[ i ] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[ i ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t} ) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\n\t\t// Potentially complex pseudos\n\t\t"not": markFunction( function( selector ) {\n\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, "$1" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction( function( seed, matches, _context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( ( elem = unmatched[ i ] ) ) {\n\t\t\t\t\t\t\tseed[ i ] = !( matches[ i ] = elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} ) :\n\t\t\t\tfunction( elem, _context, xml ) {\n\t\t\t\t\tinput[ 0 ] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\n\t\t\t\t\t// Don\'t keep the element (issue #299)\n\t\t\t\t\tinput[ 0 ] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t} ),\n\n\t\t"has": markFunction( function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t} ),\n\n\t\t"contains": markFunction( function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t} ),\n\n\t\t// "Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element\'s language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by "-".\n\t\t// The matching of C against the element\'s language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name."\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t"lang": markFunction( function( lang ) {\n\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test( lang || "" ) ) {\n\t\t\t\tSizzle.error( "unsupported lang: " + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( ( elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t} ),\n\n\t\t// Miscellaneous\n\t\t"target": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t"root": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t"focus": function( elem ) {\n\t\t\treturn elem === document.activeElement &&\n\t\t\t\t( !document.hasFocus || document.hasFocus() ) &&\n\t\t\t\t!!( elem.type || elem.href || ~elem.tabIndex );\n\t\t},\n\n\t\t// Boolean properties\n\t\t"enabled": createDisabledPseudo( false ),\n\t\t"disabled": createDisabledPseudo( true ),\n\n\t\t"checked": function( elem ) {\n\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn ( nodeName === "input" && !!elem.checked ) ||\n\t\t\t\t( nodeName === "option" && !!elem.selected );\n\t\t},\n\n\t\t"selected": function( elem ) {\n\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\t// eslint-disable-next-line no-unused-expressions\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t"empty": function( elem ) {\n\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t"parent": function( elem ) {\n\t\t\treturn !Expr.pseudos[ "empty" ]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t"header": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t"input": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t"button": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === "input" && elem.type === "button" || name === "button";\n\t\t},\n\n\t\t"text": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === "input" &&\n\t\t\t\telem.type === "text" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"\n\t\t\t\t( ( attr = elem.getAttribute( "type" ) ) == null ||\n\t\t\t\t\tattr.toLowerCase() === "text" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t"first": createPositionalPseudo( function() {\n\t\t\treturn [ 0 ];\n\t\t} ),\n\n\t\t"last": createPositionalPseudo( function( _matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t} ),\n\n\t\t"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t} ),\n\n\t\t"even": createPositionalPseudo( function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t"odd": createPositionalPseudo( function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ?\n\t\t\t\targument + length :\n\t\t\t\targument > length ?\n\t\t\t\t\tlength :\n\t\t\t\t\targument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} )\n\t}\n};\n\nExpr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + " " ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || ( match = rcomma.exec( soFar ) ) ) {\n\t\t\tif ( match ) {\n\n\t\t\t\t// Don\'t consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[ 0 ].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( ( tokens = [] ) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( ( match = rcombinators.exec( soFar ) ) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push( {\n\t\t\t\tvalue: matched,\n\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[ 0 ].replace( rtrim, " " )\n\t\t\t} );\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||\n\t\t\t\t( match = preFilters[ type ]( match ) ) ) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push( {\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t} );\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we\'re just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = "";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[ i ].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === "parentNode",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can\'t set arbitrary data on XML nodes, so they don\'t benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || ( elem[ expando ] = {} );\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] ||\n\t\t\t\t\t\t\t( outerCache[ elem.uniqueID ] = {} );\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( ( oldCache = uniqueCache[ key ] ) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn ( newCache[ 2 ] = oldCache[ 2 ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we\'re done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[ i ]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[ 0 ];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[ i ], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( ( elem = unmatched[ i ] ) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction( function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts(\n\t\t\t\tselector || "*",\n\t\t\t\tcontext.nodeType ? [ context ] : context,\n\t\t\t\t[]\n\t\t\t),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( ( elem = temp[ i ] ) ) {\n\t\t\t\t\tmatcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) ) {\n\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( ( matcherIn[ i ] = elem ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, ( matcherOut = [] ), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) &&\n\t\t\t\t\t\t( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {\n\n\t\t\t\t\t\tseed[ temp ] = !( results[ temp ] = elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t} );\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[ 0 ].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[ " " ],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t( checkContext = context ).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {\n\t\t\tmatchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[ j ].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\n\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\ttokens\n\t\t\t\t\t\t.slice( 0, i - 1 )\n\t\t\t\t\t\t.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )\n\t\t\t\t\t).replace( rtrim, "$1" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = "0",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),\n\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\n\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t// IE/Edge sometimes throw a "Permission denied" error when strict-comparing\n\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\toutermostContext = context == document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\n\t\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t\t// IE/Edge sometimes throw a "Permission denied" error when strict-comparing\n\t\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\t\tif ( !context && elem.ownerDocument != document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( ( matcher = elementMatchers[ j++ ] ) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( ( elem = !matcher && elem ) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn\'t visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a "00" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( ( matcher = setMatchers[ j++ ] ) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !( unmatched[ i ] || setMatched[ i ] ) ) {\n\t\t\t\t\t\t\t\tsetMatched[ i ] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + " " ];\n\n\tif ( !cached ) {\n\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[ i ] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache(\n\t\t\tselector,\n\t\t\tmatcherFromGroupMatchers( elementMatchers, setMatchers )\n\t\t);\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle\'s compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === "function" && selector,\n\t\tmatch = !seed && tokenize( ( selector = compiled.selector || selector ) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[ 0 ] = match[ 0 ].slice( 0 );\n\t\tif ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&\n\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {\n\n\t\t\tcontext = ( Expr.find[ "ID" ]( token.matches[ 0 ]\n\t\t\t\t.replace( runescape, funescape ), context ) || [] )[ 0 ];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[ i ];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ ( type = token.type ) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( ( find = Expr.find[ type ] ) ) {\n\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( ( seed = find(\n\t\t\t\t\ttoken.matches[ 0 ].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext\n\t\t\t\t) ) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren\'t passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert( function( el ) {\n\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;\n} );\n\n// Support: IE<8\n// Prevent attribute/property "interpolation"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert( function( el ) {\n\tel.innerHTML = "<a href=\'#\'></a>";\n\treturn el.firstChild.getAttribute( "href" ) === "#";\n} ) ) {\n\taddHandle( "type|href|height|width", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );\n\t\t}\n\t} );\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute("value")\nif ( !support.attributes || !assert( function( el ) {\n\tel.innerHTML = "<input/>";\n\tel.firstChild.setAttribute( "value", "" );\n\treturn el.firstChild.getAttribute( "value" ) === "";\n} ) ) {\n\taddHandle( "value", function( elem, _name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === "input" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t} );\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert( function( el ) {\n\treturn el.getAttribute( "disabled" ) == null;\n} ) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t\t}\n\t} );\n}\n\nreturn Sizzle;\n\n} )( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ ":" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n}\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== "string" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Filtered directly for both simple and complex selectors\n\treturn jQuery.filter( qualifier, elements, not );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = ":not(" + expr + ")";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== "string" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $("p:first").is("p:last") won\'t return true for a doc with two "p".\n\t\t\ttypeof selector === "string" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(""), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === "string" ) {\n\t\t\tif ( selector[ 0 ] === "<" &&\n\t\t\t\tselector[ selector.length - 1 ] === ">" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== "string" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there\'s no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don\'t pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === "string" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, "parentNode" );\n\t},\n\tparentsUntil: function( elem, _i, until ) {\n\t\treturn dir( elem, "parentNode", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, "nextSibling" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, "previousSibling" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, "nextSibling" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, "previousSibling" );\n\t},\n\tnextUntil: function( elem, _i, until ) {\n\t\treturn dir( elem, "nextSibling", until );\n\t},\n\tprevUntil: function( elem, _i, until ) {\n\t\treturn dir( elem, "previousSibling", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\tif ( elem.contentDocument != null &&\n\n\t\t\t// Support: IE 11+\n\t\t\t// <object> elements with no `data` attribute has an object\n\t\t\t// `contentDocument` with a `null` prototype.\n\t\t\tgetProto( elem.contentDocument ) ) {\n\n\t\t\treturn elem.contentDocument;\n\t\t}\n\n\t\t// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n\t\t// Treat the template element as a regular one in browsers that\n\t\t// don\'t support it.\n\t\tif ( nodeName( elem, "template" ) ) {\n\t\t\telem = elem.content || elem;\n\t\t}\n\n\t\treturn jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== "Until" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === "string" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * "fired" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest "memorized"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === "string" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn\'t re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we\'re done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we\'re done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = "";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== "string" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = "";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = "";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn\'t unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ "notify", "progress", jQuery.Callbacks( "memory" ),\n\t\t\t\t\tjQuery.Callbacks( "memory" ), 2 ],\n\t\t\t\t[ "resolve", "done", jQuery.Callbacks( "once memory" ),\n\t\t\t\t\tjQuery.Callbacks( "once memory" ), 0, "resolved" ],\n\t\t\t\t[ "reject", "fail", jQuery.Callbacks( "once memory" ),\n\t\t\t\t\tjQuery.Callbacks( "once memory" ), 1, "rejected" ]\n\t\t\t],\n\t\t\tstate = "pending",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t"catch": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( _i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + "With" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( "Thenable self-resolution" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === "object" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === "function" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it\'s otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = "resolved" (i.e., fulfilled)\n\t\t\t\t\t\t// state = "rejected"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + "With" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the primary Deferred\n\t\t\tprimary = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tprimary.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( primary.state() === "pending" ||\n\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn primary.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );\n\t\t}\n\n\t\treturn primary.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we\'re already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( "DOMContentLoaded", completed );\n\twindow.removeEventListener( "load", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals "interactive" too soon\nif ( document.readyState === "complete" ||\n\t( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( "DOMContentLoaded", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( "load", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it\'s a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( toType( key ) === "object" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, _key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\t\tvalue :\n\t\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\n\n\n// Matches dashed string for camelizing\nvar rmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g;\n\n// Used by camelCase as callback to replace()\nfunction fcamelCase( _all, letter ) {\n\treturn letter.toUpperCase();\n}\n\n// Convert dashed to camelCase; used by the css and data modules\n// Support: IE <=9 - 11, Edge 12 - 15\n// Microsoft forgot to hump their vendor prefix (#9572)\nfunction camelCase( string ) {\n\treturn string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );\n}\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === "string" ) {\n\t\t\tcache[ camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the "read" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === "string" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the "set" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( camelCase );\n\t\t\t} else {\n\t\t\t\tkey = camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there\'s no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module\'s maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support "private" and "user" data.\n//\t4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === "true" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === "false" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === "null" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn\'t change the string\n\tif ( data === +data + "" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === "string" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn\'t changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( "data-" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, "hasDataAttrs", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === "object" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to "discover" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn\'t exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || "fx" ) + "queue";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || "fx";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === "inprogress" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === "fx" ) {\n\t\t\t\tqueue.unshift( "inprogress" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + "queueHooks";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( "once memory" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + "queue", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tdata = type;\n\t\t\ttype = "fx";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === "fx" && queue[ 0 ] !== "inprogress" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || "fx", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || "fx";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + "queueHooks" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );\n\n\nvar cssExpand = [ "Top", "Right", "Bottom", "Left" ];\n\nvar documentElement = document.documentElement;\n\n\n\n\tvar isAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem );\n\t\t},\n\t\tcomposed = { composed: true };\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n\t// Check attachment across shadow DOM boundaries when possible (gh-3504)\n\t// Support: iOS 10.0-10.2 only\n\t// Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n\t// leading to errors. We need to check for `getRootNode`.\n\tif ( documentElement.getRootNode ) {\n\t\tisAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem ) ||\n\t\t\t\telem.getRootNode( composed ) === elem.ownerDocument;\n\t\t};\n\t}\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === "none" ||\n\t\t\telem.style.display === "" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tisAttached( elem ) &&\n\n\t\t\tjQuery.css( elem, "display" ) === "none";\n\t};\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted, scale,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, "" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = elem.nodeType &&\n\t\t\t( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Support: Firefox <=54\n\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n\t\tinitial = initial / 2;\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\twhile ( maxIterations-- ) {\n\n\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n\t\t\t\tmaxIterations = 0;\n\t\t\t}\n\t\t\tinitialInUnit = initialInUnit / scale;\n\n\t\t}\n\n\t\tinitialInUnit = initialInUnit * 2;\n\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, "display" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === "none" ) {\n\t\tdisplay = "block";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === "none" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, "display" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = "";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== "none" ) {\n\t\t\t\tvalues[ index ] = "none";\n\n\t\t\t\t// Remember what we\'re overwriting\n\t\t\t\tdataPriv.set( elem, "display", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === "boolean" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i );\n\nvar rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( "div" ) ),\n\t\tinput = document.createElement( "input" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( "type", "radio" );\n\tinput.setAttribute( "checked", "checked" );\n\tinput.setAttribute( "name", "t" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn\'t clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = "<textarea>x</textarea>";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\n\t// Support: IE <=9 only\n\t// IE <=9 replaces <option> tags with their contents when inserted outside of\n\t// the select element.\n\tdiv.innerHTML = "<option></option>";\n\tsupport.option = !!div.lastChild;\n} )();\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, "<table>", "</table>" ],\n\tcol: [ 2, "<table><colgroup>", "</colgroup></table>" ],\n\ttr: [ 2, "<table><tbody>", "</tbody></table>" ],\n\ttd: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],\n\n\t_default: [ 0, "", "" ]\n};\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// Support: IE <=9 only\nif ( !support.option ) {\n\twrapMap.optgroup = wrapMap.option = [ 1, "<select multiple=\'multiple\'>", "</select>" ];\n}\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== "undefined" ) {\n\t\tret = context.getElementsByTagName( tag || "*" );\n\n\t} else if ( typeof context.querySelectorAll !== "undefined" ) {\n\t\tret = context.querySelectorAll( tag || "*" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t"globalEval",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], "globalEval" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, attached, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( toType( elem ) === "object" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( "div" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = "";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = "";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tattached = isAttached( elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), "script" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( attached ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || "" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\nvar rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 - 11+\n// focus() and blur() are asynchronous, except when they are no-op.\n// So expect focus to be synchronous when the element is already active,\n// and blur to be synchronous when the element is not already active.\n// (focus and blur are always synchronous in other supported browsers,\n// this just defines when we can count on it).\nfunction expectSync( elem, type ) {\n\treturn ( elem === safeActiveElement() ) === ( type === "focus" );\n}\n\n// Support: IE <=9 only\n// Accessing document.activeElement can throw unexpectedly\n// https://bugs.jquery.com/ticket/13393\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === "object" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== "string" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === "string" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards\' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Only attach events to objects that accept data\n\t\tif ( !acceptData( elem ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element\'s event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = Object.create( null );\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || "" ).match( rnothtmlwhite ) || [ "" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( "." )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we\'re the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element\'s handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || "" ).match( rnothtmlwhite ) || [ "" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( "(^|\\\\.)" + namespaces.join( "\\\\.(?:.*\\\\.|)" ) + "(\\\\.|$)" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === "**" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it\'s no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, "handle events" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\n\t\t\t// Make a writable jQuery.Event from the native event object\n\t\t\tevent = jQuery.event.fix( nativeEvent ),\n\n\t\t\thandlers = (\n\t\t\t\tdataPriv.get( this, "events" ) || Object.create( null )\n\t\t\t)[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// If the event is namespaced, then each handler is only invoked if it is\n\t\t\t\t// specially universal or its namespaces are a superset of the event\'s.\n\t\t\t\tif ( !event.rnamespace || handleObj.namespace === false ||\n\t\t\t\t\tevent.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === "click" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don\'t check non-elements (#13208)\n\t\t\t\t// Don\'t process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don\'t conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + " ";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tclick: {\n\n\t\t\t// Utilize native event to ensure correct state for checkable inputs\n\t\t\tsetup: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Claim the first handler\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, "input" ) ) {\n\n\t\t\t\t\t// dataPriv.set( el, "click", ... )\n\t\t\t\t\tleverageNative( el, "click", returnTrue );\n\t\t\t\t}\n\n\t\t\t\t// Return false to allow normal processing in the caller\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\ttrigger: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Force setup before triggering a click\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, "input" ) ) {\n\n\t\t\t\t\tleverageNative( el, "click" );\n\t\t\t\t}\n\n\t\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, suppress native .click() on links\n\t\t\t// Also prevent it if we\'re currently inside a leveraged native-event stack\n\t\t\t_default: function( event ) {\n\t\t\t\tvar target = event.target;\n\t\t\t\treturn rcheckableType.test( target.type ) &&\n\t\t\t\t\ttarget.click && nodeName( target, "input" ) &&\n\t\t\t\t\tdataPriv.get( target, "click" ) ||\n\t\t\t\t\tnodeName( target, "a" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn\'t alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Ensure the presence of an event listener that handles manually-triggered\n// synthetic events by interrupting progress until reinvoked in response to\n// *native* events that it fires directly, ensuring that state changes have\n// already occurred before other listeners are invoked.\nfunction leverageNative( el, type, expectSync ) {\n\n\t// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n\tif ( !expectSync ) {\n\t\tif ( dataPriv.get( el, type ) === undefined ) {\n\t\t\tjQuery.event.add( el, type, returnTrue );\n\t\t}\n\t\treturn;\n\t}\n\n\t// Register the controller as a special universal handler for all event namespaces\n\tdataPriv.set( el, type, false );\n\tjQuery.event.add( el, type, {\n\t\tnamespace: false,\n\t\thandler: function( event ) {\n\t\t\tvar notAsync, result,\n\t\t\t\tsaved = dataPriv.get( this, type );\n\n\t\t\tif ( ( event.isTrigger & 1 ) && this[ type ] ) {\n\n\t\t\t\t// Interrupt processing of the outer synthetic .trigger()ed event\n\t\t\t\t// Saved data should be false in such cases, but might be a leftover capture object\n\t\t\t\t// from an async native handler (gh-4350)\n\t\t\t\tif ( !saved.length ) {\n\n\t\t\t\t\t// Store arguments for use when handling the inner native event\n\t\t\t\t\t// There will always be at least one argument (an event object), so this array\n\t\t\t\t\t// will not be confused with a leftover capture object.\n\t\t\t\t\tsaved = slice.call( arguments );\n\t\t\t\t\tdataPriv.set( this, type, saved );\n\n\t\t\t\t\t// Trigger the native event and capture its result\n\t\t\t\t\t// Support: IE <=9 - 11+\n\t\t\t\t\t// focus() and blur() are asynchronous\n\t\t\t\t\tnotAsync = expectSync( this, type );\n\t\t\t\t\tthis[ type ]();\n\t\t\t\t\tresult = dataPriv.get( this, type );\n\t\t\t\t\tif ( saved !== result || notAsync ) {\n\t\t\t\t\t\tdataPriv.set( this, type, false );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = {};\n\t\t\t\t\t}\n\t\t\t\t\tif ( saved !== result ) {\n\n\t\t\t\t\t\t// Cancel the outer synthetic event\n\t\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\t\t// Support: Chrome 86+\n\t\t\t\t\t\t// In Chrome, if an element having a focusout handler is blurred by\n\t\t\t\t\t\t// clicking outside of it, it invokes the handler synchronously. If\n\t\t\t\t\t\t// that handler calls `.remove()` on the element, the data is cleared,\n\t\t\t\t\t\t// leaving `result` undefined. We need to guard against this.\n\t\t\t\t\t\treturn result && result.value;\n\t\t\t\t\t}\n\n\t\t\t\t// If this is an inner synthetic event for an event with a bubbling surrogate\n\t\t\t\t// (focus or blur), assume that the surrogate already propagated from triggering the\n\t\t\t\t// native event and prevent that from happening again here.\n\t\t\t\t// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n\t\t\t\t// bubbling surrogate propagates *after* the non-bubbling base), but that seems\n\t\t\t\t// less bad than duplication.\n\t\t\t\t} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t}\n\n\t\t\t// If this is a native event triggered above, everything is now in order\n\t\t\t// Fire an inner synthetic event with the original arguments\n\t\t\t} else if ( saved.length ) {\n\n\t\t\t\t// ...and capture the result\n\t\t\t\tdataPriv.set( this, type, {\n\t\t\t\t\tvalue: jQuery.event.trigger(\n\n\t\t\t\t\t\t// Support: IE <=9 - 11+\n\t\t\t\t\t\t// Extend with the prototype to reset the above stopImmediatePropagation()\n\t\t\t\t\t\tjQuery.extend( saved[ 0 ], jQuery.Event.prototype ),\n\t\t\t\t\t\tsaved.slice( 1 ),\n\t\t\t\t\t\tthis\n\t\t\t\t\t)\n\t\t\t\t} );\n\n\t\t\t\t// Abort handling of the native event\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t}\n\t\t}\n\t} );\n}\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This "if" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the \'new\' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn\'t have one\n\tthis.timeStamp = src && src.timeStamp || Date.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t"char": true,\n\tcode: true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\twhich: true\n}, jQuery.event.addProp );\n\njQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {\n\tjQuery.event.special[ type ] = {\n\n\t\t// Utilize native event if possible so blur/focus sequence is correct\n\t\tsetup: function() {\n\n\t\t\t// Claim the first handler\n\t\t\t// dataPriv.set( this, "focus", ... )\n\t\t\t// dataPriv.set( this, "blur", ... )\n\t\t\tleverageNative( this, type, expectSync );\n\n\t\t\t// Return false to allow normal processing in the caller\n\t\t\treturn false;\n\t\t},\n\t\ttrigger: function() {\n\n\t\t\t// Force setup before trigger\n\t\t\tleverageNative( this, type );\n\n\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\treturn true;\n\t\t},\n\n\t\t// Suppress native focus or blur as it\'s already being fired\n\t\t// in leverageNative.\n\t\t_default: function() {\n\t\t\treturn true;\n\t\t},\n\n\t\tdelegateType: delegateType\n\t};\n} );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: "mouseover",\n\tmouseleave: "mouseout",\n\tpointerenter: "pointerover",\n\tpointerleave: "pointerout"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + "." + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === "object" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === "function" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t// Support: IE <=10 - 11, Edge 12 - 13 only\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked="checked" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, "table" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {\n\n\t\treturn jQuery( elem ).children( "tbody" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tif ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {\n\t\telem.type = elem.type.slice( 5 );\n\t} else {\n\t\telem.removeAttribute( "type" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.get( src );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdataPriv.remove( dest, "handle events" );\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === "input" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === "input" || nodeName === "textarea" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = flat( args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tvalueIsFunction = isFunction( value );\n\n\t// We can\'t cloneNode fragments that contain checked, in WebKit\n\tif ( valueIsFunction ||\n\t\t\t( l > 1 && typeof value === "string" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, "script" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, "script" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || "" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, "globalEval" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won\'t run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl && !node.noModule ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src, {\n\t\t\t\t\t\t\t\t\tnonce: node.nonce || node.getAttribute( "nonce" )\n\t\t\t\t\t\t\t\t}, doc );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && isAttached( node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, "script" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html;\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = isAttached( elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, "script" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, "script" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove\'s overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = "";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === "string" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: "append",\n\tprependTo: "prepend",\n\tinsertBefore: "before",\n\tinsertAfter: "after",\n\treplaceAll: "replaceWith"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar swap = function( elem, options, callback ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.call( elem );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they\'re executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.style.cssText = "position:absolute;left:-11111px;width:60px;" +\n\t\t\t"margin-top:1px;padding:0;border:0";\n\t\tdiv.style.cssText =\n\t\t\t"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +\n\t\t\t"margin:auto;border:1px;padding:1px;" +\n\t\t\t"width:60%;top:1%";\n\t\tdocumentElement.appendChild( container ).appendChild( div );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== "1%";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n\n\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n\t\t// Some styles come back with percentage values, even though they shouldn\'t\n\t\tdiv.style.right = "60%";\n\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n\n\t\t// Support: IE 9 - 11 only\n\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n\n\t\t// Support: IE 9 only\n\t\t// Detect overflow:scroll screwiness (gh-3699)\n\t\t// Support: Chrome <=64\n\t\t// Don\'t get tricked when zoom affects offsetWidth (gh-4029)\n\t\tdiv.style.position = "absolute";\n\t\tscrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn\'t be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tfunction roundPixelMeasures( measure ) {\n\t\treturn Math.round( parseFloat( measure ) );\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n\t\treliableTrDimensionsVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( "div" ),\n\t\tdiv = document.createElement( "div" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = "content-box";\n\tdiv.cloneNode( true ).style.backgroundClip = "";\n\tsupport.clearCloneStyle = div.style.backgroundClip === "content-box";\n\n\tjQuery.extend( support, {\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelBoxStyles: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelBoxStylesVal;\n\t\t},\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\tscrollboxSize: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn scrollboxSizeVal;\n\t\t},\n\n\t\t// Support: IE 9 - 11+, Edge 15 - 18+\n\t\t// IE/Edge misreport `getComputedStyle` of table rows with width/height\n\t\t// set in CSS while `offset*` properties report correct values.\n\t\t// Behavior in IE 9 is more subtle than in newer versions & it passes\n\t\t// some versions of this test; make sure not to make it pass there!\n\t\t//\n\t\t// Support: Firefox 70+\n\t\t// Only Firefox includes border widths\n\t\t// in computed dimensions. (gh-4529)\n\t\treliableTrDimensions: function() {\n\t\t\tvar table, tr, trChild, trStyle;\n\t\t\tif ( reliableTrDimensionsVal == null ) {\n\t\t\t\ttable = document.createElement( "table" );\n\t\t\t\ttr = document.createElement( "tr" );\n\t\t\t\ttrChild = document.createElement( "div" );\n\n\t\t\t\ttable.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";\n\t\t\t\ttr.style.cssText = "border:1px solid";\n\n\t\t\t\t// Support: Chrome 86+\n\t\t\t\t// Height set through cssText does not get applied.\n\t\t\t\t// Computed height then comes back as 0.\n\t\t\t\ttr.style.height = "1px";\n\t\t\t\ttrChild.style.height = "9px";\n\n\t\t\t\t// Support: Android 8 Chrome 86+\n\t\t\t\t// In our bodyBackground.html iframe,\n\t\t\t\t// display for all div elements is set to "inline",\n\t\t\t\t// which causes a problem only in Android 8 Chrome 86.\n\t\t\t\t// Ensuring the div is display: block\n\t\t\t\t// gets around this issue.\n\t\t\t\ttrChild.style.display = "block";\n\n\t\t\t\tdocumentElement\n\t\t\t\t\t.appendChild( table )\n\t\t\t\t\t.appendChild( tr )\n\t\t\t\t\t.appendChild( trChild );\n\n\t\t\t\ttrStyle = window.getComputedStyle( tr );\n\t\t\t\treliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +\n\t\t\t\t\tparseInt( trStyle.borderTopWidth, 10 ) +\n\t\t\t\t\tparseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;\n\n\t\t\t\tdocumentElement.removeChild( table );\n\t\t\t}\n\t\t\treturn reliableTrDimensionsVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css(\'filter\') (IE 9 only, #12537)\n\t//   .css(\'--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === "" && !isAttached( elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the "awesome hack by Dean Edwards"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + "" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we\'ll check on the first run if it\'s really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it\'s not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar cssPrefixes = [ "Webkit", "Moz", "ms" ],\n\temptyStyle = document.createElement( "div" ).style,\n\tvendorProps = {};\n\n// Return a vendor-prefixed property or undefined\nfunction vendorPropName( name ) {\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a potentially-mapped jQuery.cssProps or vendor prefixed property\nfunction finalPropName( name ) {\n\tvar final = jQuery.cssProps[ name ] || vendorProps[ name ];\n\n\tif ( final ) {\n\t\treturn final;\n\t}\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\treturn vendorProps[ name ] = vendorPropName( name ) || name;\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except "table", "table-cell", or "table-caption"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: "absolute", visibility: "hidden", display: "block" },\n\tcssNormalTransform = {\n\t\tletterSpacing: "0",\n\t\tfontWeight: "400"\n\t};\n\nfunction setPositiveNumber( _elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined "subtract", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :\n\t\tvalue;\n}\n\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n\tvar i = dimension === "width" ? 1 : 0,\n\t\textra = 0,\n\t\tdelta = 0;\n\n\t// Adjustment may not be necessary\n\tif ( box === ( isBorderBox ? "border" : "content" ) ) {\n\t\treturn 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin\n\t\tif ( box === "margin" ) {\n\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\t// If we get here with a content-box, we\'re seeking "padding" or "border" or "margin"\n\t\tif ( !isBorderBox ) {\n\n\t\t\t// Add padding\n\t\t\tdelta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\n\t\t\t// For "border" or "margin", add border\n\t\t\tif ( box !== "padding" ) {\n\t\t\t\tdelta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n\n\t\t\t// But still keep track of it otherwise\n\t\t\t} else {\n\t\t\t\textra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n\t\t\t}\n\n\t\t// If we get here with a border-box (content + padding + border), we\'re seeking "content" or\n\t\t// "padding" or "margin"\n\t\t} else {\n\n\t\t\t// For "content", subtract padding\n\t\t\tif ( box === "content" ) {\n\t\t\t\tdelta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// For "content" or "padding", subtract border\n\t\t\tif ( box !== "margin" ) {\n\t\t\t\tdelta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Account for positive content-box scroll gutter when requested by providing computedVal\n\tif ( !isBorderBox && computedVal >= 0 ) {\n\n\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n\t\t// Assuming integer scroll gutter, subtract the rest and round down\n\t\tdelta += Math.max( 0, Math.ceil(\n\t\t\telem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\tcomputedVal -\n\t\t\tdelta -\n\t\t\textra -\n\t\t\t0.5\n\n\t\t// If offsetWidth/offsetHeight is unknown, then we can\'t determine content-box scroll gutter\n\t\t// Use an explicit zero to avoid NaN (gh-3964)\n\t\t) ) || 0;\n\t}\n\n\treturn delta;\n}\n\nfunction getWidthOrHeight( elem, dimension, extra ) {\n\n\t// Start with computed style\n\tvar styles = getStyles( elem ),\n\n\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n\t\t// Fake content-box until we know it\'s needed to know the true value.\n\t\tboxSizingNeeded = !support.boxSizingReliable() || extra,\n\t\tisBorderBox = boxSizingNeeded &&\n\t\t\tjQuery.css( elem, "boxSizing", false, styles ) === "border-box",\n\t\tvalueIsBorderBox = isBorderBox,\n\n\t\tval = curCSS( elem, dimension, styles ),\n\t\toffsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );\n\n\t// Support: Firefox <=54\n\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n\tif ( rnumnonpx.test( val ) ) {\n\t\tif ( !extra ) {\n\t\t\treturn val;\n\t\t}\n\t\tval = "auto";\n\t}\n\n\n\t// Support: IE 9 - 11 only\n\t// Use offsetWidth/offsetHeight for when box sizing is unreliable.\n\t// In those cases, the computed value can be trusted to be border-box.\n\tif ( ( !support.boxSizingReliable() && isBorderBox ||\n\n\t\t// Support: IE 10 - 11+, Edge 15 - 18+\n\t\t// IE/Edge misreport `getComputedStyle` of table rows with width/height\n\t\t// set in CSS while `offset*` properties report correct values.\n\t\t// Interestingly, in some cases IE 9 doesn\'t suffer from this issue.\n\t\t!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||\n\n\t\t// Fall back to offsetWidth/offsetHeight when value is "auto"\n\t\t// This happens for inline elements with no explicit setting (gh-3571)\n\t\tval === "auto" ||\n\n\t\t// Support: Android <=4.1 - 4.3 only\n\t\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n\t\t!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&\n\n\t\t// Make sure the element is visible & connected\n\t\telem.getClientRects().length ) {\n\n\t\tisBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";\n\n\t\t// Where available, offsetWidth/offsetHeight approximate border box dimensions.\n\t\t// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n\t\t// retrieved value as a content box dimension.\n\t\tvalueIsBorderBox = offsetProp in elem;\n\t\tif ( valueIsBorderBox ) {\n\t\t\tval = elem[ offsetProp ];\n\t\t}\n\t}\n\n\t// Normalize "" and auto\n\tval = parseFloat( val ) || 0;\n\n\t// Adjust for the element\'s box model\n\treturn ( val +\n\t\tboxModelAdjustment(\n\t\t\telem,\n\t\t\tdimension,\n\t\t\textra || ( isBorderBox ? "border" : "content" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles,\n\n\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n\t\t\tval\n\t\t)\n\t) + "px";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, "opacity" );\n\t\t\t\t\treturn ret === "" ? "1" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don\'t automatically add "px" to these possibly-unitless properties\n\tcssNumber: {\n\t\t"animationIterationCount": true,\n\t\t"columnCount": true,\n\t\t"fillOpacity": true,\n\t\t"flexGrow": true,\n\t\t"flexShrink": true,\n\t\t"fontWeight": true,\n\t\t"gridArea": true,\n\t\t"gridColumn": true,\n\t\t"gridColumnEnd": true,\n\t\t"gridColumnStart": true,\n\t\t"gridRow": true,\n\t\t"gridRowEnd": true,\n\t\t"gridRowStart": true,\n\t\t"lineHeight": true,\n\t\t"opacity": true,\n\t\t"order": true,\n\t\t"orphans": true,\n\t\t"widows": true,\n\t\t"zIndex": true,\n\t\t"zoom": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don\'t set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we\'re working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we\'re working with the right name. We don\'t\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we\'re setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert "+=" or "-=" to relative numbers (#7345)\n\t\t\tif ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = "number";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren\'t set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\t// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n\t\t\t// "px" to a few hardcoded values.\n\t\t\tif ( type === "number" && !isCustomProp ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone\'s values\n\t\t\tif ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {\n\t\t\t\tstyle[ name ] = "inherit";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( "set" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && "get" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we\'re working with the right name. We don\'t\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && "get" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert "normal" to computed value\n\t\tif ( val === "normal" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === "" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ "height", "width" ], function( _i, dimension ) {\n\tjQuery.cssHooks[ dimension ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, "display" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n\t\t\t\t\t} ) :\n\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = getStyles( elem ),\n\n\t\t\t\t// Only read styles.position if the test has a chance to fail\n\t\t\t\t// to avoid forcing a reflow.\n\t\t\t\tscrollboxSizeBuggy = !support.scrollboxSize() &&\n\t\t\t\t\tstyles.position === "absolute",\n\n\t\t\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n\t\t\t\tboxSizingNeeded = scrollboxSizeBuggy || extra,\n\t\t\t\tisBorderBox = boxSizingNeeded &&\n\t\t\t\t\tjQuery.css( elem, "boxSizing", false, styles ) === "border-box",\n\t\t\t\tsubtract = extra ?\n\t\t\t\t\tboxModelAdjustment(\n\t\t\t\t\t\telem,\n\t\t\t\t\t\tdimension,\n\t\t\t\t\t\textra,\n\t\t\t\t\t\tisBorderBox,\n\t\t\t\t\t\tstyles\n\t\t\t\t\t) :\n\t\t\t\t\t0;\n\n\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n\t\t\t// faking a content-box to get border and padding (gh-3699)\n\t\t\tif ( isBorderBox && scrollboxSizeBuggy ) {\n\t\t\t\tsubtract -= Math.ceil(\n\t\t\t\t\telem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n\t\t\t\t\tboxModelAdjustment( elem, dimension, "border", false, styles ) -\n\t\t\t\t\t0.5\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || "px" ) !== "px" ) {\n\n\t\t\t\telem.style[ dimension ] = value;\n\t\t\t\tvalue = jQuery.css( elem, dimension );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, "marginLeft" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t) + "px";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: "",\n\tpadding: "",\n\tborder: "Width"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === "string" ? value.split( " " ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( prefix !== "margin" ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as "10px" are parsed to Float;\n\t\t\t// complex values such as "rotate(1rad)" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, "" );\n\n\t\t\t// Empty strings, null, undefined and "auto" are converted to 0.\n\t\t\treturn !result || result === "auto" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 && (\n\t\t\t\tjQuery.cssHooks[ tween.prop ] ||\n\t\t\t\t\ttween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: "swing"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = Date.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ "margin" + which ] = attrs[ "padding" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We\'re done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = "width" in props || "height" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, "fxshow" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, "fx" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, "fx" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === "toggle";\n\t\t\tif ( value === ( hidden ? "hide" : "show" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a "show" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict "overflow" and "display" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 15\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n\t\t// the overflowX value there.\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, "display" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, "display" );\n\t\tif ( display === "none" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, "display" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, "float" ) === "none" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === "none" ? "" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = "inline-block";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = "hidden";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( "hidden" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` "reverses"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a "hide" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, "fxshow" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && "expand" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won\'t overwrite existing keys.\n\t\t\t// Reusing \'index\' because we have the correct "name"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don\'t match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won\'t allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there\'s more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tresult.stop.bind( result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t"*": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ "*" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tisFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== "number" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> "fx"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = "fx";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won\'t be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, "finish" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\n\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue ) {\n\t\t\tthis.queue( type || "fx", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + "queueHooks",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn\'t forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || "fx";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + "queue" ],\n\t\t\t\thooks = data[ type + "queueHooks" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === "boolean" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( "show" ),\n\tslideUp: genFx( "hide" ),\n\tslideToggle: genFx( "toggle" ),\n\tfadeIn: { opacity: "show" },\n\tfadeOut: { opacity: "hide" },\n\tfadeToggle: { opacity: "toggle" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = Date.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || "fx";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( "input" ),\n\t\tselect = document.createElement( "select" ),\n\t\topt = select.appendChild( document.createElement( "option" ) );\n\n\tinput.type = "checkbox";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be "on"\n\tsupport.checkOn = input.value !== "";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( "input" );\n\tinput.value = "t";\n\tinput.type = "radio";\n\tsupport.radioValue = input.value === "t";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don\'t get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === "undefined" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && "set" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + "" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === "radio" &&\n\t\t\t\t\tnodeName( elem, "input" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( "type", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( _i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don\'t get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && "set" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn\'t always return the\n\t\t\t\t// correct value when it hasn\'t been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, "tabindex" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t"for": "htmlFor",\n\t\t"class": "className"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule "no-unused-expressions" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: "off" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: "off" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t"tabIndex",\n\t"readOnly",\n\t"maxLength",\n\t"cellSpacing",\n\t"cellPadding",\n\t"rowSpan",\n\t"colSpan",\n\t"useMap",\n\t"frameBorder",\n\t"contentEditable"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( " " );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( "class" ) || "";\n}\n\nfunction classesToArray( value ) {\n\tif ( Array.isArray( value ) ) {\n\t\treturn value;\n\t}\n\tif ( typeof value === "string" ) {\n\t\treturn value.match( rnothtmlwhite ) || [];\n\t}\n\treturn [];\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( " " + clazz + " " ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + " ";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( "class", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( "class", "" );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( " " + clazz + " " ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( " " + clazz + " ", " " );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( "class", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisValidValue = type === "string" || Array.isArray( value );\n\n\t\tif ( typeof stateVal === "boolean" && isValidValue ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( isValidValue ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = classesToArray( value );\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === "boolean" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, "__className__", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we\'re passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( "class",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\t"" :\n\t\t\t\t\t\t\tdataPriv.get( this, "__className__" ) || ""\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = " " + selector + " ";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, valueIsFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t"get" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, "value" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === "string" ) {\n\t\t\t\t\treturn ret.replace( rreturn, "" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? "" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueIsFunction = isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as ""; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = "";\n\n\t\t\t} else if ( typeof val === "number" ) {\n\t\t\t\tval += "";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? "" : value + "";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, "value" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === "select-one",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn\'t update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don\'t return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, "optgroup" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don\'t need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ "radio", "checkbox" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( "value" ) === null ? "on" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nsupport.focusin = "onfocusin" in window;\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\tstopPropagationCallback = function( e ) {\n\t\te.stopPropagation();\n\t};\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, "type" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];\n\n\t\tcur = lastElement = tmp = elem = elem || document;\n\n\t\t// Don\'t do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we\'re not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( "." ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( "." );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( ":" ) < 0 && "on" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === "object" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( "." );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( "(^|\\\\.)" + namespaces.join( "\\\\.(?:.*\\\\.|)" ) + "(\\\\.|$)" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tlastElement = cur;\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, "handle" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don\'t do default actions on window, that\'s where global variables be (#6170)\n\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n\n\t\t\t\t\t// Don\'t re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\telem[ type ]();\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\n// Support: Firefox <=44\n// Firefox doesn\'t have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\n\t\t\t\t// Handle: regular nodes (via `this.ownerDocument`), window\n\t\t\t\t// (via `this.document`) & document (via `this`).\n\t\t\t\tvar doc = this.ownerDocument || this.document || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this.document || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = { guid: Date.now() };\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml, parserErrorElem;\n\tif ( !data || typeof data !== "string" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );\n\t} catch ( e ) {}\n\n\tparserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];\n\tif ( !xml || parserErrorElem ) {\n\t\tjQuery.error( "Invalid XML: " + (\n\t\t\tparserErrorElem ?\n\t\t\t\tjQuery.map( parserErrorElem.childNodes, function( el ) {\n\t\t\t\t\treturn el.textContent;\n\t\t\t\t} ).join( "\\n" ) :\n\t\t\t\tdata\n\t\t) );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && toType( obj ) === "object" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + "=" +\n\t\t\t\tencodeURIComponent( value == null ? "" : value );\n\t\t};\n\n\tif ( a == null ) {\n\t\treturn "";\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the "old" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( "&" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for "elements" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, "elements" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} ).filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( ":disabled" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( ":disabled" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} ).map( function( _i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol "*" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to "*" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol "*" can be used\n\t * 3) selection will start with transport dataType and THEN go to "*" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = "*/".concat( "*" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( "a" );\n\noriginAnchor.href = location.href;\n\n// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to "*"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== "string" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = "*";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === "+" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || "*";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === "string" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );\n}\n\n// A special extend for ajax options\n// that takes "flat" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === "*" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );\n\t\t}\n\t}\n\n\t// Check if we\'re dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There\'s only work to do if current dataType is non-auto\n\t\t\tif ( current === "*" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== "*" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + " " + current ] || converters[ "* " + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( " " );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + " " + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ "* " + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: "parsererror",\n\t\t\t\t\t\t\t\terror: conv ? e : "No conversion from " + prev + " to " + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: "success", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: "GET",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: "application/x-www-form-urlencoded; charset=UTF-8",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t"*": allTypes,\n\t\t\ttext: "text/plain",\n\t\t\thtml: "text/html",\n\t\t\txml: "application/xml, text/xml",\n\t\t\tjson: "application/json, text/javascript"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: "responseXML",\n\t\t\ttext: "responseText",\n\t\t\tjson: "responseJSON"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall "*") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t"* text": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t"text html": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t"text json": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t"text xml": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn\'t be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn\'t be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === "object" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( "once memory" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = "canceled",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() + " " ] =\n\t\t\t\t\t\t\t\t\t( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )\n\t\t\t\t\t\t\t\t\t\t.concat( match[ 2 ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() + " " ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match.join( ", " );\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + "" )\n\t\t\t.replace( rprotocol, location.protocol + "//" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];\n\n\t\t// A cross-domain request is in order when the origin doesn\'t match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( "a" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor\'s host property isn\'t correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + "//" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== "string" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don\'t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( "ajaxStart" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we\'re toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, "" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available and should be processed, append data to url\n\t\t\tif ( s.data && ( s.processData || typeof s.data === "string" ) ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it\'s not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, "$1" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +\n\t\t\t\t\tuncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change \'%20\' to \'+\' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, "+" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( "Content-Type", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t"Accept",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :\n\t\t\t\ts.accepts[ "*" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = "abort";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, "No Transport" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( "timeout" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || "";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Use a noop converter for missing script but not if jsonp\n\t\t\tif ( !isSuccess &&\n\t\t\t\tjQuery.inArray( "script", s.dataTypes ) > -1 &&\n\t\t\t\tjQuery.inArray( "json", s.dataTypes ) < 0 ) {\n\t\t\t\ts.converters[ "text script" ] = function() {};\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( "Last-Modified" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( "etag" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === "HEAD" ) {\n\t\t\t\t\tstatusText = "nocontent";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = "notmodified";\n\n\t\t\t\t// If we have data, let\'s convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = "error";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + "";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( "ajaxStop" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, "json" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, "script" );\n\t}\n} );\n\njQuery.each( [ "get", "post" ], function( _i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\njQuery.ajaxPrefilter( function( s ) {\n\tvar i;\n\tfor ( i in s.headers ) {\n\t\tif ( i.toLowerCase() === "content-type" ) {\n\t\t\ts.contentType = s.headers[ i ] || "";\n\t\t}\n\t}\n} );\n\n\njQuery._evalUrl = function( url, options, doc ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: "GET",\n\t\tdataType: "script",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\n\t\t// Only evaluate the response if it is successful (gh-4126)\n\t\t// dataFilter is not invoked for failure responses, so using it instead\n\t\t// of the default converter is kludgy but it works.\n\t\tconverters: {\n\t\t\t"text script": function() {}\n\t\t},\n\t\tdataFilter: function( response ) {\n\t\t\tjQuery.globalEval( response, options, doc );\n\t\t}\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar htmlIsFunction = isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( "body" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won\'t change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {\n\t\t\t\t\theaders[ "X-Requested-With" ] = "XMLHttpRequest";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === "abort" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === "error" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== "number" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, "error" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || "text" ) !== "text"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== "string" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( "abort" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn\'t been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: "text/javascript, application/javascript, " +\n\t\t\t"application/ecmascript, application/x-ecmascript"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t"text script": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache\'s special case and crossDomain\njQuery.ajaxPrefilter( "script", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = "GET";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( "script", function( s ) {\n\n\t// This transport only deals with cross domain or forced-by-attrs requests\n\tif ( s.crossDomain || s.scriptAttrs ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( "<script>" )\n\t\t\t\t\t.attr( s.scriptAttrs || {} )\n\t\t\t\t\t.prop( { charset: s.scriptCharset, src: s.url } )\n\t\t\t\t\t.on( "load error", callback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === "error" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: "callback",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t"url" :\n\t\t\ttypeof s.data === "string" &&\n\t\t\t\t( s.contentType || "" )\n\t\t\t\t\t.indexOf( "application/x-www-form-urlencoded" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && "data"\n\t\t);\n\n\t// Handle iff the expected data type is "jsonp" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ "script json" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + " was not called" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = "json";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn\'t exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn\'t screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn "script";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( "" ).body;\n\tbody.innerHTML = "<form></form><form></form>";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument "data" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== "string" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === "boolean" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( "" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document\'s URL (gh-2965)\n\t\t\tbase = context.createElement( "base" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( " " );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it\'s a function\n\tif ( isFunction( params ) ) {\n\n\t\t// We assume that it\'s the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === "object" ) {\n\t\ttype = "POST";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If "type" variable is undefined, then "GET" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || "GET",\n\t\t\tdataType: "html",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE \'Permission Denied\' errors\n\t\t\t\tjQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets "data", "status", "jqXHR"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets "jqXHR", "status", "error"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, "position" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === "static" ) {\n\t\t\telem.style.position = "relative";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, "top" );\n\t\tcurCSSLeft = jQuery.css( elem, "left" );\n\t\tcalculatePosition = ( position === "absolute" || position === "fixed" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( "using" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\n\t// offset() relates an element\'s border box to the document origin\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\t\trect = elem.getBoundingClientRect();\n\t\twin = elem.ownerDocument.defaultView;\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset,\n\t\t\tleft: rect.left + win.pageXOffset\n\t\t};\n\t},\n\n\t// position() relates an element\'s margin box to its offset parent\'s padding box\n\t// This corresponds to the behavior of CSS absolute positioning\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset, doc,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n\t\tif ( jQuery.css( elem, "position" ) === "fixed" ) {\n\n\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\toffset = this.offset();\n\n\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n\t\t\t// when a statically positioned element is identified\n\t\t\tdoc = elem.ownerDocument;\n\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n\t\t\twhile ( offsetParent &&\n\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n\t\t\t\tjQuery.css( offsetParent, "position" ) === "static" ) {\n\n\t\t\t\toffsetParent = offsetParent.parentNode;\n\t\t\t}\n\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n\n\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );\n\t\t\t}\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {\n\tvar top = "pageYOffset" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ "top", "left" ], function( _i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + "px" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: "height", Width: "width" }, function( name, type ) {\n\tjQuery.each( {\n\t\tpadding: "inner" + name,\n\t\tcontent: type,\n\t\t"": "outer" + name\n\t}, function( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( "outer" ) === 0 ?\n\t\t\t\t\t\telem[ "inner" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ "client" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ "scroll" + name ], doc[ "scroll" + name ],\n\t\t\t\t\t\telem.body[ "offset" + name ], doc[ "offset" + name ],\n\t\t\t\t\t\tdoc[ "client" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.each( [\n\t"ajaxStart",\n\t"ajaxStop",\n\t"ajaxComplete",\n\t"ajaxError",\n\t"ajaxSuccess",\n\t"ajaxSend"\n], function( _i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, "**" ) :\n\t\t\tthis.off( types, selector || "**", fn );\n\t},\n\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\njQuery.each(\n\t( "blur focus focusin focusout resize scroll click dblclick " +\n\t"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +\n\t"change select submit keydown keypress keyup contextmenu" ).split( " " ),\n\tfunction( _i, name ) {\n\n\t\t// Handle event binding\n\t\tjQuery.fn[ name ] = function( data, fn ) {\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\tthis.on( name, null, data, fn ) :\n\t\t\t\tthis.trigger( name );\n\t\t};\n\t}\n);\n\n\n\n\n// Support: Android <=4.0 only\n// Make sure we trim BOM and NBSP\nvar rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\n// Bind a function to a context, optionally partially applying any\n// arguments.\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n// However, it is not slated for removal any time soon\njQuery.proxy = function( fn, context ) {\n\tvar tmp, args, proxy;\n\n\tif ( typeof context === "string" ) {\n\t\ttmp = fn[ context ];\n\t\tcontext = fn;\n\t\tfn = tmp;\n\t}\n\n\t// Quick check to determine if target is callable, in the spec\n\t// this throws a TypeError, but we will just return undefined.\n\tif ( !isFunction( fn ) ) {\n\t\treturn undefined;\n\t}\n\n\t// Simulated bind\n\targs = slice.call( arguments, 2 );\n\tproxy = function() {\n\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t};\n\n\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\treturn proxy;\n};\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\njQuery.isFunction = isFunction;\njQuery.isWindow = isWindow;\njQuery.camelCase = camelCase;\njQuery.type = toType;\n\njQuery.now = Date.now;\n\njQuery.isNumeric = function( obj ) {\n\n\t// As of jQuery 3.0, isNumeric is limited to\n\t// strings and numbers (primitives or objects)\n\t// that can be coerced to finite numbers (gh-2662)\n\tvar type = jQuery.type( obj );\n\treturn ( type === "number" || type === "string" ) &&\n\n\t\t// parseFloat NaNs numeric-cast false positives ("")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals ("0x...")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN( obj - parseFloat( obj ) );\n};\n\njQuery.trim = function( text ) {\n\treturn text == null ?\n\t\t"" :\n\t\t( text + "" ).replace( rtrim, "" );\n};\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\treturn jQuery;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === "undefined" ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzP2E4ODEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjYuMFxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDIxLTAzLTAyVDE3OjA4WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBmbGF0ID0gYXJyLmZsYXQgPyBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuZmxhdC5jYWxsKCBhcnJheSApO1xufSA6IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0cmV0dXJuIGFyci5jb25jYXQuYXBwbHkoIFtdLCBhcnJheSApO1xufTtcblxuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuXHRcdC8vIEluIHNvbWUgYnJvd3NlcnMsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCA8b2JqZWN0PiBlbGVtZW50c1xuXHRcdC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG5cdFx0Ly8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuXHRcdC8vIFN1cHBvcnQ6IFF0V2ViIDw9My44LjUsIFdlYktpdCA8PTUzNC4zNCwgd2todG1sdG9wZGYgdG9vbCA8PTAuMTIuNVxuXHRcdC8vIFBsdXMgZm9yIG9sZCBXZWJLaXQsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCBjb2xsZWN0aW9uc1xuXHRcdC8vIChlLmcuLCBgdHlwZW9mIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGl2XCIpID09PSBcImZ1bmN0aW9uXCJgKS4gKGdoLTQ3NTYpXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiICYmXG5cdFx0XHR0eXBlb2Ygb2JqLml0ZW0gIT09IFwiZnVuY3Rpb25cIjtcblx0fTtcblxuXG52YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH07XG5cblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG5cblxuXHR2YXIgcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyA9IHtcblx0XHR0eXBlOiB0cnVlLFxuXHRcdHNyYzogdHJ1ZSxcblx0XHRub25jZTogdHJ1ZSxcblx0XHRub01vZHVsZTogdHJ1ZVxuXHR9O1xuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIG5vZGUsIGRvYyApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgaSwgdmFsLFxuXHRcdFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHRmb3IgKCBpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA2NCssIEVkZ2UgMTgrXG5cdFx0XHRcdC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgXCJub25jZVwiIHByb3BlcnR5IG9uIHNjcmlwdHMuXG5cdFx0XHRcdC8vIE9uIHRoZSBvdGhlciBoYW5kLCBqdXN0IHVzaW5nIGBnZXRBdHRyaWJ1dGVgIGlzIG5vdCBlbm91Z2ggYXNcblx0XHRcdFx0Ly8gdGhlIGBub25jZWAgYXR0cmlidXRlIGlzIHJlc2V0IHRvIGFuIGVtcHR5IHN0cmluZyB3aGVuZXZlciBpdFxuXHRcdFx0XHQvLyBiZWNvbWVzIGJyb3dzaW5nLWNvbnRleHQgY29ubmVjdGVkLlxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9odG1sL2lzc3Vlcy8yMzY5XG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNub25jZS1hdHRyaWJ1dGVzXG5cdFx0XHRcdC8vIFRoZSBgbm9kZS5nZXRBdHRyaWJ1dGVgIGNoZWNrIHdhcyBhZGRlZCBmb3IgdGhlIHNha2Ugb2Zcblx0XHRcdFx0Ly8gYGpRdWVyeS5nbG9iYWxFdmFsYCBzbyB0aGF0IGl0IGNhbiBmYWtlIGEgbm9uY2UtY29udGFpbmluZyBub2RlXG5cdFx0XHRcdC8vIHZpYSBhbiBvYmplY3QuXG5cdFx0XHRcdHZhbCA9IG5vZGVbIGkgXSB8fCBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSggaSApO1xuXHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKCBpLCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cblxuXG5mdW5jdGlvbiB0b1R5cGUoIG9iaiApIHtcblx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0dHlwZW9mIG9iajtcbn1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjMuNi4wXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRldmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gKCBpICsgMSApICUgMjtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRvZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LmdyZXAoIHRoaXMsIGZ1bmN0aW9uKCBfZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBpICUgMjtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgT2JqZWN0LnByb3RvdHlwZSBwb2xsdXRpb25cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIG5hbWUgPT09IFwiX19wcm90b19fXCIgfHwgdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXHRcdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXG5cdFx0XHRcdFx0Ly8gRW5zdXJlIHByb3BlciB0eXBlIGZvciB0aGUgc291cmNlIHZhbHVlXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSAmJiAhQXJyYXkuaXNBcnJheSggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IFtdO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICFjb3B5SXNBcnJheSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSB7fTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgcHJvdmlkZWQgY29udGV4dDsgZmFsbHMgYmFjayB0byB0aGUgZ2xvYmFsIG9uZVxuXHQvLyBpZiBub3Qgc3BlY2lmaWVkLlxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSwgb3B0aW9ucywgZG9jICkge1xuXHRcdERPTUV2YWwoIGNvZGUsIHsgbm9uY2U6IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZSB9LCBkb2MgKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBmbGF0KCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHRcdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjZcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xuICpcbiAqIERhdGU6IDIwMjEtMDItMTZcbiAqL1xuKCBmdW5jdGlvbiggd2luZG93ICkge1xudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKCB7fSApLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaE5hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFsgaSBdID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58XCIgK1xuXHRcdFwiaXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3Mtc3ludGF4LTMvI2lkZW50LXRva2VuLWRpYWdyYW1cblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiP3xcXFxcXFxcXFteXFxcXHJcXFxcblxcXFxmXXxbXFxcXHctXXxbXlxcMC1cXFxceDdmXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV1cblx0XHQvLyBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArXG5cdFx0d2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcIiApLFxuXHRyZGVzY2VuZCA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcInw+XCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaHRtbCA9IC9IVE1MJC9pLFxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3xcXFxcXFxcXChbXlxcXFxyXFxcXG5cXFxcZl0pXCIsIFwiZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBlc2NhcGUsIG5vbkhleCApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZS5zbGljZSggMSApIC0gMHgxMDAwMDtcblxuXHRcdHJldHVybiBub25IZXggP1xuXG5cdFx0XHQvLyBTdHJpcCB0aGUgYmFja3NsYXNoIHByZWZpeCBmcm9tIGEgbm9uLWhleCBlc2NhcGUgc2VxdWVuY2Vcblx0XHRcdG5vbkhleCA6XG5cblx0XHRcdC8vIFJlcGxhY2UgYSBoZXhhZGVjaW1hbCBlc2NhcGUgc2VxdWVuY2Ugd2l0aCB0aGUgZW5jb2RlZCBVbmljb2RlIGNvZGUgcG9pbnRcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTErXG5cdFx0XHQvLyBGb3IgdmFsdWVzIG91dHNpZGUgdGhlIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZSAoQk1QKSwgbWFudWFsbHkgY29uc3RydWN0IGFcblx0XHRcdC8vIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICtcblx0XHRcdFx0Y2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGluRGlzYWJsZWRGaWVsZHNldCA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZmllbGRzZXRcIjtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdCggYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSApLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoTmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoIGVscyApICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAoIHRhcmdldFsgaisrIF0gPSBlbHNbIGkrKyBdICkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKCBtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKCBtID0gbWF0Y2hbIDEgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmICggZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbIDIgXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKCBtID0gbWF0Y2hbIDMgXSApICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCggIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkgKSAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDggb25seVxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHQoIG5vZGVUeXBlICE9PSAxIHx8IGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApICkge1xuXG5cdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXG5cdFx0XHRcdC8vIHFTQSBjb25zaWRlcnMgZWxlbWVudHMgb3V0c2lkZSBhIHNjb3Bpbmcgcm9vdCB3aGVuIGV2YWx1YXRpbmcgY2hpbGQgb3Jcblx0XHRcdFx0Ly8gZGVzY2VuZGFudCBjb21iaW5hdG9ycywgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudC5cblx0XHRcdFx0Ly8gSW4gc3VjaCBjYXNlcywgd2Ugd29yayBhcm91bmQgdGhlIGJlaGF2aW9yIGJ5IHByZWZpeGluZyBldmVyeSBzZWxlY3RvciBpbiB0aGVcblx0XHRcdFx0Ly8gbGlzdCB3aXRoIGFuIElEIHNlbGVjdG9yIHJlZmVyZW5jaW5nIHRoZSBzY29wZSBjb250ZXh0LlxuXHRcdFx0XHQvLyBUaGUgdGVjaG5pcXVlIGhhcyB0byBiZSB1c2VkIGFzIHdlbGwgd2hlbiBhIGxlYWRpbmcgY29tYmluYXRvciBpcyB1c2VkXG5cdFx0XHRcdC8vIGFzIHN1Y2ggc2VsZWN0b3JzIGFyZSBub3QgcmVjb2duaXplZCBieSBxdWVyeVNlbGVjdG9yQWxsLlxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB0ZWNobmlxdWUuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIHJkZXNjZW5kLnRlc3QoIHNlbGVjdG9yICkgfHwgcmNvbWJpbmF0b3JzLnRlc3QoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblxuXHRcdFx0XHRcdC8vIFdlIGNhbiB1c2UgOnNjb3BlIGluc3RlYWQgb2YgdGhlIElEIGhhY2sgaWYgdGhlIGJyb3dzZXJcblx0XHRcdFx0XHQvLyBzdXBwb3J0cyBpdCAmIGlmIHdlJ3JlIG5vdCBjaGFuZ2luZyB0aGUgY29udGV4dC5cblx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgIT09IGNvbnRleHQgfHwgIXN1cHBvcnQuc2NvcGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0XHRpZiAoICggbmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApICkgKSB7XG5cdFx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAoIG5pZCA9IGV4cGFuZG8gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzWyBpIF0gPSAoIG5pZCA/IFwiI1wiICsgbmlkIDogXCI6c2NvcGVcIiApICsgXCIgXCIgK1xuXHRcdFx0XHRcdFx0XHR0b1NlbGVjdG9yKCBncm91cHNbIGkgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblxuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKCBjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlICk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblxuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KCBcInxcIiApLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyWyBpIF0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIubmV4dFNpYmxpbmcgKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAoIG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiICkgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0aW5EaXNhYmxlZEZpZWxkc2V0KCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoIGogPSBtYXRjaEluZGV4ZXNbIGkgXSApIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFsgaiBdID0gISggbWF0Y2hlc1sgaiBdID0gc2VlZFsgaiBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBuYW1lc3BhY2UgPSBlbGVtICYmIGVsZW0ubmFtZXNwYWNlVVJJLFxuXHRcdGRvY0VsZW0gPSBlbGVtICYmICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdC8vIEFzc3VtZSBIVE1MIHdoZW4gZG9jdW1lbnRFbGVtZW50IGRvZXNuJ3QgeWV0IGV4aXN0LCBzdWNoIGFzIGluc2lkZSBsb2FkaW5nIGlmcmFtZXNcblx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzQ4MzNcblx0cmV0dXJuICFyaHRtbC50ZXN0KCBuYW1lc3BhY2UgfHwgZG9jRWxlbSAmJiBkb2NFbGVtLm5vZGVOYW1lIHx8IFwiSFRNTFwiICk7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCBkb2MgPT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCBwcmVmZXJyZWREb2MgIT0gZG9jdW1lbnQgJiZcblx0XHQoIHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3ICkgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTEsIEVkZ2Vcblx0XHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0XHRcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDExKywgRWRnZSAxMiAtIDE4KywgQ2hyb21lIDw9MTYgLSAyNSBvbmx5LCBGaXJlZm94IDw9My42IC0gMzEgb25seSxcblx0Ly8gU2FmYXJpIDQgLSA1IG9ubHksIE9wZXJhIDw9MTEuNiAtIDEyLnggb25seVxuXHQvLyBJRS9FZGdlICYgb2xkZXIgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgOnNjb3BlIHBzZXVkby1jbGFzcy5cblx0Ly8gU3VwcG9ydDogU2FmYXJpIDYuMCBvbmx5XG5cdC8vIFNhZmFyaSA2LjAgc3VwcG9ydHMgOnNjb3BlIGJ1dCBpdCdzIGFuIGFsaWFzIG9mIDpyb290IHRoZXJlLlxuXHRzdXBwb3J0LnNjb3BlID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cdFx0cmV0dXJuIHR5cGVvZiBlbC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHQhZWwucXVlcnlTZWxlY3RvckFsbCggXCI6c2NvcGUgZmllbGRzZXQgZGl2XCIgKS5sZW5ndGg7XG5cdH0gKTtcblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NOYW1lXCIgKTtcblx0fSApO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KCBcIlwiICkgKTtcblx0XHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcIipcIiApLmxlbmd0aDtcblx0fSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0gKTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXJbIFwiSURcIiBdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJpZFwiICkgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRFeHByLmZpbmRbIFwiSURcIiBdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlclsgXCJJRFwiIF0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0RXhwci5maW5kWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kWyBcIlRBR1wiIF0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gcmVzdWx0c1sgaSsrIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFsgXCJDTEFTU1wiIF0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKCBzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApICkgKSB7XG5cblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0XHRcdHZhciBpbnB1dDtcblxuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltzZWxlY3RlZF1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJ+PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdFx0Ly8gSUUgMTEvRWRnZSBkb24ndCBmaW5kIGVsZW1lbnRzIG9uIGEgYFtuYW1lPScnXWAgcXVlcnkgaW4gc29tZSBjYXNlcy5cblx0XHRcdC8vIEFkZGluZyBhIHRlbXBvcmFyeSBhdHRyaWJ1dGUgdG8gdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgc2VsZWN0aW9uIHdvcmtzXG5cdFx0XHQvLyBhcm91bmQgdGhlIGlzc3VlLlxuXHRcdFx0Ly8gSW50ZXJlc3RpbmdseSwgSUUgMTAgJiBvbGRlciBkb24ndCBzZWVtIHRvIGhhdmUgdGhlIGlzc3VlLlxuXHRcdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbmFtZT0nJ11cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIipuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqPVwiICtcblx0XHRcdFx0XHR3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCI6Y2hlY2tlZFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6Y2hlY2tlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCIuIy4rWyt+XVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD0zLjYgLSA1IG9ubHlcblx0XHRcdC8vIE9sZCBGaXJlZm94IGRvZXNuJ3QgdGhyb3cgb24gYSBiYWRseS1lc2NhcGVkIGlkZW50aWZpZXIuXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIlxcXFxcXGZcIiApO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiW1xcXFxyXFxcXG5cXFxcZl1cIiApO1xuXHRcdH0gKTtcblxuXHRcdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW25hbWU9ZF1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCI6ZW5hYmxlZFwiICkubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmRpc2FibGVkXCIgKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogT3BlcmEgMTAgLSAxMSBvbmx5XG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbCggXCIqLDp4XCIgKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIiwuKjpcIiApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKCBtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IgKSApICkgKSB7XG5cblx0XHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbiggXCJ8XCIgKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKCBcInxcIiApICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpICk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKCBiID0gYi5wYXJlbnROb2RlICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCAhc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlICkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdGlmICggYSA9PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG5cdFx0XHRcdGNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGEgKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0aWYgKCBiID09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiZcblx0XHRcdFx0Y29udGFpbnMoIHByZWZlcnJlZERvYywgYiApICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuXHRcdFx0cmV0dXJuIGEgPT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGN1ci5wYXJlbnROb2RlICkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoICggY3VyID0gY3VyLnBhcmVudE5vZGUgKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFsgaSBdID09PSBicFsgaSBdICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblxuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwWyBpIF0sIGJwWyBpIF0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuXHRcdFx0YXBbIGkgXSA9PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFsgaSBdID09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdHNldERvY3VtZW50KCBlbGVtICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cblx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggZXhwciwgdHJ1ZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblxuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCggdmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkgKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKCBzZWwgKyBcIlwiICkucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKCBlbGVtID0gcmVzdWx0c1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblxuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAoIG5vZGUgPSBlbGVtWyBpKysgXSApICkge1xuXG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblxuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsgMSBdID0gbWF0Y2hbIDEgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbIDMgXSA9ICggbWF0Y2hbIDMgXSB8fCBtYXRjaFsgNCBdIHx8XG5cdFx0XHRcdG1hdGNoWyA1IF0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbIDIgXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFsgMyBdID0gXCIgXCIgKyBtYXRjaFsgMyBdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblxuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWyAxIF0gPSBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbIDEgXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFsgMCBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFsgNCBdID0gKyggbWF0Y2hbIDQgXSA/XG5cdFx0XHRcdFx0bWF0Y2hbIDUgXSArICggbWF0Y2hbIDYgXSB8fCAxICkgOlxuXHRcdFx0XHRcdDIgKiAoIG1hdGNoWyAzIF0gPT09IFwiZXZlblwiIHx8IG1hdGNoWyAzIF0gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFsgNSBdID0gKyggKCBtYXRjaFsgNyBdICsgbWF0Y2hbIDggXSApIHx8IG1hdGNoWyAzIF0gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWyA2IF0gJiYgbWF0Y2hbIDIgXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbIFwiQ0hJTERcIiBdLnRlc3QoIG1hdGNoWyAwIF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdG1hdGNoWyAyIF0gPSBtYXRjaFsgNCBdIHx8IG1hdGNoWyA1IF0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdCggZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkgKSAmJlxuXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoIGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCApICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWyAwIF0gPSBtYXRjaFsgMCBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbIDIgXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdCggcGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFx0XHRcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSApICYmIGNsYXNzQ2FjaGUoXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KFxuXHRcdFx0XHRcdFx0XHRcdHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fFxuXHRcdFx0XHRcdFx0XHRcdHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8XG5cdFx0XHRcdFx0XHRcdFx0XCJcIlxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9ICk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgX2FyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9IG5vZGVbIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KCBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoIGRpZmYgPSBub2RlSW5kZXggPSAwICkgfHwgc3RhcnQucG9wKCkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8ICggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KCBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KCBkaWZmID0gbm9kZUluZGV4ID0gMCApIHx8IHN0YXJ0LnBvcCgpICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblxuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbIGkgXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFsgaSBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpIF0gPSAhKCBtYXRjaGVzWyBpIF0gPSBlbGVtICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFsgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WyAwIF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KCBsYW5nIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoICggZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIFwieG1sOmxhbmdcIiApIHx8IGVsZW0uZ2V0QXR0cmlidXRlKCBcImxhbmdcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoIGVsZW0gPSBlbGVtLnBhcmVudE5vZGUgKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiZcblx0XHRcdFx0KCAhZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSApICYmXG5cdFx0XHRcdCEhKCBlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4ICk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQgKSB8fFxuXHRcdFx0XHQoIG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCApO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zWyBcImVtcHR5XCIgXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoICggYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICkgPT0gbnVsbCB8fFxuXHRcdFx0XHRcdGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSApLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSApLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggX21hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9ICksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/XG5cdFx0XHRcdGFyZ3VtZW50ICsgbGVuZ3RoIDpcblx0XHRcdFx0YXJndW1lbnQgPiBsZW5ndGggP1xuXHRcdFx0XHRcdGxlbmd0aCA6XG5cdFx0XHRcdFx0YXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9IClcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zWyBcIm50aFwiIF0gPSBFeHByLnBzZXVkb3NbIFwiZXFcIiBdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAoIG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkgKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbIDAgXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAoIHRva2VucyA9IFtdICkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKCBtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApICkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKCB7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFsgMCBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9ICk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAoIG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSApICYmICggIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQoIG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApICkgKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKCB7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zWyBpIF0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblxuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKCBlbGVtWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAoIG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdICkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKCBuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoICggbmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbIGkgXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1sgMCBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzWyBpIF0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoICggZWxlbSA9IHVubWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKFxuXHRcdFx0XHRzZWxlY3RvciB8fCBcIipcIixcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCxcblx0XHRcdFx0W11cblx0XHRcdCksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKCBlbGVtID0gdGVtcFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFsgaSBdIF0gPSAhKCBtYXRjaGVySW5bIHBvc3RNYXBbIGkgXSBdID0gZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gbWF0Y2hlck91dFsgaSBdICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAoIG1hdGNoZXJJblsgaSBdID0gZWxlbSApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsICggbWF0Y2hlck91dCA9IFtdICksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICYmXG5cdFx0XHRcdFx0XHQoIHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwWyBpIF0gKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkWyB0ZW1wIF0gPSAhKCByZXN1bHRzWyB0ZW1wIF0gPSBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyAwIF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVsgXCIgXCIgXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KCBjaGVja0NvbnRleHQgPSBjb250ZXh0ICkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblxuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoIG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIGkgXS50eXBlIF0gKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKCBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlciApIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zWyBpIF0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbIGkgXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIGogXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3RvcihcblxuXHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0dG9rZW5zXG5cdFx0XHRcdFx0XHQuc2xpY2UoIDAsIGkgLSAxIClcblx0XHRcdFx0XHRcdC5jb25jYXQoIHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9IClcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICggdG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkgKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbIFwiVEFHXCIgXSggXCIqXCIsIG91dGVybW9zdCApLFxuXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoIGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xICksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtICkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoZXIgPSBzZXRNYXRjaGVyc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEoIHVubWF0Y2hlZFsgaSBdIHx8IHNldE1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbIGkgXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoWyBpIF0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoXG5cdFx0XHRzZWxlY3Rvcixcblx0XHRcdG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApXG5cdFx0KTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKCBzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yICkgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFsgMCBdID0gbWF0Y2hbIDAgXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKCB0b2tlbiA9IHRva2Vuc1sgMCBdICkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgMSBdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kWyBcIklEXCIgXSggdG9rZW4ubWF0Y2hlc1sgMCBdXG5cdFx0XHRcdC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLCBjb250ZXh0ICkgfHwgW10gKVsgMCBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwclsgXCJuZWVkc0NvbnRleHRcIiBdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zWyBpIF07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKCB0eXBlID0gdG9rZW4udHlwZSApIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoIGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSApICkge1xuXG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoICggc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1sgMCBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWyAwIF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dFxuXHRcdFx0XHQpICkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoIFwiXCIgKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKCBcIlwiICkgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJmaWVsZHNldFwiICkgKSAmIDE7XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwiaHJlZlwiICkgPT09IFwiI1wiO1xufSApICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSApO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBfbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9ICk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCBcImRpc2FibGVkXCIgKSA9PSBudWxsO1xufSApICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHQoIHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApICkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSApO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59ICkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5cbi8vIERlcHJlY2F0ZWRcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cblxuXG5mdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcblxuXHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblxufVxudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcblx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0aWYgKCBlbGVtLmNvbnRlbnREb2N1bWVudCAhPSBudWxsICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExK1xuXHRcdFx0Ly8gPG9iamVjdD4gZWxlbWVudHMgd2l0aCBubyBgZGF0YWAgYXR0cmlidXRlIGhhcyBhbiBvYmplY3Rcblx0XHRcdC8vIGBjb250ZW50RG9jdW1lbnRgIHdpdGggYSBgbnVsbGAgcHJvdG90eXBlLlxuXHRcdFx0Z2V0UHJvdG8oIGVsZW0uY29udGVudERvY3VtZW50ICkgKSB7XG5cblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggX2ksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBwcmltYXJ5IERlZmVycmVkXG5cdFx0XHRwcmltYXJ5ID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdHByaW1hcnkucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIHByaW1hcnkuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgcHJpbWFyeS5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBwcmltYXJ5LnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBwcmltYXJ5LnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIHByaW1hcnkucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByaW1hcnkucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBfa2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBfYWxsLCBsZXR0ZXIgKSB7XG5cdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbn1cblxuLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuZnVuY3Rpb24gY2FtZWxDYXNlKCBzdHJpbmcgKSB7XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xufVxudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBjYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG5cdHZhciBpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0XHR9LFxuXHRcdGNvbXBvc2VkID0geyBjb21wb3NlZDogdHJ1ZSB9O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCssIGlPUyAxMC4wIC0gMTAuMiBvbmx5XG5cdC8vIENoZWNrIGF0dGFjaG1lbnQgYWNyb3NzIHNoYWRvdyBET00gYm91bmRhcmllcyB3aGVuIHBvc3NpYmxlIChnaC0zNTA0KVxuXHQvLyBTdXBwb3J0OiBpT1MgMTAuMC0xMC4yIG9ubHlcblx0Ly8gRWFybHkgaU9TIDEwIHZlcnNpb25zIHN1cHBvcnQgYGF0dGFjaFNoYWRvd2AgYnV0IG5vdCBgZ2V0Um9vdE5vZGVgLFxuXHQvLyBsZWFkaW5nIHRvIGVycm9ycy4gV2UgbmVlZCB0byBjaGVjayBmb3IgYGdldFJvb3ROb2RlYC5cblx0aWYgKCBkb2N1bWVudEVsZW1lbnQuZ2V0Um9vdE5vZGUgKSB7XG5cdFx0aXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRSb290Tm9kZSggY29tcG9zZWQgKSA9PT0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdH07XG5cdH1cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpc0F0dGFjaGVkKCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsIHNjYWxlLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9IGVsZW0ubm9kZVR5cGUgJiZcblx0XHRcdCggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0XHQvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG5cdFx0aW5pdGlhbCA9IGluaXRpYWwgLyAyO1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHR3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcblxuXHRcdFx0Ly8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cblx0XHRcdC8vIEZpbmlzaCBpZiB0aGUgc2NhbGUgZXF1YWxzIG9yIGNyb3NzZXMgMSAobWFraW5nIHRoZSBvbGQqbmV3IHByb2R1Y3Qgbm9uLXBvc2l0aXZlKS5cblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblx0XHRcdGlmICggKCAxIC0gc2NhbGUgKSAqICggMSAtICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41ICkgKSA8PSAwICkge1xuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMDtcblx0XHRcdH1cblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cblx0XHR9XG5cblx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XG5cdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxuXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG5cdHZhciB0ZW1wLFxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG5cdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdGlmICggZGlzcGxheSApIHtcblx0XHRyZXR1cm4gZGlzcGxheTtcblx0fVxuXG5cdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcblx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cblx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRkaXNwbGF5ID0gXCJibG9ja1wiO1xuXHR9XG5cdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSxcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcblx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdC8vIElFIDw9OSByZXBsYWNlcyA8b3B0aW9uPiB0YWdzIHdpdGggdGhlaXIgY29udGVudHMgd2hlbiBpbnNlcnRlZCBvdXRzaWRlIG9mXG5cdC8vIHRoZSBzZWxlY3QgZWxlbWVudC5cblx0ZGl2LmlubmVySFRNTCA9IFwiPG9wdGlvbj48L29wdGlvbj5cIjtcblx0c3VwcG9ydC5vcHRpb24gPSAhIWRpdi5sYXN0Q2hpbGQ7XG59ICkoKTtcblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5pZiAoICFzdXBwb3J0Lm9wdGlvbiApIHtcblx0d3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uID0gWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdO1xufVxuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHR2YXIgcmV0O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gW107XG5cdH1cblxuXHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGF0dGFjaGVkLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggdG9UeXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRhdHRhY2hlZCA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggYXR0YWNoZWQgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbnZhciBydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcbi8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzLCBleGNlcHQgd2hlbiB0aGV5IGFyZSBuby1vcC5cbi8vIFNvIGV4cGVjdCBmb2N1cyB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYWN0aXZlLFxuLy8gYW5kIGJsdXIgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBub3QgYWxyZWFkeSBhY3RpdmUuXG4vLyAoZm9jdXMgYW5kIGJsdXIgYXJlIGFsd2F5cyBzeW5jaHJvbm91cyBpbiBvdGhlciBzdXBwb3J0ZWQgYnJvd3NlcnMsXG4vLyB0aGlzIGp1c3QgZGVmaW5lcyB3aGVuIHdlIGNhbiBjb3VudCBvbiBpdCkuXG5mdW5jdGlvbiBleHBlY3RTeW5jKCBlbGVtLCB0eXBlICkge1xuXHRyZXR1cm4gKCBlbGVtID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICkgPT09ICggdHlwZSA9PT0gXCJmb2N1c1wiICk7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBBY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gdGhyb3cgdW5leHBlY3RlZGx5XG4vLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzOTNcbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gT25seSBhdHRhY2ggZXZlbnRzIHRvIG9iamVjdHMgdGhhdCBhY2NlcHQgZGF0YVxuXHRcdGlmICggIWFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSBPYmplY3QuY3JlYXRlKCBudWxsICk7XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cblx0XHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApLFxuXG5cdFx0XHRoYW5kbGVycyA9IChcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHQpWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZXZlbnQgaXMgbmFtZXNwYWNlZCwgdGhlbiBlYWNoIGhhbmRsZXIgaXMgb25seSBpbnZva2VkIGlmIGl0IGlzXG5cdFx0XHRcdC8vIHNwZWNpYWxseSB1bml2ZXJzYWwgb3IgaXRzIG5hbWVzcGFjZXMgYXJlIGEgc3VwZXJzZXQgb2YgdGhlIGV2ZW50J3MuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgaGFuZGxlT2JqLm5hbWVzcGFjZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0XHRldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCByZXR1cm5UcnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBleHBlY3RTeW5jICkge1xuXG5cdC8vIE1pc3NpbmcgZXhwZWN0U3luYyBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG5cdGlmICggIWV4cGVjdFN5bmMgKSB7XG5cdFx0aWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCByZXR1cm5UcnVlICk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcblx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcblx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcblx0XHRuYW1lc3BhY2U6IGZhbHNlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBub3RBc3luYywgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHQvLyBTYXZlZCBkYXRhIHNob3VsZCBiZSBmYWxzZSBpbiBzdWNoIGNhc2VzLCBidXQgbWlnaHQgYmUgYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdFxuXHRcdFx0XHQvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxuXHRcdFx0XHRpZiAoICFzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXG5cdFx0XHRcdFx0bm90QXN5bmMgPSBleHBlY3RTeW5jKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jICkge1xuXHRcdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgODYrXG5cdFx0XHRcdFx0XHQvLyBJbiBDaHJvbWUsIGlmIGFuIGVsZW1lbnQgaGF2aW5nIGEgZm9jdXNvdXQgaGFuZGxlciBpcyBibHVycmVkIGJ5XG5cdFx0XHRcdFx0XHQvLyBjbGlja2luZyBvdXRzaWRlIG9mIGl0LCBpdCBpbnZva2VzIHRoZSBoYW5kbGVyIHN5bmNocm9ub3VzbHkuIElmXG5cdFx0XHRcdFx0XHQvLyB0aGF0IGhhbmRsZXIgY2FsbHMgYC5yZW1vdmUoKWAgb24gdGhlIGVsZW1lbnQsIHRoZSBkYXRhIGlzIGNsZWFyZWQsXG5cdFx0XHRcdFx0XHQvLyBsZWF2aW5nIGByZXN1bHRgIHVuZGVmaW5lZC4gV2UgbmVlZCB0byBndWFyZCBhZ2FpbnN0IHRoaXMuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0ICYmIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXG5cdFx0XHRcdC8vIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHtcblx0XHRcdFx0XHR2YWx1ZTogalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdFx0Ly8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblx0XHRcdFx0XHRcdGpRdWVyeS5leHRlbmQoIHNhdmVkWyAwIF0sIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgKSxcblx0XHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjb2RlOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblx0d2hpY2g6IHRydWVcbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbmpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gPSB7XG5cblx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgZXhwZWN0U3luYyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSApO1xuXG5cdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gU3VwcHJlc3MgbmF0aXZlIGZvY3VzIG9yIGJsdXIgYXMgaXQncyBhbHJlYWR5IGJlaW5nIGZpcmVkXG5cdFx0Ly8gaW4gbGV2ZXJhZ2VOYXRpdmUuXG5cdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdGRlbGVnYXRlVHlwZTogZGVsZWdhdGVUeXBlXG5cdH07XG59ICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0aWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuXHRcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5nZXQoIHNyYyApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkZXN0LCBcImhhbmRsZSBldmVudHNcIiApO1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gZmxhdCggYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG5cdFx0XHRcdFx0XHRcdFx0fSwgZG9jICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIG5vZGUsIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgaXNBdHRhY2hlZCggbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5jYWxsKCBlbGVtICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuXHRcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXYub2Zmc2V0V2lkdGggLyAzICkgPT09IDEyO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH0sXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBCZWhhdmlvciBpbiBJRSA5IGlzIG1vcmUgc3VidGxlIHRoYW4gaW4gbmV3ZXIgdmVyc2lvbnMgJiBpdCBwYXNzZXNcblx0XHQvLyBzb21lIHZlcnNpb25zIG9mIHRoaXMgdGVzdDsgbWFrZSBzdXJlIG5vdCB0byBtYWtlIGl0IHBhc3MgdGhlcmUhXG5cdFx0Ly9cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDcwK1xuXHRcdC8vIE9ubHkgRmlyZWZveCBpbmNsdWRlcyBib3JkZXIgd2lkdGhzXG5cdFx0Ly8gaW4gY29tcHV0ZWQgZGltZW5zaW9ucy4gKGdoLTQ1MjkpXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRhYmxlLCB0ciwgdHJDaGlsZCwgdHJTdHlsZTtcblx0XHRcdGlmICggcmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRhYmxlXCIgKTtcblx0XHRcdFx0dHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRyXCIgKTtcblx0XHRcdFx0dHJDaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHRcdFx0XHR0YWJsZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O2JvcmRlci1jb2xsYXBzZTpzZXBhcmF0ZVwiO1xuXHRcdFx0XHR0ci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MXB4IHNvbGlkXCI7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDg2K1xuXHRcdFx0XHQvLyBIZWlnaHQgc2V0IHRocm91Z2ggY3NzVGV4dCBkb2VzIG5vdCBnZXQgYXBwbGllZC5cblx0XHRcdFx0Ly8gQ29tcHV0ZWQgaGVpZ2h0IHRoZW4gY29tZXMgYmFjayBhcyAwLlxuXHRcdFx0XHR0ci5zdHlsZS5oZWlnaHQgPSBcIjFweFwiO1xuXHRcdFx0XHR0ckNoaWxkLnN0eWxlLmhlaWdodCA9IFwiOXB4XCI7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA4IENocm9tZSA4Nitcblx0XHRcdFx0Ly8gSW4gb3VyIGJvZHlCYWNrZ3JvdW5kLmh0bWwgaWZyYW1lLFxuXHRcdFx0XHQvLyBkaXNwbGF5IGZvciBhbGwgZGl2IGVsZW1lbnRzIGlzIHNldCB0byBcImlubGluZVwiLFxuXHRcdFx0XHQvLyB3aGljaCBjYXVzZXMgYSBwcm9ibGVtIG9ubHkgaW4gQW5kcm9pZCA4IENocm9tZSA4Ni5cblx0XHRcdFx0Ly8gRW5zdXJpbmcgdGhlIGRpdiBpcyBkaXNwbGF5OiBibG9ja1xuXHRcdFx0XHQvLyBnZXRzIGFyb3VuZCB0aGlzIGlzc3VlLlxuXHRcdFx0XHR0ckNoaWxkLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cblx0XHRcdFx0ZG9jdW1lbnRFbGVtZW50XG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0YWJsZSApXG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0ciApXG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0ckNoaWxkICk7XG5cblx0XHRcdFx0dHJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCB0ciApO1xuXHRcdFx0XHRyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9ICggcGFyc2VJbnQoIHRyU3R5bGUuaGVpZ2h0LCAxMCApICtcblx0XHRcdFx0XHRwYXJzZUludCggdHJTdHlsZS5ib3JkZXJUb3BXaWR0aCwgMTAgKSArXG5cdFx0XHRcdFx0cGFyc2VJbnQoIHRyU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgsIDEwICkgKSA9PT0gdHIub2Zmc2V0SGVpZ2h0O1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggdGFibGUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuXHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG5cdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgIzEyNTM3KVxuXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFpc0F0dGFjaGVkKCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhciBjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGUsXG5cdHZlbmRvclByb3BzID0ge307XG5cbi8vIFJldHVybiBhIHZlbmRvci1wcmVmaXhlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWRcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwb3RlbnRpYWxseS1tYXBwZWQgalF1ZXJ5LmNzc1Byb3BzIG9yIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIGZpbmFsID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gfHwgdmVuZG9yUHJvcHNbIG5hbWUgXTtcblxuXHRpZiAoIGZpbmFsICkge1xuXHRcdHJldHVybiBmaW5hbDtcblx0fVxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXHRyZXR1cm4gdmVuZG9yUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRyY3VzdG9tUHJvcCA9IC9eLS0vLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fTtcblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIF9lbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cblx0XHQvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxuXHRcdC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcblx0XHQpICkgfHwgMDtcblx0fVxuXG5cdHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuXHRcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuXHRcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG5cdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxuXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gVXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3Igd2hlbiBib3ggc2l6aW5nIGlzIHVucmVsaWFibGUuXG5cdC8vIEluIHRob3NlIGNhc2VzLCB0aGUgY29tcHV0ZWQgdmFsdWUgY2FuIGJlIHRydXN0ZWQgdG8gYmUgYm9yZGVyLWJveC5cblx0aWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDEwIC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBJbnRlcmVzdGluZ2x5LCBpbiBzb21lIGNhc2VzIElFIDkgZG9lc24ndCBzdWZmZXIgZnJvbSB0aGlzIGlzc3VlLlxuXHRcdCFzdXBwb3J0LnJlbGlhYmxlVHJEaW1lbnNpb25zKCkgJiYgbm9kZU5hbWUoIGVsZW0sIFwidHJcIiApIHx8XG5cblx0XHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0XHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdFx0dmFsID09PSBcImF1dG9cIiB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdFx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcblx0XHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJpbmxpbmVcIiApICYmXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSAmIGNvbm5lY3RlZFxuXHRcdGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG5cdFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuXHRcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXHRcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcblx0XHRcdHZhbCA9IGVsZW1bIG9mZnNldFByb3AgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwiZ3JpZEFyZWFcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5cIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5FbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5TdGFydFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1wiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd0VuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1N0YXJ0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHQvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG5cdFx0XHQvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBfaSwgZGltZW5zaW9uICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0XHRcdC8vIE9ubHkgcmVhZCBzdHlsZXMucG9zaXRpb24gaWYgdGhlIHRlc3QgaGFzIGEgY2hhbmNlIHRvIGZhaWxcblx0XHRcdFx0Ly8gdG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdy5cblx0XHRcdFx0c2Nyb2xsYm94U2l6ZUJ1Z2d5ID0gIXN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpICYmXG5cdFx0XHRcdFx0c3R5bGVzLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIsXG5cblx0XHRcdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtMzk5MSlcblx0XHRcdFx0Ym94U2l6aW5nTmVlZGVkID0gc2Nyb2xsYm94U2l6ZUJ1Z2d5IHx8IGV4dHJhLFxuXHRcdFx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgP1xuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRcdGlzQm9yZGVyQm94LFxuXHRcdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdFx0KSA6XG5cdFx0XHRcdFx0MDtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXG5cdFx0XHQvLyBmYWtpbmcgYSBjb250ZW50LWJveCB0byBnZXQgYm9yZGVyIGFuZCBwYWRkaW5nIChnaC0zNjk5KVxuXHRcdFx0aWYgKCBpc0JvcmRlckJveCAmJiBzY3JvbGxib3hTaXplQnVnZ3kgKSB7XG5cdFx0XHRcdHN1YnRyYWN0IC09IE1hdGguY2VpbChcblx0XHRcdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHN0eWxlc1sgZGltZW5zaW9uIF0gKSAtXG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMgKSAtXG5cdFx0XHRcdFx0MC41XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBkaW1lbnNpb24gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSB8fFxuXHRcdFx0XHRcdHR3ZWVuLmVsZW0uc3R5bGVbIGZpbmFsUHJvcE5hbWUoIHR3ZWVuLnByb3AgKSBdICE9IG51bGwgKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBIYW5kbGU6IHJlZ3VsYXIgbm9kZXMgKHZpYSBgdGhpcy5vd25lckRvY3VtZW50YCksIHdpbmRvd1xuXHRcdFx0XHQvLyAodmlhIGB0aGlzLmRvY3VtZW50YCkgJiBkb2N1bWVudCAodmlhIGB0aGlzYCkuXG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSB7IGd1aWQ6IERhdGUubm93KCkgfTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sLCBwYXJzZXJFcnJvckVsZW07XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHt9XG5cblx0cGFyc2VyRXJyb3JFbGVtID0geG1sICYmIHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiIClbIDAgXTtcblx0aWYgKCAheG1sIHx8IHBhcnNlckVycm9yRWxlbSApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgKFxuXHRcdFx0cGFyc2VyRXJyb3JFbGVtID9cblx0XHRcdFx0alF1ZXJ5Lm1hcCggcGFyc2VyRXJyb3JFbGVtLmNoaWxkTm9kZXMsIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWwudGV4dENvbnRlbnQ7XG5cdFx0XHRcdH0gKS5qb2luKCBcIlxcblwiICkgOlxuXHRcdFx0XHRkYXRhXG5cdFx0KSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgdG9UeXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdGlmICggYSA9PSBudWxsICkge1xuXHRcdHJldHVybiBcIlwiO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9ICkubWFwKCBmdW5jdGlvbiggX2ksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cbm9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gPVxuXHRcdFx0XHRcdFx0XHRcdFx0KCByZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gfHwgW10gKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuY29uY2F0KCBtYXRjaFsgMiBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSArIFwiIFwiIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoLmpvaW4oIFwiLCBcIiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UuZ3VpZCsrICkgK1xuXHRcdFx0XHRcdHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVc2UgYSBub29wIGNvbnZlcnRlciBmb3IgbWlzc2luZyBzY3JpcHQgYnV0IG5vdCBpZiBqc29ucFxuXHRcdFx0aWYgKCAhaXNTdWNjZXNzICYmXG5cdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBcInNjcmlwdFwiLCBzLmRhdGFUeXBlcyApID4gLTEgJiZcblx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIFwianNvblwiLCBzLmRhdGFUeXBlcyApIDwgMCApIHtcblx0XHRcdFx0cy5jb252ZXJ0ZXJzWyBcInRleHQgc2NyaXB0XCIgXSA9IGZ1bmN0aW9uKCkge307XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIF9pLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0dmFyIGk7XG5cdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdGlmICggaS50b0xvd2VyQ2FzZSgpID09PSBcImNvbnRlbnQtdHlwZVwiICkge1xuXHRcdFx0cy5jb250ZW50VHlwZSA9IHMuaGVhZGVyc1sgaSBdIHx8IFwiXCI7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCwgb3B0aW9ucywgZG9jICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cblx0XHQvLyBPbmx5IGV2YWx1YXRlIHRoZSByZXNwb25zZSBpZiBpdCBpcyBzdWNjZXNzZnVsIChnaC00MTI2KVxuXHRcdC8vIGRhdGFGaWx0ZXIgaXMgbm90IGludm9rZWQgZm9yIGZhaWx1cmUgcmVzcG9uc2VzLCBzbyB1c2luZyBpdCBpbnN0ZWFkXG5cdFx0Ly8gb2YgdGhlIGRlZmF1bHQgY29udmVydGVyIGlzIGtsdWRneSBidXQgaXQgd29ya3MuXG5cdFx0Y29udmVydGVyczoge1xuXHRcdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbigpIHt9XG5cdFx0fSxcblx0XHRkYXRhRmlsdGVyOiBmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggcmVzcG9uc2UsIG9wdGlvbnMsIGRvYyApO1xuXHRcdH1cblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluIHx8IHMuc2NyaXB0QXR0cnMgKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBzLnNjcmlwdEF0dHJzIHx8IHt9IClcblx0XHRcdFx0XHQucHJvcCggeyBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsIHNyYzogcy51cmwgfSApXG5cdFx0XHRcdFx0Lm9uKCBcImxvYWQgZXJyb3JcIiwgY2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlLmd1aWQrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBpc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcblx0Ly8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG5cdFx0XHQvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG5cdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIF9pLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7XG5cdFx0cGFkZGluZzogXCJpbm5lclwiICsgbmFtZSxcblx0XHRjb250ZW50OiB0eXBlLFxuXHRcdFwiXCI6IFwib3V0ZXJcIiArIG5hbWVcblx0fSwgZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggX2ksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9LFxuXG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaChcblx0KCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblxuXHRcdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdFx0fTtcblx0fVxuKTtcblxuXG5cblxuLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG4vLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1BcbnZhciBydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxualF1ZXJ5LnRyaW0gPSBmdW5jdGlvbiggdGV4dCApIHtcblx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XCJcIiA6XG5cdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG59O1xuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggdHlwZW9mIG5vR2xvYmFsID09PSBcInVuZGVmaW5lZFwiICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/jquery/dist/jquery.js\n')},"../node_modules/style-loader/lib/addStyles.js":function(module,exports,__webpack_require__){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === "undefined") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve "head" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }\n                // }\n                if (typeof target === \'function\') {\n                        return target();\n                }\n                if (typeof memo[target] === "undefined") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ "../node_modules/style-loader/lib/urls.js");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== "undefined" && DEBUG) {\n\t\tif (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === "object" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = "head";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = "bottom";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error("Couldn\'t find a style target. This probably means that the value for the \'insertInto\' parameter is invalid.");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === "top") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === "bottom") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === "object" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + " " + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error("[Style Loader]\\n\\n Invalid value for parameter \'insertAt\' (\'options.insertAt\') found.\\n Must be \'top\', \'bottom\', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement("style");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = "text/css";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement("link");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = "text/css";\n\t}\n\toptions.attrs.rel = "stylesheet";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don\'t add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === "function" &&\n\t\ttypeof URL.createObjectURL === "function" &&\n\t\ttypeof URL.revokeObjectURL === "function" &&\n\t\ttypeof Blob === "function" &&\n\t\ttypeof btoa === "function"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join(\'\\n\');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? "" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute("media", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn\'t defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";\n\t}\n\n\tvar blob = new Blob([css], { type: "text/css" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcz81MWVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8gKyBcIiBcIiArIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/style-loader/lib/addStyles.js\n')},"../node_modules/style-loader/lib/urls.js":function(module,exports){eval('\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function "fixes" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== "undefined" && window.location;\n\n  if (!location) {\n    throw new Error("fixUrls requires window.location");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== "string") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + "//" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, "/");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word "url" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn\'t a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn\'t a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn\'t a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^"(.*)"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^\'(.*)\'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf("//") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf("/") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with \'/\'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, ""); // Strip leading \'./\'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn "url(" + JSON.stringify(newUrl) + ")";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzPzk0MzIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/style-loader/lib/urls.js\n')},"../node_modules/url-join/lib/url-join.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (name, context, definition) {\n  if ( true && module.exports) module.exports = definition();\n  else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  else {}\n})('urljoin', this, function () {\n\n  function normalize (strArray) {\n    var resultArray = [];\n\n    // If the first part is a plain protocol, we combine it with the next part.\n    if (strArray[0].match(/^[^/:]+:\\/*$/) && strArray.length > 1) {\n      var first = strArray.shift();\n      strArray[0] = first + strArray[0];\n    }\n\n    // There must be two or three slashes in the file protocol, two slashes in anything else.\n    if (strArray[0].match(/^file:\\/\\/\\//)) {\n      strArray[0] = strArray[0].replace(/^([^/:]+):\\/*/, '$1:///');\n    } else {\n      strArray[0] = strArray[0].replace(/^([^/:]+):\\/*/, '$1://');\n    }\n\n    for (var i = 0; i < strArray.length; i++) {\n      var component = strArray[i];\n\n      if (typeof component !== 'string') {\n        throw new TypeError('Url must be a string. Received ' + component);\n      }\n\n      if (component === '') { continue; }\n\n      if (i > 0) {\n        // Removing the starting slashes for each component but the first.\n        component = component.replace(/^[\\/]+/, '');\n      }\n      if (i < strArray.length - 1) {\n        // Removing the ending slashes for each component but the last.\n        component = component.replace(/[\\/]+$/, '');\n      } else {\n        // For the last component we will combine multiple slashes to a single one.\n        component = component.replace(/[\\/]+$/, '/');\n      }\n\n      resultArray.push(component);\n\n    }\n\n    var str = resultArray.join('/');\n    // Each input component is now separated by a single slash except the possible first plain protocol part.\n\n    // remove trailing slash before parameters or hash\n    str = str.replace(/\\/(\\?|&|#[^!])/g, '$1');\n\n    // replace ? in parameters with &\n    var parts = str.split('?');\n    str = parts.shift() + (parts.length > 0 ? '?': '') + parts.join('&');\n\n    return str;\n  }\n\n  return function () {\n    var input;\n\n    if (typeof arguments[0] === 'object') {\n      input = arguments[0];\n    } else {\n      input = [].slice.call(arguments);\n    }\n\n    return normalize(input);\n  };\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3VybC1qb2luL2xpYi91cmwtam9pbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvdXJsLWpvaW4vbGliL3VybC1qb2luLmpzPzgyMTIiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChuYW1lLCBjb250ZXh0LCBkZWZpbml0aW9uKSB7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGRlZmluaXRpb24pO1xuICBlbHNlIGNvbnRleHRbbmFtZV0gPSBkZWZpbml0aW9uKCk7XG59KSgndXJsam9pbicsIHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICBmdW5jdGlvbiBub3JtYWxpemUgKHN0ckFycmF5KSB7XG4gICAgdmFyIHJlc3VsdEFycmF5ID0gW107XG5cbiAgICAvLyBJZiB0aGUgZmlyc3QgcGFydCBpcyBhIHBsYWluIHByb3RvY29sLCB3ZSBjb21iaW5lIGl0IHdpdGggdGhlIG5leHQgcGFydC5cbiAgICBpZiAoc3RyQXJyYXlbMF0ubWF0Y2goL15bXi86XSs6XFwvKiQvKSAmJiBzdHJBcnJheS5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgZmlyc3QgPSBzdHJBcnJheS5zaGlmdCgpO1xuICAgICAgc3RyQXJyYXlbMF0gPSBmaXJzdCArIHN0ckFycmF5WzBdO1xuICAgIH1cblxuICAgIC8vIFRoZXJlIG11c3QgYmUgdHdvIG9yIHRocmVlIHNsYXNoZXMgaW4gdGhlIGZpbGUgcHJvdG9jb2wsIHR3byBzbGFzaGVzIGluIGFueXRoaW5nIGVsc2UuXG4gICAgaWYgKHN0ckFycmF5WzBdLm1hdGNoKC9eZmlsZTpcXC9cXC9cXC8vKSkge1xuICAgICAgc3RyQXJyYXlbMF0gPSBzdHJBcnJheVswXS5yZXBsYWNlKC9eKFteLzpdKyk6XFwvKi8sICckMTovLy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyQXJyYXlbMF0gPSBzdHJBcnJheVswXS5yZXBsYWNlKC9eKFteLzpdKyk6XFwvKi8sICckMTovLycpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSBzdHJBcnJheVtpXTtcblxuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VybCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCAnICsgY29tcG9uZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvbmVudCA9PT0gJycpIHsgY29udGludWU7IH1cblxuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIC8vIFJlbW92aW5nIHRoZSBzdGFydGluZyBzbGFzaGVzIGZvciBlYWNoIGNvbXBvbmVudCBidXQgdGhlIGZpcnN0LlxuICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnQucmVwbGFjZSgvXltcXC9dKy8sICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChpIDwgc3RyQXJyYXkubGVuZ3RoIC0gMSkge1xuICAgICAgICAvLyBSZW1vdmluZyB0aGUgZW5kaW5nIHNsYXNoZXMgZm9yIGVhY2ggY29tcG9uZW50IGJ1dCB0aGUgbGFzdC5cbiAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50LnJlcGxhY2UoL1tcXC9dKyQvLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3IgdGhlIGxhc3QgY29tcG9uZW50IHdlIHdpbGwgY29tYmluZSBtdWx0aXBsZSBzbGFzaGVzIHRvIGEgc2luZ2xlIG9uZS5cbiAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50LnJlcGxhY2UoL1tcXC9dKyQvLCAnLycpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRBcnJheS5wdXNoKGNvbXBvbmVudCk7XG5cbiAgICB9XG5cbiAgICB2YXIgc3RyID0gcmVzdWx0QXJyYXkuam9pbignLycpO1xuICAgIC8vIEVhY2ggaW5wdXQgY29tcG9uZW50IGlzIG5vdyBzZXBhcmF0ZWQgYnkgYSBzaW5nbGUgc2xhc2ggZXhjZXB0IHRoZSBwb3NzaWJsZSBmaXJzdCBwbGFpbiBwcm90b2NvbCBwYXJ0LlxuXG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoIGJlZm9yZSBwYXJhbWV0ZXJzIG9yIGhhc2hcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFwvKFxcP3wmfCNbXiFdKS9nLCAnJDEnKTtcblxuICAgIC8vIHJlcGxhY2UgPyBpbiBwYXJhbWV0ZXJzIHdpdGggJlxuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnPycpO1xuICAgIHN0ciA9IHBhcnRzLnNoaWZ0KCkgKyAocGFydHMubGVuZ3RoID4gMCA/ICc/JzogJycpICsgcGFydHMuam9pbignJicpO1xuXG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlucHV0O1xuXG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICBpbnB1dCA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZShpbnB1dCk7XG4gIH07XG5cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/url-join/lib/url-join.js\n")},"./app.css":function(module,exports,__webpack_require__){eval('\nvar content = __webpack_require__(/*! !../node_modules/css-loader??ref--4-1!./app.css */ "../node_modules/css-loader/index.js?!./app.css");\n\nif(typeof content === \'string\') content = [[module.i, content, \'\']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {"hmr":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ "../node_modules/style-loader/lib/addStyles.js")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hcHAuY3NzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vYXBwLmNzcz82MTg1Il0sInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS00LTEhLi9hcHAuY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS00LTEhLi9hcHAuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNC0xIS4vYXBwLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./app.css\n')},"./app.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "run_summary_table", function() { return run_summary_table; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "../node_modules/jquery/dist/jquery.js");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var jquery_ui_themes_base_core_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery-ui/themes/base/core.css */ "../node_modules/jquery-ui/themes/base/core.css");\n/* harmony import */ var jquery_ui_themes_base_core_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery_ui_themes_base_core_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var jquery_ui_themes_base_theme_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery-ui/themes/base/theme.css */ "../node_modules/jquery-ui/themes/base/theme.css");\n/* harmony import */ var jquery_ui_themes_base_theme_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery_ui_themes_base_theme_css__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var jquery_ui_themes_base_tabs_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jquery-ui/themes/base/tabs.css */ "../node_modules/jquery-ui/themes/base/tabs.css");\n/* harmony import */ var jquery_ui_themes_base_tabs_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(jquery_ui_themes_base_tabs_css__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! jquery-ui/ui/core */ "../node_modules/jquery-ui/ui/core.js");\n/* harmony import */ var jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(jquery_ui_ui_core__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var jquery_ui_ui_widgets_tabs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jquery-ui/ui/widgets/tabs */ "../node_modules/jquery-ui/ui/widgets/tabs.js");\n/* harmony import */ var jquery_ui_ui_widgets_tabs__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(jquery_ui_ui_widgets_tabs__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _app_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./app.css */ "./app.css");\n/* harmony import */ var _app_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_app_css__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var url_join__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! url-join */ "../node_modules/url-join/lib/url-join.js");\n/* harmony import */ var url_join__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(url_join__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var apollo_fetch__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! apollo-fetch */ "../node_modules/apollo-fetch/dist/index.js");\n/* harmony import */ var _loaderImage_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./loaderImage.js */ "./loaderImage.js");\n\n\n\n\n\n\n\n\n\n\n\nlet quartile_map = {\n  1: {\n    name: "Q1",\n    css_class: "Q1",\n  },\n  2: {\n    name: "Q2",\n    css_class: "Q2",\n  },\n  3: {\n    name: "Q3",\n    css_class: "Q3",\n  },\n  4: {\n    name: "Q4",\n    css_class: "Q4",\n  },\n};\n\nfunction fill_in_table(\n  divid,\n  aggregations,\n  mode,\n  tool_elixir_ids,\n  community_id,\n  benchmarking_event_id,\n  chunk_size,\n  api_url\n) {\n  let known_tools = {};\n  let ordered_tools = [];\n  let challenges = {};\n  let challenges_list = [];\n  let num_charts = 0;\n\n  aggregations.forEach((aggregation, num) => {\n    if ("participants" in aggregation) {\n      Object.keys(aggregation.participants).forEach((toolname, i) => {\n        if (!(toolname in known_tools)) {\n          known_tools[toolname] = true;\n          ordered_tools.push(toolname);\n        }\n      });\n      if (!(aggregation._id in challenges)) {\n        challenges[aggregation._id] = [];\n        challenges_list.push(challenges[aggregation._id]);\n      }\n      challenges[aggregation._id].push(aggregation);\n      if (Object.keys(aggregation.participants).length > 0) {\n        num_charts++;\n      }\n    }\n  });\n\n  challenges_list.sort((a, b) => {\n    const c_a = a[0].challenge_acronym.toUpperCase();\n    const c_b = b[0].challenge_acronym.toUpperCase();\n\n    return c_a < c_b ? -1 : c_a > c_b ? 1 : 0;\n  });\n\n  let empty_challenges_list = [];\n  let used_challenges_list = [];\n  challenges_list.forEach((aggregations) => {\n    let challenge_num_charts = aggregations\n      .map((aggregation) => Object.keys(aggregation.participants).length)\n      .reduce((ps, a) => ps + a, 0);\n    if (challenge_num_charts > 0) {\n      used_challenges_list.push(aggregations);\n    } else {\n      empty_challenges_list.push(aggregations);\n    }\n  });\n\n  let force_break = false;\n  let reduce_lambda = (aggregation_slices, aggregations) => {\n    let lastidx = aggregation_slices.length - 1;\n    if (\n      lastidx == -1 ||\n      aggregation_slices[lastidx].members.length + aggregations.length >=\n        chunk_size ||\n      force_break\n    ) {\n      force_break = false;\n      let aggregation_tab = {\n        from: aggregations[0].challenge_acronym,\n        to: aggregations[0].challenge_acronym,\n        members: [...aggregations],\n        empty_challenge: Object.keys(aggregations[0].participants).length === 0,\n      };\n      aggregation_slices.push(aggregation_tab);\n    } else {\n      let aggregation_tab = aggregation_slices[lastidx];\n      aggregation_tab.members.push(...aggregations);\n      aggregation_tab.to = aggregations[0].challenge_acronym;\n    }\n\n    return aggregation_slices;\n  };\n\n  let aggregation_slices = used_challenges_list.reduce(reduce_lambda, []);\n  force_break = true;\n  aggregation_slices = empty_challenges_list.reduce(\n    reduce_lambda,\n    aggregation_slices\n  );\n\n  let slicesdiv_id = remove_table(divid);\n  let slicesdiv = document.createElement("div");\n  slicesdiv.id = slicesdiv_id;\n  let parentDivTable = document.getElementById(divid);\n  parentDivTable.appendChild(slicesdiv);\n\n  let tabcontainer = document.createElement("div");\n  tabcontainer.setAttribute("class", "tabs-container");\n  slicesdiv.appendChild(tabcontainer);\n\n  let buttonleft = document.createElement("button");\n  buttonleft.setAttribute("class", "arrow left-arrow");\n  buttonleft.setAttribute("aria-label", "Previous tabs");\n  buttonleft.innerHTML = "&lt;";\n  tabcontainer.appendChild(buttonleft);\n\n  let tabwrap = document.createElement("div");\n  tabwrap.setAttribute("class", "tabs-wrapper");\n  tabcontainer.appendChild(tabwrap);\n\n  let tablist = document.createElement("ul");\n  tablist.setAttribute(\n    "title",\n    `Community ${community_id} event ${benchmarking_event_id}`\n  );\n  tabwrap.appendChild(tablist);\n\n  let buttonright = document.createElement("button");\n  buttonright.setAttribute("class", "arrow right-arrow");\n  buttonright.setAttribute("aria-label", "Next tabs");\n  buttonright.innerHTML = "&gt;";\n  tabcontainer.appendChild(buttonright);\n\n  let currentIndex = 0;\n  const maxVisibleTabs = 10;\n\n  function updateArrowButtons() {\n    buttonleft.disabled = currentIndex === 0;\n    buttonright.disabled =\n      currentIndex >= tablist.children.length - maxVisibleTabs;\n  }\n\n  function showVisibleTabs() {\n    let tabHeight = tablist.children[0].offsetHeight; // Get the height of the first tab\n    const totalTabs = tablist.children.length;\n\n    for (let i = 0; i < totalTabs; i++) {\n      if (i >= currentIndex && i < currentIndex + maxVisibleTabs) {\n        tablist.children[i].style.display = "inline-block";\n      } else {\n        tablist.children[i].style.display = "none";\n      }\n    }\n\n    // Update arrows visibility\n    if (totalTabs <= maxVisibleTabs) {\n      buttonleft.style.display = "none";\n      buttonright.style.display = "none";\n      tablist.style.width = "100%";\n    } else {\n      buttonleft.style.display = "block";\n      buttonright.style.display = "block";\n    }\n\n    // Add empty tabs to maintain height if fewer tabs on the final page\n    let tabsToShow = Math.min(totalTabs - currentIndex, maxVisibleTabs);\n    let emptyTabs = maxVisibleTabs - tabsToShow;\n    while (emptyTabs > 0) {\n      let emptyTab = document.createElement("li");\n      emptyTab.className = "empty-tab";\n      emptyTab.style.height = `${tabHeight}px`; // Match the height of the visible tabs\n      tablist.appendChild(emptyTab);\n      emptyTabs--;\n    }\n  }\n\n  function scrollTabs(direction) {\n    if (direction === "right") {\n      currentIndex += maxVisibleTabs;\n    } else {\n      currentIndex -= maxVisibleTabs;\n    }\n\n    showVisibleTabs();\n    updateArrowButtons();\n    updatePaginator(); // Update paginator when tabs are scrolled\n  }\n\n  buttonright.addEventListener("click", () => {\n    scrollTabs("right");\n  });\n  buttonleft.addEventListener("click", () => {\n    scrollTabs("left");\n  });\n\n  // Create the paginator\n  let paginator = document.createElement("div");\n  paginator.setAttribute("class", "tabs-footer");\n  slicesdiv.appendChild(paginator);\n\n  let challenge_report = document.createElement("p");\n  challenge_report.appendChild(\n    document.createTextNode(\n      challenges_list.length.toString() +\n        " Challenges, " +\n        num_charts.toString() +\n        " charts"\n    )\n  );\n  challenge_report.setAttribute("class", "report");\n  paginator.appendChild(challenge_report);\n\n  function updatePaginator() {\n    const totalTabs = Array.from(tablist.children).filter(\n      (child) => !child.classList.contains("empty-tab")\n    ).length;\n    const totalPages = Math.ceil(totalTabs / maxVisibleTabs);\n    const currentPage = Math.floor(currentIndex / maxVisibleTabs) + 1;\n\n    // Calculate the range of visible tabs\n    const startTab = currentIndex + 1; // Start index for visible tabs (1-based)\n    const endTab = Math.min(currentIndex + maxVisibleTabs, totalTabs); // End index for visible tabs (1-based)\n\n    // Check if the paginator already contains a <p> element with class "pags"\n    let counter = paginator.querySelector(".pags");\n\n    if (!counter) {\n      // If no <p> element exists, create it\n      counter = document.createElement("p");\n      counter.setAttribute("class", "pags");\n      paginator.appendChild(counter);\n    }\n\n    // Update the content of the existing <p> element\n    counter.innerHTML = `${startTab}-${endTab} tabs of ${totalTabs} tabs, ${currentPage}/${totalPages} pages`;\n  }\n\n  aggregation_slices.forEach((aggregations_slice, slice_i) => {\n    if (\n      !aggregations_slice.members ||\n      aggregations_slice.members.length === 0\n    ) {\n      // Skip empty tabs\n      return;\n    }\n    let tabheader = document.createElement("li");\n    if (aggregations_slice.empty_challenge) {\n      tabheader.setAttribute("class", "empty-challenge");\n    }\n    let tab_a = document.createElement("a");\n    let shift_slice_id = slicesdiv_id + "-" + slice_i;\n    tab_a.href = "#" + shift_slice_id;\n\n    let tabtext;\n    if (aggregations_slice.from == aggregations_slice.to) {\n      tabtext = aggregations_slice.from;\n    } else {\n      tabtext = aggregations_slice.from + "\\u00A0to " + aggregations_slice.to;\n    }\n\n    let span_limits = document.createElement("span");\n    span_limits.appendChild(document.createTextNode(tabtext));\n    span_limits.setAttribute("class", "tablimits");\n    tab_a.appendChild(span_limits);\n\n    tab_a.setAttribute("title", tabtext);\n    tabheader.appendChild(tab_a);\n    tablist.appendChild(tabheader);\n\n    let scrollableDiv = fill_in_table_slice(\n      aggregations_slice.members,\n      mode,\n      tool_elixir_ids,\n      community_id,\n      ordered_tools,\n      api_url\n    );\n    scrollableDiv.id = shift_slice_id;\n    slicesdiv.appendChild(scrollableDiv);\n  });\n\n  // Initial state: show only the first 10 tabs\n  showVisibleTabs();\n  updateArrowButtons();\n  updatePaginator(); // Initialize paginator\n  jquery__WEBPACK_IMPORTED_MODULE_0___default()(slicesdiv).tabs({ active: 0 });\n}\n\nfunction fill_in_table_slice(\n  aggregations,\n  mode,\n  tool_elixir_ids,\n  community_id,\n  ordered_tools,\n  api_url\n) {\n  let scrollableDiv = document.createElement("div");\n  scrollableDiv.className = "oeb-table-scroll";\n\n  // Create table dynamically\n  let table = document.createElement("table");\n  table.className = "oeb-main-table";\n  scrollableDiv.appendChild(table);\n\n  let thead = document.createElement("thead");\n  let tbody = document.createElement("tbody");\n  table.appendChild(thead);\n  table.appendChild(tbody);\n\n  // Add challenge and tool fixed top left\n  let challenges_row = thead.insertRow();\n  let ch_th = document.createElement("th");\n  ch_th.innerHTML = "<b>Challenges&nbsp;&#8594</b>";\n  challenges_row.appendChild(ch_th);\n\n  let aggregations_row = thead.insertRow();\n  let th = document.createElement("th");\n  th.innerHTML = "<b>Charts&nbsp;&#8594  <br>Participants&nbsp;&#8595</b>";\n  aggregations_row.appendChild(th);\n\n  // Append rows with all participants in the benchmark\n  ordered_tools.forEach((toolname) => {\n    let row = tbody.insertRow(-1);\n    let th = document.createElement("th");\n    let divpart = document.createElement("div");\n    divpart.setAttribute("class", "aggregation_cell");\n    th.appendChild(divpart);\n\n    let a = document.createElement("a");\n    if (tool_elixir_ids[toolname] != null) {\n      let technical_url = url_join__WEBPACK_IMPORTED_MODULE_7___default()(\n        "https://" + mode + ".bsc.es/tool/",\n        tool_elixir_ids[toolname]\n      );\n      a.setAttribute("href", technical_url);\n      a.setAttribute("target", "_blank");\n      a.setAttribute("class", "aggregation_cell_2");\n    }else{\n      a.setAttribute("style", "color:black");\n      a.setAttribute("style", "pointer:default");\n    }\n    a.appendChild(document.createTextNode(toolname));\n    a.setAttribute("title", toolname);\n    divpart.appendChild(a);\n    th.dataset.toolname = toolname;\n    row.appendChild(th);\n  });\n\n  // It has to be done in two passes because the number of rows have to be "known" beforehand\n  let drawn_challenge_headers = {};\n  aggregations.forEach((aggregation, num) => {\n    if ("participants" in aggregation) {\n      // Append columns with aggregations and results\n      let column_value_dict = {};\n      Object.keys(aggregation.participants).forEach((toolname, j) => {\n        column_value_dict[toolname] = aggregation.participants[toolname];\n      });\n\n      // Challenge specific cell\n      let url = url_join__WEBPACK_IMPORTED_MODULE_7___default()(\n        "https://" + mode + ".bsc.es/scientific/",\n        community_id,\n        aggregation._id\n      );\n      let the_colspan = 1;\n      let ch_th = null;\n      if (aggregation._id in drawn_challenge_headers) {\n        // Increase the colspan\n        ch_th = drawn_challenge_headers[aggregation._id];\n        let colspanstr = ch_th.getAttribute("colspan");\n        the_colspan = parseInt(colspanstr);\n        the_colspan++;\n      } else {\n        ch_th = document.createElement("th");\n        let aggdivcell = document.createElement("div");\n        aggdivcell.setAttribute("class", "aggregation_cell");\n\n        let a = document.createElement("a");\n        a.setAttribute("href", url);\n        a.setAttribute("target", "blank");\n        a.setAttribute("class", "aggregation_cell_2");\n        let acronym =\n          "challenge_acronym" in aggregation\n            ? aggregation.challenge_acronym\n            : aggregation.acronym;\n        a.appendChild(document.createTextNode(acronym));\n        a.setAttribute("title", acronym);\n        aggdivcell.appendChild(a);\n        ch_th.appendChild(aggdivcell);\n        ch_th.id = aggregation._id;\n        challenges_row.appendChild(ch_th);\n        drawn_challenge_headers[aggregation._id] = ch_th;\n      }\n      ch_th.setAttribute("colspan", the_colspan.toString());\n\n      // Aggregation specific cell\n      let th = document.createElement("th");\n      let divcell = document.createElement("div");\n      divcell.setAttribute("class", "aggregation_cell");\n      let a = document.createElement("a");\n      //a.setAttribute("href", url);\n      //a.setAttribute("target", "blank");\n      if (aggregation.aggregation_id !== undefined) {\n        th.id = aggregation.aggregation_id;\n        aggregation.metrics.forEach((m_entry, m_entry_i) => {\n          if (m_entry_i > 0) {\n            a.appendChild(document.createElement("br"));\n            let span = document.createElement("span");\n            span.setAttribute("class", "notbold italic");\n            span.appendChild(document.createTextNode("vs"));\n            a.appendChild(span);\n            a.appendChild(document.createElement("br"));\n          }\n          let content;\n          if (m_entry == null) {\n            console.log("FIXME: metrics label not in challenge", aggregation);\n            content = document.createElement("i");\n            content.appendChild(document.createTextNode("undefined"));\n          } else {\n            content = document.createTextNode(m_entry.title);\n          }\n          a.appendChild(content);\n        });\n      } else {\n        let content = document.createTextNode(\n          "No chart based on " + aggregation.metrics_category_id\n        );\n        a.appendChild(content);\n        a.setAttribute("target", "_blank");\n        a.setAttribute(\n          "href",\n          url_join__WEBPACK_IMPORTED_MODULE_7___default()(\n            api_url,\n            "../staged/Metrics/" + aggregation.metrics_category_id\n          )\n        );\n      }\n      divcell.appendChild(a);\n      th.appendChild(divcell);\n      aggregations_row.appendChild(th);\n\n      // Open loop for each row and append cell\n      ordered_tools.forEach((row_tool_name, i) => {\n        // Non headers\n        let cell = tbody.rows[i].insertCell();\n        let cellval = "-";\n        if (row_tool_name in column_value_dict) {\n          cellval = quartile_map[column_value_dict[row_tool_name]].name;\n          cell.setAttribute(\n            "class",\n            quartile_map[column_value_dict[row_tool_name]].css_class\n          );\n        }\n        cell.appendChild(document.createTextNode(cellval));\n      });\n    }\n  });\n\n  // Function to recalculate and apply height in list of tabs\n  function updateTableLayout() {\n    setTimeout(() => {\n      let firstRowHeight = challenges_row.offsetHeight;\n      let secondRowHeaders = aggregations_row.querySelectorAll("th");\n      let firstHeaderInSecondRow =\n        aggregations_row.querySelector("th:first-child");\n\n      secondRowHeaders.forEach(function (header) {\n        header.style.top = firstRowHeight + "px";\n\n        firstHeaderInSecondRow.style.zIndex = "99";\n      });\n    }, 0);\n  }\n\n  updateTableLayout();\n\n  // Watch for changes to the table and recalculate height\n  let observer = new MutationObserver(function (mutationsList) {\n    for (let mutation of mutationsList) {\n      if (mutation.type === "childList" || mutation.type === "attributes") {\n        updateTableLayout();\n      }\n    }\n  });\n\n  // Start observing the table for changes\n  observer.observe(scrollableDiv, {\n    attributes: true, // For any changes to attributes\n    childList: true, // For any changes to child nodes\n    subtree: true, // Watch for changes in all descendants\n  });\n  return scrollableDiv;\n}\n\nasync function fetchUrl(url, http_method, challenge_list) {\n  try {\n    let request1;\n\n    if (http_method == "GET") {\n      return await fetch(url);\n    } else {\n      return await fetch(url, {\n        method: "POST",\n        body: JSON.stringify(challenge_list),\n      });\n    }\n  } catch (err) {\n    console.log(`Invalid Url Error: ${err.stack} `, url);\n  }\n}\n\nfunction compute_classification(\n  divid,\n  selected_classifier,\n  challenge_list,\n  chunk_size\n) {\n  show_loading_spinner(divid, true);\n\n  //check for mode by default it is production if no param is given\n  let tablediv = document.getElementById(divid);\n  var mode = jquery__WEBPACK_IMPORTED_MODULE_0___default()(tablediv).data("mode") ? jquery__WEBPACK_IMPORTED_MODULE_0___default()(tablediv).data("mode") : "openebench";\n\n  const api_url = jquery__WEBPACK_IMPORTED_MODULE_0___default()(tablediv).data("api-url");\n  const bench_event_api_url = jquery__WEBPACK_IMPORTED_MODULE_0___default()(tablediv).data("bench-event-api-url")\n    ? jquery__WEBPACK_IMPORTED_MODULE_0___default()(tablediv).data("bench-event-api-url")\n    : "https://openebench.bsc.es/rest/bench_event_api";\n\n  let path_data =\n    jquery__WEBPACK_IMPORTED_MODULE_0___default()(tablediv).data("benchmarkingevent") + "/" + selected_classifier;\n  path_data = url_join__WEBPACK_IMPORTED_MODULE_7___default()(bench_event_api_url, path_data);\n  let http_method;\n\n  if (challenge_list.length === undefined || challenge_list.length == 0) {\n    http_method = "GET";\n  } else {\n    http_method = "POST";\n  }\n\n  fetchUrl(path_data, http_method, challenge_list)\n    .then((response) => {\n      if (!response.ok) {\n        let bench_id = jquery__WEBPACK_IMPORTED_MODULE_0___default()(tablediv).data("benchmarkingevent");\n        if (response.status === 404) {\n          show_loading_spinner(divid, false);\n          tablediv.innerHTML = "";\n          let para = document.createElement("div");\n          para.className = "alert alert-info";\n          let err_txt = document.createTextNode(\n            "No data found for the benchmarking event: \'" + bench_id + "\'"\n          );\n          para.appendChild(err_txt);\n          tablediv.appendChild(para);\n        } else {\n          show_loading_spinner(divid, false);\n          tablediv.innerHTML = "";\n          let para = document.createElement("div");\n          para.className = "alert alert-info";\n          let err_txt = document.createTextNode(\n            "There is an error in the server. Please try again or contact with the support team"\n          );\n          para.appendChild(err_txt);\n          tablediv.appendChild(para);\n        }\n        throw response;\n      }\n\n      return response.json();\n    })\n    .then((results) => {\n      let bench_id = jquery__WEBPACK_IMPORTED_MODULE_0___default()(tablediv).data("benchmarkingevent");\n      if (\n        (results.data !== undefined && results.data == null) ||\n        results.length == 0\n      ) {\n        show_loading_spinner(divid, false);\n        tablediv.innerHTML = "";\n        let para = document.createElement("div");\n        para.className = "alert alert-info";\n        let err_txt = document.createTextNode(\n          "No data available for the benchmarking event: \'" + bench_id + "\'"\n        );\n        para.appendChild(err_txt);\n        tablediv.appendChild(para);\n      } else {\n        // console.log(bench_id, results);\n        let community_id = "OEBC" + bench_id.substring(4, 7);\n\n        const fetch = Object(apollo_fetch__WEBPACK_IMPORTED_MODULE_8__["createApolloFetch"])({\n          //fallback to legacy if no api_url is defined\n          uri: api_url\n            ? api_url\n            : url_join__WEBPACK_IMPORTED_MODULE_7___default()("https://" + mode + ".bsc.es/", "sciapi/graphql"),\n        });\n\n        const fetchData = () =>\n          fetch({\n            query: `query getTools($community_id: String!){\n                            getTools(toolFilters:{community_id: $community_id}) {\n                                registry_tool_id\n                                name\n                            }\n                        }`,\n            variables: { community_id: community_id },\n          });\n\n        fetchData().then((response) => {\n          let tool_list = response.data.getTools;\n\n          // iterate over the list of tools to generate a dictionary\n          let tool_elixir_ids = {};\n          tool_list.forEach(function (tool) {\n            if (tool.registry_tool_id != null) {\n              tool_elixir_ids[tool.name] = tool.registry_tool_id\n                .split(":")[1]\n                .toLowerCase();\n            } else {\n              tool_elixir_ids[tool.name] = null;\n            }\n          });\n\n          fill_in_table(\n            divid,\n            results,\n            mode,\n            tool_elixir_ids,\n            community_id,\n            bench_id,\n            chunk_size,\n            api_url\n          );\n          show_loading_spinner(divid, false);\n        });\n      }\n    })\n    .catch((err) => console.log(err));\n}\n\nfunction load_table(\n  divid,\n  challenge_list = [],\n  classifier = "diagonal",\n  chunk_size = 10\n) {\n  remove_table(divid);\n\n  let droplist_id = divid + "_bench_dropdown_list";\n  let droplist = document.getElementById(droplist_id);\n  if (droplist == null) {\n    //add dropdown list\n    droplist = document.createElement("select");\n    droplist.id = droplist_id;\n    droplist.className = "classificator_list";\n\n    let bench_table = document.getElementById(divid);\n\n    let droplist_label = document.createElement("label");\n    droplist_label.htmlFor = droplist_id;\n    droplist_label.innerText = "Classification Method:";\n\n    // add option group\n    let group = document.createElement("OptGroup");\n    group.label = "Select a classification method:";\n    droplist.add(group);\n\n    // add list options\n    let option1 = document.createElement("option");\n    option1.class = "selection_option";\n    option1.id = divid + "_classificator__squares";\n    option1.title =\n      "Apply square quartiles classification method (based on the 0.5 quartile of the X and Y metrics)";\n    option1.data = ("toggle", "list_tooltip");\n    option1.data = ("container", "#tooltip_container");\n    option1.value = "squares";\n    option1.innerHTML = "SQUARE QUARTILES";\n\n    let option2 = document.createElement("option");\n    option2.class = "selection_option";\n    option2.id = divid + "_classificator__diagonals";\n    option2.title =\n      "Apply diagonal quartiles classifcation method (based on the assignment of a score to each participant proceeding from its distance to the \'optimal performance\' corner)";\n    option2.data = ("toggle", "list_tooltip");\n    option2.data = ("container", "#tooltip_container");\n    option2.value = "diagonals";\n    option2.innerHTML = "DIAGONAL QUARTILES";\n\n    let option3 = document.createElement("option");\n    option3.class = "selection_option";\n    option3.id = divid + "_classificator__clusters";\n    option3.title =\n      "Apply k-means clustering algorithm to group the participants";\n    option3.data = ("toggle", "list_tooltip");\n    option3.data = ("container", "#tooltip_container");\n    option3.value = "clusters";\n    option3.innerHTML = "K-MEANS CLUSTERING";\n\n    group.appendChild(option1);\n    group.appendChild(option2);\n    group.appendChild(option3);\n\n    let selected_classifier = classifier;\n\n    if (selected_classifier) {\n      switch (selected_classifier) {\n        case "squares":\n          option1.selected = "disabled";\n          break;\n        case "diagonals":\n          option2.selected = "disabled";\n          break;\n        case "clusters":\n          option3.selected = "disabled";\n          break;\n        default:\n          option2.selected = "disabled";\n          break;\n      }\n    }\n\n    bench_table.appendChild(droplist_label);\n    bench_table.appendChild(droplist);\n  }\n\n  jquery__WEBPACK_IMPORTED_MODULE_0___default()(droplist).off();\n  jquery__WEBPACK_IMPORTED_MODULE_0___default()(droplist).on("change", function () {\n    //compute_classification(divid, this.options[this.selectedIndex].id.split(\'__\')[1], challenge_list, chunk_size);\n    compute_classification(\n      divid,\n      this.options[this.selectedIndex].value,\n      challenge_list,\n      chunk_size\n    );\n  });\n\n  //compute_classification(divid, droplist.options[droplist.selectedIndex].id.split(\'__\')[1], challenge_list, chunk_size);\n  compute_classification(\n    divid,\n    droplist.options[droplist.selectedIndex].value,\n    challenge_list,\n    chunk_size\n  );\n}\n\nfunction run_summary_table(challenge_list = [], active_table = null) {\n  if (challenge_list.length == 0 && active_table == null) {\n    let tables = document.getElementsByClassName("oeb-table");\n    let i = 0;\n    let dataId;\n    let y;\n\n    // append ids to divs\n    i = 0;\n    for (y of tables) {\n      // get benchmarking event id\n      dataId = y.getAttribute("data-benchmarkingevent");\n\n      //set chart id\n      let divid = dataId.replace(":", "_");\n      y.id = divid;\n      load_table(divid, challenge_list);\n      i++;\n    }\n  } else {\n    load_table(active_table, challenge_list);\n  }\n}\n\nfunction remove_table(divid) {\n  let tablediv_id = divid + "_oeb-table-scroll";\n  let tablediv = document.getElementById(tablediv_id);\n  if (tablediv != null) {\n    tablediv.remove();\n  }\n\n  return tablediv_id;\n}\n\nfunction show_loading_spinner(divid, loading) {\n  let spinner_id = divid + "-loading";\n  let spinner_div = document.getElementById(spinner_id);\n\n  // Check if the table exists (divid + \'_oeb-table-scroll\')\n  let table_div = document.getElementById(divid + "_oeb-table-scroll");\n\n  if (!spinner_div) {\n    spinner_div = document.createElement("div");\n    spinner_div.id = spinner_id;\n    spinner_div.className = "spinner-container";\n\n    // Create the image element for the spinner\n    let spinner_img = document.createElement("img");\n    spinner_img.loading = "lazy";\n    spinner_img.src = _loaderImage_js__WEBPACK_IMPORTED_MODULE_9__["loaderImage"];\n    spinner_img.className = "spinner";\n\n    spinner_div.appendChild(spinner_img);\n    document.getElementById(divid).appendChild(spinner_div);\n  }\n\n  spinner_div.style.display = loading ? "flex" : "none";\n\n  if (table_div) {\n    table_div.style.display = loading ? "none" : "block";\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hcHAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAuanM/OWE3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJCBmcm9tIFwianF1ZXJ5XCI7XG5pbXBvcnQgXCJqcXVlcnktdWkvdGhlbWVzL2Jhc2UvY29yZS5jc3NcIjtcbmltcG9ydCBcImpxdWVyeS11aS90aGVtZXMvYmFzZS90aGVtZS5jc3NcIjtcbmltcG9ydCBcImpxdWVyeS11aS90aGVtZXMvYmFzZS90YWJzLmNzc1wiO1xuaW1wb3J0IFwianF1ZXJ5LXVpL3VpL2NvcmVcIjtcbmltcG9ydCBcImpxdWVyeS11aS91aS93aWRnZXRzL3RhYnNcIjtcbmltcG9ydCBcIi4vYXBwLmNzc1wiO1xuaW1wb3J0IHVybGpvaW4gZnJvbSBcInVybC1qb2luXCI7XG5pbXBvcnQgeyBjcmVhdGVBcG9sbG9GZXRjaCB9IGZyb20gXCJhcG9sbG8tZmV0Y2hcIjtcbmltcG9ydCB7IGxvYWRlckltYWdlIH0gZnJvbSBcIi4vbG9hZGVySW1hZ2UuanNcIjtcblxubGV0IHF1YXJ0aWxlX21hcCA9IHtcbiAgMToge1xuICAgIG5hbWU6IFwiUTFcIixcbiAgICBjc3NfY2xhc3M6IFwiUTFcIixcbiAgfSxcbiAgMjoge1xuICAgIG5hbWU6IFwiUTJcIixcbiAgICBjc3NfY2xhc3M6IFwiUTJcIixcbiAgfSxcbiAgMzoge1xuICAgIG5hbWU6IFwiUTNcIixcbiAgICBjc3NfY2xhc3M6IFwiUTNcIixcbiAgfSxcbiAgNDoge1xuICAgIG5hbWU6IFwiUTRcIixcbiAgICBjc3NfY2xhc3M6IFwiUTRcIixcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGZpbGxfaW5fdGFibGUoXG4gIGRpdmlkLFxuICBhZ2dyZWdhdGlvbnMsXG4gIG1vZGUsXG4gIHRvb2xfZWxpeGlyX2lkcyxcbiAgY29tbXVuaXR5X2lkLFxuICBiZW5jaG1hcmtpbmdfZXZlbnRfaWQsXG4gIGNodW5rX3NpemUsXG4gIGFwaV91cmxcbikge1xuICBsZXQga25vd25fdG9vbHMgPSB7fTtcbiAgbGV0IG9yZGVyZWRfdG9vbHMgPSBbXTtcbiAgbGV0IGNoYWxsZW5nZXMgPSB7fTtcbiAgbGV0IGNoYWxsZW5nZXNfbGlzdCA9IFtdO1xuICBsZXQgbnVtX2NoYXJ0cyA9IDA7XG5cbiAgYWdncmVnYXRpb25zLmZvckVhY2goKGFnZ3JlZ2F0aW9uLCBudW0pID0+IHtcbiAgICBpZiAoXCJwYXJ0aWNpcGFudHNcIiBpbiBhZ2dyZWdhdGlvbikge1xuICAgICAgT2JqZWN0LmtleXMoYWdncmVnYXRpb24ucGFydGljaXBhbnRzKS5mb3JFYWNoKCh0b29sbmFtZSwgaSkgPT4ge1xuICAgICAgICBpZiAoISh0b29sbmFtZSBpbiBrbm93bl90b29scykpIHtcbiAgICAgICAgICBrbm93bl90b29sc1t0b29sbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIG9yZGVyZWRfdG9vbHMucHVzaCh0b29sbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCEoYWdncmVnYXRpb24uX2lkIGluIGNoYWxsZW5nZXMpKSB7XG4gICAgICAgIGNoYWxsZW5nZXNbYWdncmVnYXRpb24uX2lkXSA9IFtdO1xuICAgICAgICBjaGFsbGVuZ2VzX2xpc3QucHVzaChjaGFsbGVuZ2VzW2FnZ3JlZ2F0aW9uLl9pZF0pO1xuICAgICAgfVxuICAgICAgY2hhbGxlbmdlc1thZ2dyZWdhdGlvbi5faWRdLnB1c2goYWdncmVnYXRpb24pO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGFnZ3JlZ2F0aW9uLnBhcnRpY2lwYW50cykubGVuZ3RoID4gMCkge1xuICAgICAgICBudW1fY2hhcnRzKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBjaGFsbGVuZ2VzX2xpc3Quc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGNfYSA9IGFbMF0uY2hhbGxlbmdlX2Fjcm9ueW0udG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBjX2IgPSBiWzBdLmNoYWxsZW5nZV9hY3JvbnltLnRvVXBwZXJDYXNlKCk7XG5cbiAgICByZXR1cm4gY19hIDwgY19iID8gLTEgOiBjX2EgPiBjX2IgPyAxIDogMDtcbiAgfSk7XG5cbiAgbGV0IGVtcHR5X2NoYWxsZW5nZXNfbGlzdCA9IFtdO1xuICBsZXQgdXNlZF9jaGFsbGVuZ2VzX2xpc3QgPSBbXTtcbiAgY2hhbGxlbmdlc19saXN0LmZvckVhY2goKGFnZ3JlZ2F0aW9ucykgPT4ge1xuICAgIGxldCBjaGFsbGVuZ2VfbnVtX2NoYXJ0cyA9IGFnZ3JlZ2F0aW9uc1xuICAgICAgLm1hcCgoYWdncmVnYXRpb24pID0+IE9iamVjdC5rZXlzKGFnZ3JlZ2F0aW9uLnBhcnRpY2lwYW50cykubGVuZ3RoKVxuICAgICAgLnJlZHVjZSgocHMsIGEpID0+IHBzICsgYSwgMCk7XG4gICAgaWYgKGNoYWxsZW5nZV9udW1fY2hhcnRzID4gMCkge1xuICAgICAgdXNlZF9jaGFsbGVuZ2VzX2xpc3QucHVzaChhZ2dyZWdhdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbXB0eV9jaGFsbGVuZ2VzX2xpc3QucHVzaChhZ2dyZWdhdGlvbnMpO1xuICAgIH1cbiAgfSk7XG5cbiAgbGV0IGZvcmNlX2JyZWFrID0gZmFsc2U7XG4gIGxldCByZWR1Y2VfbGFtYmRhID0gKGFnZ3JlZ2F0aW9uX3NsaWNlcywgYWdncmVnYXRpb25zKSA9PiB7XG4gICAgbGV0IGxhc3RpZHggPSBhZ2dyZWdhdGlvbl9zbGljZXMubGVuZ3RoIC0gMTtcbiAgICBpZiAoXG4gICAgICBsYXN0aWR4ID09IC0xIHx8XG4gICAgICBhZ2dyZWdhdGlvbl9zbGljZXNbbGFzdGlkeF0ubWVtYmVycy5sZW5ndGggKyBhZ2dyZWdhdGlvbnMubGVuZ3RoID49XG4gICAgICAgIGNodW5rX3NpemUgfHxcbiAgICAgIGZvcmNlX2JyZWFrXG4gICAgKSB7XG4gICAgICBmb3JjZV9icmVhayA9IGZhbHNlO1xuICAgICAgbGV0IGFnZ3JlZ2F0aW9uX3RhYiA9IHtcbiAgICAgICAgZnJvbTogYWdncmVnYXRpb25zWzBdLmNoYWxsZW5nZV9hY3JvbnltLFxuICAgICAgICB0bzogYWdncmVnYXRpb25zWzBdLmNoYWxsZW5nZV9hY3JvbnltLFxuICAgICAgICBtZW1iZXJzOiBbLi4uYWdncmVnYXRpb25zXSxcbiAgICAgICAgZW1wdHlfY2hhbGxlbmdlOiBPYmplY3Qua2V5cyhhZ2dyZWdhdGlvbnNbMF0ucGFydGljaXBhbnRzKS5sZW5ndGggPT09IDAsXG4gICAgICB9O1xuICAgICAgYWdncmVnYXRpb25fc2xpY2VzLnB1c2goYWdncmVnYXRpb25fdGFiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGFnZ3JlZ2F0aW9uX3RhYiA9IGFnZ3JlZ2F0aW9uX3NsaWNlc1tsYXN0aWR4XTtcbiAgICAgIGFnZ3JlZ2F0aW9uX3RhYi5tZW1iZXJzLnB1c2goLi4uYWdncmVnYXRpb25zKTtcbiAgICAgIGFnZ3JlZ2F0aW9uX3RhYi50byA9IGFnZ3JlZ2F0aW9uc1swXS5jaGFsbGVuZ2VfYWNyb255bTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWdncmVnYXRpb25fc2xpY2VzO1xuICB9O1xuXG4gIGxldCBhZ2dyZWdhdGlvbl9zbGljZXMgPSB1c2VkX2NoYWxsZW5nZXNfbGlzdC5yZWR1Y2UocmVkdWNlX2xhbWJkYSwgW10pO1xuICBmb3JjZV9icmVhayA9IHRydWU7XG4gIGFnZ3JlZ2F0aW9uX3NsaWNlcyA9IGVtcHR5X2NoYWxsZW5nZXNfbGlzdC5yZWR1Y2UoXG4gICAgcmVkdWNlX2xhbWJkYSxcbiAgICBhZ2dyZWdhdGlvbl9zbGljZXNcbiAgKTtcblxuICBsZXQgc2xpY2VzZGl2X2lkID0gcmVtb3ZlX3RhYmxlKGRpdmlkKTtcbiAgbGV0IHNsaWNlc2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHNsaWNlc2Rpdi5pZCA9IHNsaWNlc2Rpdl9pZDtcbiAgbGV0IHBhcmVudERpdlRhYmxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGl2aWQpO1xuICBwYXJlbnREaXZUYWJsZS5hcHBlbmRDaGlsZChzbGljZXNkaXYpO1xuXG4gIGxldCB0YWJjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB0YWJjb250YWluZXIuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJ0YWJzLWNvbnRhaW5lclwiKTtcbiAgc2xpY2VzZGl2LmFwcGVuZENoaWxkKHRhYmNvbnRhaW5lcik7XG5cbiAgbGV0IGJ1dHRvbmxlZnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICBidXR0b25sZWZ0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYXJyb3cgbGVmdC1hcnJvd1wiKTtcbiAgYnV0dG9ubGVmdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiUHJldmlvdXMgdGFic1wiKTtcbiAgYnV0dG9ubGVmdC5pbm5lckhUTUwgPSBcIiZsdDtcIjtcbiAgdGFiY29udGFpbmVyLmFwcGVuZENoaWxkKGJ1dHRvbmxlZnQpO1xuXG4gIGxldCB0YWJ3cmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgdGFid3JhcC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInRhYnMtd3JhcHBlclwiKTtcbiAgdGFiY29udGFpbmVyLmFwcGVuZENoaWxkKHRhYndyYXApO1xuXG4gIGxldCB0YWJsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuICB0YWJsaXN0LnNldEF0dHJpYnV0ZShcbiAgICBcInRpdGxlXCIsXG4gICAgYENvbW11bml0eSAke2NvbW11bml0eV9pZH0gZXZlbnQgJHtiZW5jaG1hcmtpbmdfZXZlbnRfaWR9YFxuICApO1xuICB0YWJ3cmFwLmFwcGVuZENoaWxkKHRhYmxpc3QpO1xuXG4gIGxldCBidXR0b25yaWdodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gIGJ1dHRvbnJpZ2h0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYXJyb3cgcmlnaHQtYXJyb3dcIik7XG4gIGJ1dHRvbnJpZ2h0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJOZXh0IHRhYnNcIik7XG4gIGJ1dHRvbnJpZ2h0LmlubmVySFRNTCA9IFwiJmd0O1wiO1xuICB0YWJjb250YWluZXIuYXBwZW5kQ2hpbGQoYnV0dG9ucmlnaHQpO1xuXG4gIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICBjb25zdCBtYXhWaXNpYmxlVGFicyA9IDEwO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZUFycm93QnV0dG9ucygpIHtcbiAgICBidXR0b25sZWZ0LmRpc2FibGVkID0gY3VycmVudEluZGV4ID09PSAwO1xuICAgIGJ1dHRvbnJpZ2h0LmRpc2FibGVkID1cbiAgICAgIGN1cnJlbnRJbmRleCA+PSB0YWJsaXN0LmNoaWxkcmVuLmxlbmd0aCAtIG1heFZpc2libGVUYWJzO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvd1Zpc2libGVUYWJzKCkge1xuICAgIGxldCB0YWJIZWlnaHQgPSB0YWJsaXN0LmNoaWxkcmVuWzBdLm9mZnNldEhlaWdodDsgLy8gR2V0IHRoZSBoZWlnaHQgb2YgdGhlIGZpcnN0IHRhYlxuICAgIGNvbnN0IHRvdGFsVGFicyA9IHRhYmxpc3QuY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFRhYnM7IGkrKykge1xuICAgICAgaWYgKGkgPj0gY3VycmVudEluZGV4ICYmIGkgPCBjdXJyZW50SW5kZXggKyBtYXhWaXNpYmxlVGFicykge1xuICAgICAgICB0YWJsaXN0LmNoaWxkcmVuW2ldLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFibGlzdC5jaGlsZHJlbltpXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGFycm93cyB2aXNpYmlsaXR5XG4gICAgaWYgKHRvdGFsVGFicyA8PSBtYXhWaXNpYmxlVGFicykge1xuICAgICAgYnV0dG9ubGVmdC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBidXR0b25yaWdodC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICB0YWJsaXN0LnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1dHRvbmxlZnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIGJ1dHRvbnJpZ2h0LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfVxuXG4gICAgLy8gQWRkIGVtcHR5IHRhYnMgdG8gbWFpbnRhaW4gaGVpZ2h0IGlmIGZld2VyIHRhYnMgb24gdGhlIGZpbmFsIHBhZ2VcbiAgICBsZXQgdGFic1RvU2hvdyA9IE1hdGgubWluKHRvdGFsVGFicyAtIGN1cnJlbnRJbmRleCwgbWF4VmlzaWJsZVRhYnMpO1xuICAgIGxldCBlbXB0eVRhYnMgPSBtYXhWaXNpYmxlVGFicyAtIHRhYnNUb1Nob3c7XG4gICAgd2hpbGUgKGVtcHR5VGFicyA+IDApIHtcbiAgICAgIGxldCBlbXB0eVRhYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICAgIGVtcHR5VGFiLmNsYXNzTmFtZSA9IFwiZW1wdHktdGFiXCI7XG4gICAgICBlbXB0eVRhYi5zdHlsZS5oZWlnaHQgPSBgJHt0YWJIZWlnaHR9cHhgOyAvLyBNYXRjaCB0aGUgaGVpZ2h0IG9mIHRoZSB2aXNpYmxlIHRhYnNcbiAgICAgIHRhYmxpc3QuYXBwZW5kQ2hpbGQoZW1wdHlUYWIpO1xuICAgICAgZW1wdHlUYWJzLS07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsVGFicyhkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInJpZ2h0XCIpIHtcbiAgICAgIGN1cnJlbnRJbmRleCArPSBtYXhWaXNpYmxlVGFicztcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudEluZGV4IC09IG1heFZpc2libGVUYWJzO1xuICAgIH1cblxuICAgIHNob3dWaXNpYmxlVGFicygpO1xuICAgIHVwZGF0ZUFycm93QnV0dG9ucygpO1xuICAgIHVwZGF0ZVBhZ2luYXRvcigpOyAvLyBVcGRhdGUgcGFnaW5hdG9yIHdoZW4gdGFicyBhcmUgc2Nyb2xsZWRcbiAgfVxuXG4gIGJ1dHRvbnJpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgc2Nyb2xsVGFicyhcInJpZ2h0XCIpO1xuICB9KTtcbiAgYnV0dG9ubGVmdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgIHNjcm9sbFRhYnMoXCJsZWZ0XCIpO1xuICB9KTtcblxuICAvLyBDcmVhdGUgdGhlIHBhZ2luYXRvclxuICBsZXQgcGFnaW5hdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgcGFnaW5hdG9yLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwidGFicy1mb290ZXJcIik7XG4gIHNsaWNlc2Rpdi5hcHBlbmRDaGlsZChwYWdpbmF0b3IpO1xuXG4gIGxldCBjaGFsbGVuZ2VfcmVwb3J0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gIGNoYWxsZW5nZV9yZXBvcnQuYXBwZW5kQ2hpbGQoXG4gICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXG4gICAgICBjaGFsbGVuZ2VzX2xpc3QubGVuZ3RoLnRvU3RyaW5nKCkgK1xuICAgICAgICBcIiBDaGFsbGVuZ2VzLCBcIiArXG4gICAgICAgIG51bV9jaGFydHMudG9TdHJpbmcoKSArXG4gICAgICAgIFwiIGNoYXJ0c1wiXG4gICAgKVxuICApO1xuICBjaGFsbGVuZ2VfcmVwb3J0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwicmVwb3J0XCIpO1xuICBwYWdpbmF0b3IuYXBwZW5kQ2hpbGQoY2hhbGxlbmdlX3JlcG9ydCk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlUGFnaW5hdG9yKCkge1xuICAgIGNvbnN0IHRvdGFsVGFicyA9IEFycmF5LmZyb20odGFibGlzdC5jaGlsZHJlbikuZmlsdGVyKFxuICAgICAgKGNoaWxkKSA9PiAhY2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZW1wdHktdGFiXCIpXG4gICAgKS5sZW5ndGg7XG4gICAgY29uc3QgdG90YWxQYWdlcyA9IE1hdGguY2VpbCh0b3RhbFRhYnMgLyBtYXhWaXNpYmxlVGFicyk7XG4gICAgY29uc3QgY3VycmVudFBhZ2UgPSBNYXRoLmZsb29yKGN1cnJlbnRJbmRleCAvIG1heFZpc2libGVUYWJzKSArIDE7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHJhbmdlIG9mIHZpc2libGUgdGFic1xuICAgIGNvbnN0IHN0YXJ0VGFiID0gY3VycmVudEluZGV4ICsgMTsgLy8gU3RhcnQgaW5kZXggZm9yIHZpc2libGUgdGFicyAoMS1iYXNlZClcbiAgICBjb25zdCBlbmRUYWIgPSBNYXRoLm1pbihjdXJyZW50SW5kZXggKyBtYXhWaXNpYmxlVGFicywgdG90YWxUYWJzKTsgLy8gRW5kIGluZGV4IGZvciB2aXNpYmxlIHRhYnMgKDEtYmFzZWQpXG5cbiAgICAvLyBDaGVjayBpZiB0aGUgcGFnaW5hdG9yIGFscmVhZHkgY29udGFpbnMgYSA8cD4gZWxlbWVudCB3aXRoIGNsYXNzIFwicGFnc1wiXG4gICAgbGV0IGNvdW50ZXIgPSBwYWdpbmF0b3IucXVlcnlTZWxlY3RvcihcIi5wYWdzXCIpO1xuXG4gICAgaWYgKCFjb3VudGVyKSB7XG4gICAgICAvLyBJZiBubyA8cD4gZWxlbWVudCBleGlzdHMsIGNyZWF0ZSBpdFxuICAgICAgY291bnRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xuICAgICAgY291bnRlci5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInBhZ3NcIik7XG4gICAgICBwYWdpbmF0b3IuYXBwZW5kQ2hpbGQoY291bnRlcik7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBjb250ZW50IG9mIHRoZSBleGlzdGluZyA8cD4gZWxlbWVudFxuICAgIGNvdW50ZXIuaW5uZXJIVE1MID0gYCR7c3RhcnRUYWJ9LSR7ZW5kVGFifSB0YWJzIG9mICR7dG90YWxUYWJzfSB0YWJzLCAke2N1cnJlbnRQYWdlfS8ke3RvdGFsUGFnZXN9IHBhZ2VzYDtcbiAgfVxuXG4gIGFnZ3JlZ2F0aW9uX3NsaWNlcy5mb3JFYWNoKChhZ2dyZWdhdGlvbnNfc2xpY2UsIHNsaWNlX2kpID0+IHtcbiAgICBpZiAoXG4gICAgICAhYWdncmVnYXRpb25zX3NsaWNlLm1lbWJlcnMgfHxcbiAgICAgIGFnZ3JlZ2F0aW9uc19zbGljZS5tZW1iZXJzLmxlbmd0aCA9PT0gMFxuICAgICkge1xuICAgICAgLy8gU2tpcCBlbXB0eSB0YWJzXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB0YWJoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XG4gICAgaWYgKGFnZ3JlZ2F0aW9uc19zbGljZS5lbXB0eV9jaGFsbGVuZ2UpIHtcbiAgICAgIHRhYmhlYWRlci5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImVtcHR5LWNoYWxsZW5nZVwiKTtcbiAgICB9XG4gICAgbGV0IHRhYl9hID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgbGV0IHNoaWZ0X3NsaWNlX2lkID0gc2xpY2VzZGl2X2lkICsgXCItXCIgKyBzbGljZV9pO1xuICAgIHRhYl9hLmhyZWYgPSBcIiNcIiArIHNoaWZ0X3NsaWNlX2lkO1xuXG4gICAgbGV0IHRhYnRleHQ7XG4gICAgaWYgKGFnZ3JlZ2F0aW9uc19zbGljZS5mcm9tID09IGFnZ3JlZ2F0aW9uc19zbGljZS50bykge1xuICAgICAgdGFidGV4dCA9IGFnZ3JlZ2F0aW9uc19zbGljZS5mcm9tO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWJ0ZXh0ID0gYWdncmVnYXRpb25zX3NsaWNlLmZyb20gKyBcIlxcdTAwQTB0byBcIiArIGFnZ3JlZ2F0aW9uc19zbGljZS50bztcbiAgICB9XG5cbiAgICBsZXQgc3Bhbl9saW1pdHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBzcGFuX2xpbWl0cy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0YWJ0ZXh0KSk7XG4gICAgc3Bhbl9saW1pdHMuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJ0YWJsaW1pdHNcIik7XG4gICAgdGFiX2EuYXBwZW5kQ2hpbGQoc3Bhbl9saW1pdHMpO1xuXG4gICAgdGFiX2Euc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgdGFidGV4dCk7XG4gICAgdGFiaGVhZGVyLmFwcGVuZENoaWxkKHRhYl9hKTtcbiAgICB0YWJsaXN0LmFwcGVuZENoaWxkKHRhYmhlYWRlcik7XG5cbiAgICBsZXQgc2Nyb2xsYWJsZURpdiA9IGZpbGxfaW5fdGFibGVfc2xpY2UoXG4gICAgICBhZ2dyZWdhdGlvbnNfc2xpY2UubWVtYmVycyxcbiAgICAgIG1vZGUsXG4gICAgICB0b29sX2VsaXhpcl9pZHMsXG4gICAgICBjb21tdW5pdHlfaWQsXG4gICAgICBvcmRlcmVkX3Rvb2xzLFxuICAgICAgYXBpX3VybFxuICAgICk7XG4gICAgc2Nyb2xsYWJsZURpdi5pZCA9IHNoaWZ0X3NsaWNlX2lkO1xuICAgIHNsaWNlc2Rpdi5hcHBlbmRDaGlsZChzY3JvbGxhYmxlRGl2KTtcbiAgfSk7XG5cbiAgLy8gSW5pdGlhbCBzdGF0ZTogc2hvdyBvbmx5IHRoZSBmaXJzdCAxMCB0YWJzXG4gIHNob3dWaXNpYmxlVGFicygpO1xuICB1cGRhdGVBcnJvd0J1dHRvbnMoKTtcbiAgdXBkYXRlUGFnaW5hdG9yKCk7IC8vIEluaXRpYWxpemUgcGFnaW5hdG9yXG4gICQoc2xpY2VzZGl2KS50YWJzKHsgYWN0aXZlOiAwIH0pO1xufVxuXG5mdW5jdGlvbiBmaWxsX2luX3RhYmxlX3NsaWNlKFxuICBhZ2dyZWdhdGlvbnMsXG4gIG1vZGUsXG4gIHRvb2xfZWxpeGlyX2lkcyxcbiAgY29tbXVuaXR5X2lkLFxuICBvcmRlcmVkX3Rvb2xzLFxuICBhcGlfdXJsXG4pIHtcbiAgbGV0IHNjcm9sbGFibGVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBzY3JvbGxhYmxlRGl2LmNsYXNzTmFtZSA9IFwib2ViLXRhYmxlLXNjcm9sbFwiO1xuXG4gIC8vIENyZWF0ZSB0YWJsZSBkeW5hbWljYWxseVxuICBsZXQgdGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGFibGVcIik7XG4gIHRhYmxlLmNsYXNzTmFtZSA9IFwib2ViLW1haW4tdGFibGVcIjtcbiAgc2Nyb2xsYWJsZURpdi5hcHBlbmRDaGlsZCh0YWJsZSk7XG5cbiAgbGV0IHRoZWFkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRoZWFkXCIpO1xuICBsZXQgdGJvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIik7XG4gIHRhYmxlLmFwcGVuZENoaWxkKHRoZWFkKTtcbiAgdGFibGUuYXBwZW5kQ2hpbGQodGJvZHkpO1xuXG4gIC8vIEFkZCBjaGFsbGVuZ2UgYW5kIHRvb2wgZml4ZWQgdG9wIGxlZnRcbiAgbGV0IGNoYWxsZW5nZXNfcm93ID0gdGhlYWQuaW5zZXJ0Um93KCk7XG4gIGxldCBjaF90aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0aFwiKTtcbiAgY2hfdGguaW5uZXJIVE1MID0gXCI8Yj5DaGFsbGVuZ2VzJm5ic3A7JiM4NTk0PC9iPlwiO1xuICBjaGFsbGVuZ2VzX3Jvdy5hcHBlbmRDaGlsZChjaF90aCk7XG5cbiAgbGV0IGFnZ3JlZ2F0aW9uc19yb3cgPSB0aGVhZC5pbnNlcnRSb3coKTtcbiAgbGV0IHRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRoXCIpO1xuICB0aC5pbm5lckhUTUwgPSBcIjxiPkNoYXJ0cyZuYnNwOyYjODU5NCAgPGJyPlBhcnRpY2lwYW50cyZuYnNwOyYjODU5NTwvYj5cIjtcbiAgYWdncmVnYXRpb25zX3Jvdy5hcHBlbmRDaGlsZCh0aCk7XG5cbiAgLy8gQXBwZW5kIHJvd3Mgd2l0aCBhbGwgcGFydGljaXBhbnRzIGluIHRoZSBiZW5jaG1hcmtcbiAgb3JkZXJlZF90b29scy5mb3JFYWNoKCh0b29sbmFtZSkgPT4ge1xuICAgIGxldCByb3cgPSB0Ym9keS5pbnNlcnRSb3coLTEpO1xuICAgIGxldCB0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0aFwiKTtcbiAgICBsZXQgZGl2cGFydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2cGFydC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImFnZ3JlZ2F0aW9uX2NlbGxcIik7XG4gICAgdGguYXBwZW5kQ2hpbGQoZGl2cGFydCk7XG5cbiAgICBsZXQgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIGlmICh0b29sX2VsaXhpcl9pZHNbdG9vbG5hbWVdICE9IG51bGwpIHtcbiAgICAgIGxldCB0ZWNobmljYWxfdXJsID0gdXJsam9pbihcbiAgICAgICAgXCJodHRwczovL1wiICsgbW9kZSArIFwiLmJzYy5lcy90b29sL1wiLFxuICAgICAgICB0b29sX2VsaXhpcl9pZHNbdG9vbG5hbWVdXG4gICAgICApO1xuICAgICAgYS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHRlY2huaWNhbF91cmwpO1xuICAgICAgYS5zZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIiwgXCJfYmxhbmtcIik7XG4gICAgICBhLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYWdncmVnYXRpb25fY2VsbF8yXCIpO1xuICAgIH1lbHNle1xuICAgICAgYS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImNvbG9yOmJsYWNrXCIpO1xuICAgICAgYS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInBvaW50ZXI6ZGVmYXVsdFwiKTtcbiAgICB9XG4gICAgYS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0b29sbmFtZSkpO1xuICAgIGEuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgdG9vbG5hbWUpO1xuICAgIGRpdnBhcnQuYXBwZW5kQ2hpbGQoYSk7XG4gICAgdGguZGF0YXNldC50b29sbmFtZSA9IHRvb2xuYW1lO1xuICAgIHJvdy5hcHBlbmRDaGlsZCh0aCk7XG4gIH0pO1xuXG4gIC8vIEl0IGhhcyB0byBiZSBkb25lIGluIHR3byBwYXNzZXMgYmVjYXVzZSB0aGUgbnVtYmVyIG9mIHJvd3MgaGF2ZSB0byBiZSBcImtub3duXCIgYmVmb3JlaGFuZFxuICBsZXQgZHJhd25fY2hhbGxlbmdlX2hlYWRlcnMgPSB7fTtcbiAgYWdncmVnYXRpb25zLmZvckVhY2goKGFnZ3JlZ2F0aW9uLCBudW0pID0+IHtcbiAgICBpZiAoXCJwYXJ0aWNpcGFudHNcIiBpbiBhZ2dyZWdhdGlvbikge1xuICAgICAgLy8gQXBwZW5kIGNvbHVtbnMgd2l0aCBhZ2dyZWdhdGlvbnMgYW5kIHJlc3VsdHNcbiAgICAgIGxldCBjb2x1bW5fdmFsdWVfZGljdCA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMoYWdncmVnYXRpb24ucGFydGljaXBhbnRzKS5mb3JFYWNoKCh0b29sbmFtZSwgaikgPT4ge1xuICAgICAgICBjb2x1bW5fdmFsdWVfZGljdFt0b29sbmFtZV0gPSBhZ2dyZWdhdGlvbi5wYXJ0aWNpcGFudHNbdG9vbG5hbWVdO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIENoYWxsZW5nZSBzcGVjaWZpYyBjZWxsXG4gICAgICBsZXQgdXJsID0gdXJsam9pbihcbiAgICAgICAgXCJodHRwczovL1wiICsgbW9kZSArIFwiLmJzYy5lcy9zY2llbnRpZmljL1wiLFxuICAgICAgICBjb21tdW5pdHlfaWQsXG4gICAgICAgIGFnZ3JlZ2F0aW9uLl9pZFxuICAgICAgKTtcbiAgICAgIGxldCB0aGVfY29sc3BhbiA9IDE7XG4gICAgICBsZXQgY2hfdGggPSBudWxsO1xuICAgICAgaWYgKGFnZ3JlZ2F0aW9uLl9pZCBpbiBkcmF3bl9jaGFsbGVuZ2VfaGVhZGVycykge1xuICAgICAgICAvLyBJbmNyZWFzZSB0aGUgY29sc3BhblxuICAgICAgICBjaF90aCA9IGRyYXduX2NoYWxsZW5nZV9oZWFkZXJzW2FnZ3JlZ2F0aW9uLl9pZF07XG4gICAgICAgIGxldCBjb2xzcGFuc3RyID0gY2hfdGguZ2V0QXR0cmlidXRlKFwiY29sc3BhblwiKTtcbiAgICAgICAgdGhlX2NvbHNwYW4gPSBwYXJzZUludChjb2xzcGFuc3RyKTtcbiAgICAgICAgdGhlX2NvbHNwYW4rKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoX3RoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRoXCIpO1xuICAgICAgICBsZXQgYWdnZGl2Y2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGFnZ2RpdmNlbGwuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJhZ2dyZWdhdGlvbl9jZWxsXCIpO1xuXG4gICAgICAgIGxldCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgIGEuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCB1cmwpO1xuICAgICAgICBhLnNldEF0dHJpYnV0ZShcInRhcmdldFwiLCBcImJsYW5rXCIpO1xuICAgICAgICBhLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYWdncmVnYXRpb25fY2VsbF8yXCIpO1xuICAgICAgICBsZXQgYWNyb255bSA9XG4gICAgICAgICAgXCJjaGFsbGVuZ2VfYWNyb255bVwiIGluIGFnZ3JlZ2F0aW9uXG4gICAgICAgICAgICA/IGFnZ3JlZ2F0aW9uLmNoYWxsZW5nZV9hY3JvbnltXG4gICAgICAgICAgICA6IGFnZ3JlZ2F0aW9uLmFjcm9ueW07XG4gICAgICAgIGEuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYWNyb255bSkpO1xuICAgICAgICBhLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIGFjcm9ueW0pO1xuICAgICAgICBhZ2dkaXZjZWxsLmFwcGVuZENoaWxkKGEpO1xuICAgICAgICBjaF90aC5hcHBlbmRDaGlsZChhZ2dkaXZjZWxsKTtcbiAgICAgICAgY2hfdGguaWQgPSBhZ2dyZWdhdGlvbi5faWQ7XG4gICAgICAgIGNoYWxsZW5nZXNfcm93LmFwcGVuZENoaWxkKGNoX3RoKTtcbiAgICAgICAgZHJhd25fY2hhbGxlbmdlX2hlYWRlcnNbYWdncmVnYXRpb24uX2lkXSA9IGNoX3RoO1xuICAgICAgfVxuICAgICAgY2hfdGguc2V0QXR0cmlidXRlKFwiY29sc3BhblwiLCB0aGVfY29sc3Bhbi50b1N0cmluZygpKTtcblxuICAgICAgLy8gQWdncmVnYXRpb24gc3BlY2lmaWMgY2VsbFxuICAgICAgbGV0IHRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRoXCIpO1xuICAgICAgbGV0IGRpdmNlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2Y2VsbC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImFnZ3JlZ2F0aW9uX2NlbGxcIik7XG4gICAgICBsZXQgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgLy9hLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgdXJsKTtcbiAgICAgIC8vYS5zZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIiwgXCJibGFua1wiKTtcbiAgICAgIGlmIChhZ2dyZWdhdGlvbi5hZ2dyZWdhdGlvbl9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoLmlkID0gYWdncmVnYXRpb24uYWdncmVnYXRpb25faWQ7XG4gICAgICAgIGFnZ3JlZ2F0aW9uLm1ldHJpY3MuZm9yRWFjaCgobV9lbnRyeSwgbV9lbnRyeV9pKSA9PiB7XG4gICAgICAgICAgaWYgKG1fZW50cnlfaSA+IDApIHtcbiAgICAgICAgICAgIGEuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwibm90Ym9sZCBpdGFsaWNcIik7XG4gICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwidnNcIikpO1xuICAgICAgICAgICAgYS5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICAgIGEuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGNvbnRlbnQ7XG4gICAgICAgICAgaWYgKG1fZW50cnkgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJGSVhNRTogbWV0cmljcyBsYWJlbCBub3QgaW4gY2hhbGxlbmdlXCIsIGFnZ3JlZ2F0aW9uKTtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcbiAgICAgICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ1bmRlZmluZWRcIikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobV9lbnRyeS50aXRsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGEuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcbiAgICAgICAgICBcIk5vIGNoYXJ0IGJhc2VkIG9uIFwiICsgYWdncmVnYXRpb24ubWV0cmljc19jYXRlZ29yeV9pZFxuICAgICAgICApO1xuICAgICAgICBhLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICBhLnNldEF0dHJpYnV0ZShcInRhcmdldFwiLCBcIl9ibGFua1wiKTtcbiAgICAgICAgYS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgXCJocmVmXCIsXG4gICAgICAgICAgdXJsam9pbihcbiAgICAgICAgICAgIGFwaV91cmwsXG4gICAgICAgICAgICBcIi4uL3N0YWdlZC9NZXRyaWNzL1wiICsgYWdncmVnYXRpb24ubWV0cmljc19jYXRlZ29yeV9pZFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRpdmNlbGwuYXBwZW5kQ2hpbGQoYSk7XG4gICAgICB0aC5hcHBlbmRDaGlsZChkaXZjZWxsKTtcbiAgICAgIGFnZ3JlZ2F0aW9uc19yb3cuYXBwZW5kQ2hpbGQodGgpO1xuXG4gICAgICAvLyBPcGVuIGxvb3AgZm9yIGVhY2ggcm93IGFuZCBhcHBlbmQgY2VsbFxuICAgICAgb3JkZXJlZF90b29scy5mb3JFYWNoKChyb3dfdG9vbF9uYW1lLCBpKSA9PiB7XG4gICAgICAgIC8vIE5vbiBoZWFkZXJzXG4gICAgICAgIGxldCBjZWxsID0gdGJvZHkucm93c1tpXS5pbnNlcnRDZWxsKCk7XG4gICAgICAgIGxldCBjZWxsdmFsID0gXCItXCI7XG4gICAgICAgIGlmIChyb3dfdG9vbF9uYW1lIGluIGNvbHVtbl92YWx1ZV9kaWN0KSB7XG4gICAgICAgICAgY2VsbHZhbCA9IHF1YXJ0aWxlX21hcFtjb2x1bW5fdmFsdWVfZGljdFtyb3dfdG9vbF9uYW1lXV0ubmFtZTtcbiAgICAgICAgICBjZWxsLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgIFwiY2xhc3NcIixcbiAgICAgICAgICAgIHF1YXJ0aWxlX21hcFtjb2x1bW5fdmFsdWVfZGljdFtyb3dfdG9vbF9uYW1lXV0uY3NzX2NsYXNzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjZWxsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNlbGx2YWwpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gRnVuY3Rpb24gdG8gcmVjYWxjdWxhdGUgYW5kIGFwcGx5IGhlaWdodCBpbiBsaXN0IG9mIHRhYnNcbiAgZnVuY3Rpb24gdXBkYXRlVGFibGVMYXlvdXQoKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsZXQgZmlyc3RSb3dIZWlnaHQgPSBjaGFsbGVuZ2VzX3Jvdy5vZmZzZXRIZWlnaHQ7XG4gICAgICBsZXQgc2Vjb25kUm93SGVhZGVycyA9IGFnZ3JlZ2F0aW9uc19yb3cucXVlcnlTZWxlY3RvckFsbChcInRoXCIpO1xuICAgICAgbGV0IGZpcnN0SGVhZGVySW5TZWNvbmRSb3cgPVxuICAgICAgICBhZ2dyZWdhdGlvbnNfcm93LnF1ZXJ5U2VsZWN0b3IoXCJ0aDpmaXJzdC1jaGlsZFwiKTtcblxuICAgICAgc2Vjb25kUm93SGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgICAgaGVhZGVyLnN0eWxlLnRvcCA9IGZpcnN0Um93SGVpZ2h0ICsgXCJweFwiO1xuXG4gICAgICAgIGZpcnN0SGVhZGVySW5TZWNvbmRSb3cuc3R5bGUuekluZGV4ID0gXCI5OVwiO1xuICAgICAgfSk7XG4gICAgfSwgMCk7XG4gIH1cblxuICB1cGRhdGVUYWJsZUxheW91dCgpO1xuXG4gIC8vIFdhdGNoIGZvciBjaGFuZ2VzIHRvIHRoZSB0YWJsZSBhbmQgcmVjYWxjdWxhdGUgaGVpZ2h0XG4gIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRhdGlvbnNMaXN0KSB7XG4gICAgZm9yIChsZXQgbXV0YXRpb24gb2YgbXV0YXRpb25zTGlzdCkge1xuICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09IFwiY2hpbGRMaXN0XCIgfHwgbXV0YXRpb24udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgdXBkYXRlVGFibGVMYXlvdXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIFN0YXJ0IG9ic2VydmluZyB0aGUgdGFibGUgZm9yIGNoYW5nZXNcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShzY3JvbGxhYmxlRGl2LCB7XG4gICAgYXR0cmlidXRlczogdHJ1ZSwgLy8gRm9yIGFueSBjaGFuZ2VzIHRvIGF0dHJpYnV0ZXNcbiAgICBjaGlsZExpc3Q6IHRydWUsIC8vIEZvciBhbnkgY2hhbmdlcyB0byBjaGlsZCBub2Rlc1xuICAgIHN1YnRyZWU6IHRydWUsIC8vIFdhdGNoIGZvciBjaGFuZ2VzIGluIGFsbCBkZXNjZW5kYW50c1xuICB9KTtcbiAgcmV0dXJuIHNjcm9sbGFibGVEaXY7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoVXJsKHVybCwgaHR0cF9tZXRob2QsIGNoYWxsZW5nZV9saXN0KSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlcXVlc3QxO1xuXG4gICAgaWYgKGh0dHBfbWV0aG9kID09IFwiR0VUXCIpIHtcbiAgICAgIHJldHVybiBhd2FpdCBmZXRjaCh1cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGNoYWxsZW5nZV9saXN0KSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5sb2coYEludmFsaWQgVXJsIEVycm9yOiAke2Vyci5zdGFja30gYCwgdXJsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlX2NsYXNzaWZpY2F0aW9uKFxuICBkaXZpZCxcbiAgc2VsZWN0ZWRfY2xhc3NpZmllcixcbiAgY2hhbGxlbmdlX2xpc3QsXG4gIGNodW5rX3NpemVcbikge1xuICBzaG93X2xvYWRpbmdfc3Bpbm5lcihkaXZpZCwgdHJ1ZSk7XG5cbiAgLy9jaGVjayBmb3IgbW9kZSBieSBkZWZhdWx0IGl0IGlzIHByb2R1Y3Rpb24gaWYgbm8gcGFyYW0gaXMgZ2l2ZW5cbiAgbGV0IHRhYmxlZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGl2aWQpO1xuICB2YXIgbW9kZSA9ICQodGFibGVkaXYpLmRhdGEoXCJtb2RlXCIpID8gJCh0YWJsZWRpdikuZGF0YShcIm1vZGVcIikgOiBcIm9wZW5lYmVuY2hcIjtcblxuICBjb25zdCBhcGlfdXJsID0gJCh0YWJsZWRpdikuZGF0YShcImFwaS11cmxcIik7XG4gIGNvbnN0IGJlbmNoX2V2ZW50X2FwaV91cmwgPSAkKHRhYmxlZGl2KS5kYXRhKFwiYmVuY2gtZXZlbnQtYXBpLXVybFwiKVxuICAgID8gJCh0YWJsZWRpdikuZGF0YShcImJlbmNoLWV2ZW50LWFwaS11cmxcIilcbiAgICA6IFwiaHR0cHM6Ly9vcGVuZWJlbmNoLmJzYy5lcy9yZXN0L2JlbmNoX2V2ZW50X2FwaVwiO1xuXG4gIGxldCBwYXRoX2RhdGEgPVxuICAgICQodGFibGVkaXYpLmRhdGEoXCJiZW5jaG1hcmtpbmdldmVudFwiKSArIFwiL1wiICsgc2VsZWN0ZWRfY2xhc3NpZmllcjtcbiAgcGF0aF9kYXRhID0gdXJsam9pbihiZW5jaF9ldmVudF9hcGlfdXJsLCBwYXRoX2RhdGEpO1xuICBsZXQgaHR0cF9tZXRob2Q7XG5cbiAgaWYgKGNoYWxsZW5nZV9saXN0Lmxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGNoYWxsZW5nZV9saXN0Lmxlbmd0aCA9PSAwKSB7XG4gICAgaHR0cF9tZXRob2QgPSBcIkdFVFwiO1xuICB9IGVsc2Uge1xuICAgIGh0dHBfbWV0aG9kID0gXCJQT1NUXCI7XG4gIH1cblxuICBmZXRjaFVybChwYXRoX2RhdGEsIGh0dHBfbWV0aG9kLCBjaGFsbGVuZ2VfbGlzdClcbiAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgbGV0IGJlbmNoX2lkID0gJCh0YWJsZWRpdikuZGF0YShcImJlbmNobWFya2luZ2V2ZW50XCIpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICBzaG93X2xvYWRpbmdfc3Bpbm5lcihkaXZpZCwgZmFsc2UpO1xuICAgICAgICAgIHRhYmxlZGl2LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgbGV0IHBhcmEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgIHBhcmEuY2xhc3NOYW1lID0gXCJhbGVydCBhbGVydC1pbmZvXCI7XG4gICAgICAgICAgbGV0IGVycl90eHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcbiAgICAgICAgICAgIFwiTm8gZGF0YSBmb3VuZCBmb3IgdGhlIGJlbmNobWFya2luZyBldmVudDogJ1wiICsgYmVuY2hfaWQgKyBcIidcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgcGFyYS5hcHBlbmRDaGlsZChlcnJfdHh0KTtcbiAgICAgICAgICB0YWJsZWRpdi5hcHBlbmRDaGlsZChwYXJhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaG93X2xvYWRpbmdfc3Bpbm5lcihkaXZpZCwgZmFsc2UpO1xuICAgICAgICAgIHRhYmxlZGl2LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgbGV0IHBhcmEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgIHBhcmEuY2xhc3NOYW1lID0gXCJhbGVydCBhbGVydC1pbmZvXCI7XG4gICAgICAgICAgbGV0IGVycl90eHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcbiAgICAgICAgICAgIFwiVGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIHNlcnZlci4gUGxlYXNlIHRyeSBhZ2FpbiBvciBjb250YWN0IHdpdGggdGhlIHN1cHBvcnQgdGVhbVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwYXJhLmFwcGVuZENoaWxkKGVycl90eHQpO1xuICAgICAgICAgIHRhYmxlZGl2LmFwcGVuZENoaWxkKHBhcmEpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHJlc3BvbnNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0pXG4gICAgLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgIGxldCBiZW5jaF9pZCA9ICQodGFibGVkaXYpLmRhdGEoXCJiZW5jaG1hcmtpbmdldmVudFwiKTtcbiAgICAgIGlmIChcbiAgICAgICAgKHJlc3VsdHMuZGF0YSAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdHMuZGF0YSA9PSBudWxsKSB8fFxuICAgICAgICByZXN1bHRzLmxlbmd0aCA9PSAwXG4gICAgICApIHtcbiAgICAgICAgc2hvd19sb2FkaW5nX3NwaW5uZXIoZGl2aWQsIGZhbHNlKTtcbiAgICAgICAgdGFibGVkaXYuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgbGV0IHBhcmEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBwYXJhLmNsYXNzTmFtZSA9IFwiYWxlcnQgYWxlcnQtaW5mb1wiO1xuICAgICAgICBsZXQgZXJyX3R4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuICAgICAgICAgIFwiTm8gZGF0YSBhdmFpbGFibGUgZm9yIHRoZSBiZW5jaG1hcmtpbmcgZXZlbnQ6ICdcIiArIGJlbmNoX2lkICsgXCInXCJcbiAgICAgICAgKTtcbiAgICAgICAgcGFyYS5hcHBlbmRDaGlsZChlcnJfdHh0KTtcbiAgICAgICAgdGFibGVkaXYuYXBwZW5kQ2hpbGQocGFyYSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhiZW5jaF9pZCwgcmVzdWx0cyk7XG4gICAgICAgIGxldCBjb21tdW5pdHlfaWQgPSBcIk9FQkNcIiArIGJlbmNoX2lkLnN1YnN0cmluZyg0LCA3KTtcblxuICAgICAgICBjb25zdCBmZXRjaCA9IGNyZWF0ZUFwb2xsb0ZldGNoKHtcbiAgICAgICAgICAvL2ZhbGxiYWNrIHRvIGxlZ2FjeSBpZiBubyBhcGlfdXJsIGlzIGRlZmluZWRcbiAgICAgICAgICB1cmk6IGFwaV91cmxcbiAgICAgICAgICAgID8gYXBpX3VybFxuICAgICAgICAgICAgOiB1cmxqb2luKFwiaHR0cHM6Ly9cIiArIG1vZGUgKyBcIi5ic2MuZXMvXCIsIFwic2NpYXBpL2dyYXBocWxcIiksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGZldGNoRGF0YSA9ICgpID0+XG4gICAgICAgICAgZmV0Y2goe1xuICAgICAgICAgICAgcXVlcnk6IGBxdWVyeSBnZXRUb29scygkY29tbXVuaXR5X2lkOiBTdHJpbmchKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRUb29scyh0b29sRmlsdGVyczp7Y29tbXVuaXR5X2lkOiAkY29tbXVuaXR5X2lkfSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RyeV90b29sX2lkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9YCxcbiAgICAgICAgICAgIHZhcmlhYmxlczogeyBjb21tdW5pdHlfaWQ6IGNvbW11bml0eV9pZCB9LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGZldGNoRGF0YSgpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgbGV0IHRvb2xfbGlzdCA9IHJlc3BvbnNlLmRhdGEuZ2V0VG9vbHM7XG5cbiAgICAgICAgICAvLyBpdGVyYXRlIG92ZXIgdGhlIGxpc3Qgb2YgdG9vbHMgdG8gZ2VuZXJhdGUgYSBkaWN0aW9uYXJ5XG4gICAgICAgICAgbGV0IHRvb2xfZWxpeGlyX2lkcyA9IHt9O1xuICAgICAgICAgIHRvb2xfbGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh0b29sKSB7XG4gICAgICAgICAgICBpZiAodG9vbC5yZWdpc3RyeV90b29sX2lkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdG9vbF9lbGl4aXJfaWRzW3Rvb2wubmFtZV0gPSB0b29sLnJlZ2lzdHJ5X3Rvb2xfaWRcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCI6XCIpWzFdXG4gICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0b29sX2VsaXhpcl9pZHNbdG9vbC5uYW1lXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmaWxsX2luX3RhYmxlKFxuICAgICAgICAgICAgZGl2aWQsXG4gICAgICAgICAgICByZXN1bHRzLFxuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIHRvb2xfZWxpeGlyX2lkcyxcbiAgICAgICAgICAgIGNvbW11bml0eV9pZCxcbiAgICAgICAgICAgIGJlbmNoX2lkLFxuICAgICAgICAgICAgY2h1bmtfc2l6ZSxcbiAgICAgICAgICAgIGFwaV91cmxcbiAgICAgICAgICApO1xuICAgICAgICAgIHNob3dfbG9hZGluZ19zcGlubmVyKGRpdmlkLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmNhdGNoKChlcnIpID0+IGNvbnNvbGUubG9nKGVycikpO1xufVxuXG5mdW5jdGlvbiBsb2FkX3RhYmxlKFxuICBkaXZpZCxcbiAgY2hhbGxlbmdlX2xpc3QgPSBbXSxcbiAgY2xhc3NpZmllciA9IFwiZGlhZ29uYWxcIixcbiAgY2h1bmtfc2l6ZSA9IDEwXG4pIHtcbiAgcmVtb3ZlX3RhYmxlKGRpdmlkKTtcblxuICBsZXQgZHJvcGxpc3RfaWQgPSBkaXZpZCArIFwiX2JlbmNoX2Ryb3Bkb3duX2xpc3RcIjtcbiAgbGV0IGRyb3BsaXN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZHJvcGxpc3RfaWQpO1xuICBpZiAoZHJvcGxpc3QgPT0gbnVsbCkge1xuICAgIC8vYWRkIGRyb3Bkb3duIGxpc3RcbiAgICBkcm9wbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XG4gICAgZHJvcGxpc3QuaWQgPSBkcm9wbGlzdF9pZDtcbiAgICBkcm9wbGlzdC5jbGFzc05hbWUgPSBcImNsYXNzaWZpY2F0b3JfbGlzdFwiO1xuXG4gICAgbGV0IGJlbmNoX3RhYmxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGl2aWQpO1xuXG4gICAgbGV0IGRyb3BsaXN0X2xhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpO1xuICAgIGRyb3BsaXN0X2xhYmVsLmh0bWxGb3IgPSBkcm9wbGlzdF9pZDtcbiAgICBkcm9wbGlzdF9sYWJlbC5pbm5lclRleHQgPSBcIkNsYXNzaWZpY2F0aW9uIE1ldGhvZDpcIjtcblxuICAgIC8vIGFkZCBvcHRpb24gZ3JvdXBcbiAgICBsZXQgZ3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiT3B0R3JvdXBcIik7XG4gICAgZ3JvdXAubGFiZWwgPSBcIlNlbGVjdCBhIGNsYXNzaWZpY2F0aW9uIG1ldGhvZDpcIjtcbiAgICBkcm9wbGlzdC5hZGQoZ3JvdXApO1xuXG4gICAgLy8gYWRkIGxpc3Qgb3B0aW9uc1xuICAgIGxldCBvcHRpb24xID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICBvcHRpb24xLmNsYXNzID0gXCJzZWxlY3Rpb25fb3B0aW9uXCI7XG4gICAgb3B0aW9uMS5pZCA9IGRpdmlkICsgXCJfY2xhc3NpZmljYXRvcl9fc3F1YXJlc1wiO1xuICAgIG9wdGlvbjEudGl0bGUgPVxuICAgICAgXCJBcHBseSBzcXVhcmUgcXVhcnRpbGVzIGNsYXNzaWZpY2F0aW9uIG1ldGhvZCAoYmFzZWQgb24gdGhlIDAuNSBxdWFydGlsZSBvZiB0aGUgWCBhbmQgWSBtZXRyaWNzKVwiO1xuICAgIG9wdGlvbjEuZGF0YSA9IChcInRvZ2dsZVwiLCBcImxpc3RfdG9vbHRpcFwiKTtcbiAgICBvcHRpb24xLmRhdGEgPSAoXCJjb250YWluZXJcIiwgXCIjdG9vbHRpcF9jb250YWluZXJcIik7XG4gICAgb3B0aW9uMS52YWx1ZSA9IFwic3F1YXJlc1wiO1xuICAgIG9wdGlvbjEuaW5uZXJIVE1MID0gXCJTUVVBUkUgUVVBUlRJTEVTXCI7XG5cbiAgICBsZXQgb3B0aW9uMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgb3B0aW9uMi5jbGFzcyA9IFwic2VsZWN0aW9uX29wdGlvblwiO1xuICAgIG9wdGlvbjIuaWQgPSBkaXZpZCArIFwiX2NsYXNzaWZpY2F0b3JfX2RpYWdvbmFsc1wiO1xuICAgIG9wdGlvbjIudGl0bGUgPVxuICAgICAgXCJBcHBseSBkaWFnb25hbCBxdWFydGlsZXMgY2xhc3NpZmNhdGlvbiBtZXRob2QgKGJhc2VkIG9uIHRoZSBhc3NpZ25tZW50IG9mIGEgc2NvcmUgdG8gZWFjaCBwYXJ0aWNpcGFudCBwcm9jZWVkaW5nIGZyb20gaXRzIGRpc3RhbmNlIHRvIHRoZSAnb3B0aW1hbCBwZXJmb3JtYW5jZScgY29ybmVyKVwiO1xuICAgIG9wdGlvbjIuZGF0YSA9IChcInRvZ2dsZVwiLCBcImxpc3RfdG9vbHRpcFwiKTtcbiAgICBvcHRpb24yLmRhdGEgPSAoXCJjb250YWluZXJcIiwgXCIjdG9vbHRpcF9jb250YWluZXJcIik7XG4gICAgb3B0aW9uMi52YWx1ZSA9IFwiZGlhZ29uYWxzXCI7XG4gICAgb3B0aW9uMi5pbm5lckhUTUwgPSBcIkRJQUdPTkFMIFFVQVJUSUxFU1wiO1xuXG4gICAgbGV0IG9wdGlvbjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgIG9wdGlvbjMuY2xhc3MgPSBcInNlbGVjdGlvbl9vcHRpb25cIjtcbiAgICBvcHRpb24zLmlkID0gZGl2aWQgKyBcIl9jbGFzc2lmaWNhdG9yX19jbHVzdGVyc1wiO1xuICAgIG9wdGlvbjMudGl0bGUgPVxuICAgICAgXCJBcHBseSBrLW1lYW5zIGNsdXN0ZXJpbmcgYWxnb3JpdGhtIHRvIGdyb3VwIHRoZSBwYXJ0aWNpcGFudHNcIjtcbiAgICBvcHRpb24zLmRhdGEgPSAoXCJ0b2dnbGVcIiwgXCJsaXN0X3Rvb2x0aXBcIik7XG4gICAgb3B0aW9uMy5kYXRhID0gKFwiY29udGFpbmVyXCIsIFwiI3Rvb2x0aXBfY29udGFpbmVyXCIpO1xuICAgIG9wdGlvbjMudmFsdWUgPSBcImNsdXN0ZXJzXCI7XG4gICAgb3B0aW9uMy5pbm5lckhUTUwgPSBcIkstTUVBTlMgQ0xVU1RFUklOR1wiO1xuXG4gICAgZ3JvdXAuYXBwZW5kQ2hpbGQob3B0aW9uMSk7XG4gICAgZ3JvdXAuYXBwZW5kQ2hpbGQob3B0aW9uMik7XG4gICAgZ3JvdXAuYXBwZW5kQ2hpbGQob3B0aW9uMyk7XG5cbiAgICBsZXQgc2VsZWN0ZWRfY2xhc3NpZmllciA9IGNsYXNzaWZpZXI7XG5cbiAgICBpZiAoc2VsZWN0ZWRfY2xhc3NpZmllcikge1xuICAgICAgc3dpdGNoIChzZWxlY3RlZF9jbGFzc2lmaWVyKSB7XG4gICAgICAgIGNhc2UgXCJzcXVhcmVzXCI6XG4gICAgICAgICAgb3B0aW9uMS5zZWxlY3RlZCA9IFwiZGlzYWJsZWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRpYWdvbmFsc1wiOlxuICAgICAgICAgIG9wdGlvbjIuc2VsZWN0ZWQgPSBcImRpc2FibGVkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjbHVzdGVyc1wiOlxuICAgICAgICAgIG9wdGlvbjMuc2VsZWN0ZWQgPSBcImRpc2FibGVkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgb3B0aW9uMi5zZWxlY3RlZCA9IFwiZGlzYWJsZWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiZW5jaF90YWJsZS5hcHBlbmRDaGlsZChkcm9wbGlzdF9sYWJlbCk7XG4gICAgYmVuY2hfdGFibGUuYXBwZW5kQ2hpbGQoZHJvcGxpc3QpO1xuICB9XG5cbiAgJChkcm9wbGlzdCkub2ZmKCk7XG4gICQoZHJvcGxpc3QpLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAvL2NvbXB1dGVfY2xhc3NpZmljYXRpb24oZGl2aWQsIHRoaXMub3B0aW9uc1t0aGlzLnNlbGVjdGVkSW5kZXhdLmlkLnNwbGl0KCdfXycpWzFdLCBjaGFsbGVuZ2VfbGlzdCwgY2h1bmtfc2l6ZSk7XG4gICAgY29tcHV0ZV9jbGFzc2lmaWNhdGlvbihcbiAgICAgIGRpdmlkLFxuICAgICAgdGhpcy5vcHRpb25zW3RoaXMuc2VsZWN0ZWRJbmRleF0udmFsdWUsXG4gICAgICBjaGFsbGVuZ2VfbGlzdCxcbiAgICAgIGNodW5rX3NpemVcbiAgICApO1xuICB9KTtcblxuICAvL2NvbXB1dGVfY2xhc3NpZmljYXRpb24oZGl2aWQsIGRyb3BsaXN0Lm9wdGlvbnNbZHJvcGxpc3Quc2VsZWN0ZWRJbmRleF0uaWQuc3BsaXQoJ19fJylbMV0sIGNoYWxsZW5nZV9saXN0LCBjaHVua19zaXplKTtcbiAgY29tcHV0ZV9jbGFzc2lmaWNhdGlvbihcbiAgICBkaXZpZCxcbiAgICBkcm9wbGlzdC5vcHRpb25zW2Ryb3BsaXN0LnNlbGVjdGVkSW5kZXhdLnZhbHVlLFxuICAgIGNoYWxsZW5nZV9saXN0LFxuICAgIGNodW5rX3NpemVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcnVuX3N1bW1hcnlfdGFibGUoY2hhbGxlbmdlX2xpc3QgPSBbXSwgYWN0aXZlX3RhYmxlID0gbnVsbCkge1xuICBpZiAoY2hhbGxlbmdlX2xpc3QubGVuZ3RoID09IDAgJiYgYWN0aXZlX3RhYmxlID09IG51bGwpIHtcbiAgICBsZXQgdGFibGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIm9lYi10YWJsZVwiKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGRhdGFJZDtcbiAgICBsZXQgeTtcblxuICAgIC8vIGFwcGVuZCBpZHMgdG8gZGl2c1xuICAgIGkgPSAwO1xuICAgIGZvciAoeSBvZiB0YWJsZXMpIHtcbiAgICAgIC8vIGdldCBiZW5jaG1hcmtpbmcgZXZlbnQgaWRcbiAgICAgIGRhdGFJZCA9IHkuZ2V0QXR0cmlidXRlKFwiZGF0YS1iZW5jaG1hcmtpbmdldmVudFwiKTtcblxuICAgICAgLy9zZXQgY2hhcnQgaWRcbiAgICAgIGxldCBkaXZpZCA9IGRhdGFJZC5yZXBsYWNlKFwiOlwiLCBcIl9cIik7XG4gICAgICB5LmlkID0gZGl2aWQ7XG4gICAgICBsb2FkX3RhYmxlKGRpdmlkLCBjaGFsbGVuZ2VfbGlzdCk7XG4gICAgICBpKys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxvYWRfdGFibGUoYWN0aXZlX3RhYmxlLCBjaGFsbGVuZ2VfbGlzdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlX3RhYmxlKGRpdmlkKSB7XG4gIGxldCB0YWJsZWRpdl9pZCA9IGRpdmlkICsgXCJfb2ViLXRhYmxlLXNjcm9sbFwiO1xuICBsZXQgdGFibGVkaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YWJsZWRpdl9pZCk7XG4gIGlmICh0YWJsZWRpdiAhPSBudWxsKSB7XG4gICAgdGFibGVkaXYucmVtb3ZlKCk7XG4gIH1cblxuICByZXR1cm4gdGFibGVkaXZfaWQ7XG59XG5cbmZ1bmN0aW9uIHNob3dfbG9hZGluZ19zcGlubmVyKGRpdmlkLCBsb2FkaW5nKSB7XG4gIGxldCBzcGlubmVyX2lkID0gZGl2aWQgKyBcIi1sb2FkaW5nXCI7XG4gIGxldCBzcGlubmVyX2RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNwaW5uZXJfaWQpO1xuXG4gIC8vIENoZWNrIGlmIHRoZSB0YWJsZSBleGlzdHMgKGRpdmlkICsgJ19vZWItdGFibGUtc2Nyb2xsJylcbiAgbGV0IHRhYmxlX2RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRpdmlkICsgXCJfb2ViLXRhYmxlLXNjcm9sbFwiKTtcblxuICBpZiAoIXNwaW5uZXJfZGl2KSB7XG4gICAgc3Bpbm5lcl9kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHNwaW5uZXJfZGl2LmlkID0gc3Bpbm5lcl9pZDtcbiAgICBzcGlubmVyX2Rpdi5jbGFzc05hbWUgPSBcInNwaW5uZXItY29udGFpbmVyXCI7XG5cbiAgICAvLyBDcmVhdGUgdGhlIGltYWdlIGVsZW1lbnQgZm9yIHRoZSBzcGlubmVyXG4gICAgbGV0IHNwaW5uZXJfaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICBzcGlubmVyX2ltZy5sb2FkaW5nID0gXCJsYXp5XCI7XG4gICAgc3Bpbm5lcl9pbWcuc3JjID0gbG9hZGVySW1hZ2U7XG4gICAgc3Bpbm5lcl9pbWcuY2xhc3NOYW1lID0gXCJzcGlubmVyXCI7XG5cbiAgICBzcGlubmVyX2Rpdi5hcHBlbmRDaGlsZChzcGlubmVyX2ltZyk7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGl2aWQpLmFwcGVuZENoaWxkKHNwaW5uZXJfZGl2KTtcbiAgfVxuXG4gIHNwaW5uZXJfZGl2LnN0eWxlLmRpc3BsYXkgPSBsb2FkaW5nID8gXCJmbGV4XCIgOiBcIm5vbmVcIjtcblxuICBpZiAodGFibGVfZGl2KSB7XG4gICAgdGFibGVfZGl2LnN0eWxlLmRpc3BsYXkgPSBsb2FkaW5nID8gXCJub25lXCIgOiBcImJsb2NrXCI7XG4gIH1cbn1cblxuZXhwb3J0IHsgcnVuX3N1bW1hcnlfdGFibGUgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./app.js\n')},"./loaderImage.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loaderImage", function() { return loaderImage; });\nconst loaderImage =   "data:image/gif;base64,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";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9sb2FkZXJJbWFnZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xvYWRlckltYWdlLmpzPzdhMDEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGxvYWRlckltYWdlID0gICBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaFVnTUZBdmYvQUVoNXNmZjUrZVRuNmVmcDdPUGw2WmV6MHdCWXVzYlg2d0JHbkFBOWpqNTFzK0hrNTJXTHMzV1Z0eVpxdGJqQ3pMWEcyQUJLb3NuTjArL3g4ek4yd1FCUXF3QkFrcW0rMXRubTlFZUV4cGV0eFllbnpBQk9xUUJTc1hxazAvdjkvZmYzK1l1aXVnQkluM1dieHJiTTVWR015K1BzOVNwcXI2U3p3Nm5HNWhKanZBQlp2VGhucGdCQ2xRQThsbW1WeFlHYnVJT3MydHZrN3gxa3N2SHo5Vk9CczdPK3l1dnQ3MmViMHBHbXZRcGJ0cHlzdit6eSthN0Myc3ZSMVp5enpCTmd0MW1Fc2dBeGhiM1Q3TS9UMlFCTnNRRll0NWU2NEcyUXQvRDErZ3BldWxDRnZ4aFhwZERhNTlQZTYrbnI3ZFBaM2V2djlUaHVySzI4eTJpSnJTUlhuTUhJejhISjBSVkxsYTY2eDFxUnpDbHd2NDIwM2cxZ3V3Qld0UjVxdmpwd3JqQnVzeHRSbWFHMXl4ZG12WmFwdnVqdDh3OWV0VXgvdHlOZXA4WFM0YWkyeEFBMWljdmQ4TlhoOEQ5OHdGdUx2d3BCamdSYXVjTFAzY25SMmxlR3VndEttOVBYM1FCRW1GeURyLy8vLzVHdHo4WE4xNks1MUF0RWtHR1B3WCtneFFkY3V0bmY1dWJ2K0FSY3ZjblQzc2ZMMGRuZDM5cmg2TzN0N3dWV3RWK1cwTC9QNHdwTm9PRG43VytSczgvVjJ3OUlsSit2d0w3SzJBQlVzODdXM2dBdGd3OVJvdjM5L1FCVXNRWkJqd1ZGbUFCU3I4Zk4wd0pjdmdWVXRBWTlqQzVnb2dCUXJmdjcrOWZiMzh2UDFkdmY0d1JCbFBuNys4M1Ixd0JNcGUzdjhmWDE5OW5kNGNuUDFkSFYyUUJTclFCT3AvbjUrKy92OGRIWDI5L2o1OVhaM2ZQMTk5UFgyd0JXdC9YMzl3Qk1wOUhWMi9Iejg4M1Qxd2RHbS9IeDh3QTVpd1ZLbi9QMTlkWFozOTNoNWQzaDQ5L2g1UUFxZ0FoRWxOUFYyUUJNbzgvVDF3QlV0YzNSMWYzOS84WEwwOWZiM2VEajVkdmY0ZjMvLzhUTDBRQld1ZHZkNGZuNStjbk4xZDNmNHdKVHN3Sld0ZkgxOTlqZDVBSlV0ZXp2OHo1L3g4clY0c1BOMTlYYjROZlozZG5mNDZDeHd0M2g1OTNqNmRYWjIvUDMrKy96K2VEbzg2SEE0eUJudFFKV3QvWDQvTXZQMThqUDJBaFl0WENnMWRIVDJlbngrYWU0eWxPSXdsK0hzNUdqdHhCR2tSSlBuUVpJbXYvLy95SC9DMDVGVkZORFFWQkZNaTR3QXdFQUFBQWgrUVFGQlFEL0FDd0FBQUFBVWdNRkFrQUkvd0QvQ1J4SXNLREJnd2dUS2x6SXNLSERoeEFqU3B4SXNhTEZpeGd6YXR6SXNhUEhqeUJEaWh4SnNxVEpreWhUcWx6SnNxWExsekJqeXB4SnM2Yk5temh6NnR6SnM2ZlBueGZOaUx1dzRVVytOMXZlelFEQ0ZNZzdCeFF5YUJsUkFJS1RXMEN6YXQzS3RhdlhyMkREaW0wWllBOFpBMTdTcWwzTHRxM2J0M0RqcnMyMTRrMmhzWGp6NnQzTHQ2L2Z2ejRCb1pWTHVMRGh3NGk5NVBweUZ4UGd4NUFqUzU1TXVUSk1UQjgrL0t1a0lySG56NkJEcnpVQTUxOW1USTR0cTE3TnVyWHIxMEF4ZnhnVkFNUy9GNE5GRXk2eXJjUUJQY0NEQ3g5T3ZMZ2VFeDVVRktHa3UzQ2d1d0ZRbllaTnZicjE2OWl6RTVTTkNnU3JDYU5HNVA5dXJyYkRtZC9HMDZ0Znp4NVZoaUxrMjNhcHhJb0dxd0NqTW12Zno3Ky8vLzg2WVVaYmZSUGNzTW9ENHpWWFJEM3NOZWpnZyttMW9RaHo4Um1od0ExUDNEREJMU0JJOTBGcUFJWW80b2drbHNnUVp0M2RNa0VpQXdod0RBRUtKQmhhRVl0QWFPT05ON2JCRFlYTkdhREJBQXNNb0tGOStIMW80cEZJSnFsa2E1blZSa09CUUpweVNERmx5QWhhRVRqZ3FPV1c2N1VoQjQraUdlSEFIYVNZVW93QUF5UXlBU3NkR3Jua20zREdLYWRXQWdid1hTSlBDRkNMS2JiUThvb1BEdVFTWHhIdWNHbm9vZXQ4MFVGOEt6eHlDQkZRbEJua2tQZTVPZWVsbUdhcTZVbE5FbmlEQU5LWVFnb1VSS1JTQ2k2UFdBa2FKVHBnY09pckQrTC9BRjk4WHB6eFFDbytFRUVMRkZNU0lPU0diWUs0NmJERUZtdnNpUitrQ0NVQlVrTHhDaEUrU0NDdEZUTUlTcXNYbEd5VEFxemN1amZydFFZdzhJb2hFcFNTS3kxbDFpTEFFNnNRbVord3g4WXJiMTdnN0VHQkFkWmVxNjhCWGZ5aEJwd29lcmZpQUFRVTAwcWYwSllpZ1NFTXB5S0pIUHEyMVVFUkZBekJMWEh4Y0FIRXR4R25aVUFZMGpJc2JhNlFsaW1OQUpRV0NlKzhMTGRzVXpvWnJORHh6TFFhMFVVQklhSVlnSW9zNmlrcUxhVkd1ekRERFB2d3dEdEcwS3cwelNzRVFRVFJSSmViNnl1OG1qTHBCTzVhNnZMV1hKZmtHQTBacUxyMDJETXJjY0UvcUYyWEdTcDJycGhucUtNKzY0UENVTmZ0Z3lFQXlFejIzbkRsL3lJSERPUFdEYlhVdXRyUzY2OVpyOXoxNG94UEpPQS9FQkRDOStTVXQyWEFFcVBJcGpobDNIbEh3eW8zQUdrd0tVQkRLKzNRZ3R1ZFNnZ3o2RjM1WjNTQmdjSXJxS2NlTmVHN3B1dHJ5dTgyN3Z2dnlNNFdBQ2Jva1BHNkYwVndVMEliRnp1NHpoRmZGTEZvNVNzQThrOTAwN0ZXSnlzOGgxNndxRkFBalN2ZHRwZGZOeEZnaUIyZkFRMUVZLzc3SWhOZStDR20xTEk3MW15cURQeisvQSswUFEzL0VBL1pPdkNKUWpYdmdNUmh4M3YyUmdaMGVBZDdXck9NYkdqak9TZ0o0SHVIR0ZYcGZEQzMwNzB2RlZKUUgza004SWpBbWU5MDVrb0ZFWFFWcVZhWVFocTdVNU45T3BTZkNQYnZob3Y3M3dRbXNJQjNMSTFRQ0F5aWpmOVFRUUdPUld3Rk9RQkJ1Kzdqb2MxVkJqV1pvWTJkYnZHa1JJVHVndElvaHBRMHVFSU9La3dDekVqZjBraElPNm1SakdxMktKT1pGb0NtREswQ2YweXNvUk54U0VldWRlcEpvWnRGQ0Z5bnJ5S0VRNGlBTkJRSnBoZXhYRGpBRkFONFFpSVN4eDhvQ3M5VEJETVl3bEpCQ3pFcWpZU2tVQ0c2Nm5jL0lubm9RM09zb3lnWkp6d1E0SkZnQytBREVEcldBVElrSVpDd1BCUVhqTWdvSkF4QVhleGFrLzRhbVN3UXFNaDd4VGlFczRpQUMwdlNESk9GYTBVeENLQklYZlp1bE5EczMvOUFCeXBUdElJV2dZcllnbUxKVFVPWm9BdGdXbDhPcEtITSszRklPcUdrRENyRXNZRTNLTUVBSWp5ZWJ1Q3BnaVVVQUJFa01VTUI5c24vejM3Njg1OEFEYWhBQjByUWdocjBvQWhOcUVJWHl0Q0dPdlNoRHUxREh5N1FBeExNUVExTlFFUTd3TU95Z1AweWtzSzhneXVxcGMwWWRQT2tPT0tCb2lKbUFCaGMwMlFvVytJdTh6S0tDMUJnQmZtU3AwN0JSWWdsL0dzN0V3eUFuZW96aWlza2JhZElUYXBTbDhyVXp4akJBQ3JRd2lSa2NSMmRmYlJnd2dRYUxzNXgxRDZXQUtWZ2JWQWJzTVZTQUVCQmt6RGxuV2FBOG9FQ3FDQ2VsYU9FWE9kSzE3cmE5YTU0dFd0VDFXSUFCNXhqQWRKWVExZjNTdGpDR3Zhd1REVUFCWDRLR1k5Q2FRSE5rbHNwaUFBQXVINm1BeVFJcTJhRkV3NWF4a2NPYXpBVld1dTNMcG5tNXlZYjhFUlM4OHBhdW1iaXRiQ05yV3huUzF2WS83YTJ0WWpOclc1M3k5dmVpdVp5ckRCTlhoNkp4MnFPS21nTGV3VU1MSHNsQm0wV2xoZ0FBaUgzdG9JWndJQWNCZExRTGJDWFRvOWc1aCtvZ0FNZkozZmJ1OVlXdGgzb0FDZld5OTcycmhjVzhJMnZmT2NMWC9mYU43MGRPRzhteW90WDMvcjN2d0FPOEU1WG9BSHdabThyYXpQbHNvSTV6QTRXTFF0bkdDQVFtUGRjTHNtS3QwYnd4QkxFd1JIWi9BTVE0L1VNZjBlc1gvU3ExNzZjaUs4b1JGR0JGcnY0eFJYZ2dJeG5UT01hMjdqR01NNXhCVlljWHhSeklyMGx0dTJJYnl2Z0lodjV5RWMyd0FqK2NSODVzdlVEVTF4d1ZoTldPMFA0SUVhVks0SWljR0NDQ3FkZ0M4dEJzbUVNUUlZTlRHQTdhL3ZISkNTM0toS1hHUCsvUG42dmlsZXNZeGZYT0JaNFZvV2U5NnpuWlN3akFvQU90S0FIVGVoQ1I4RFBmTjR6bnZHTTR6cTNtTWM5ampOK2d6eGtNVnY2MHBoR3FvOUdBYXdtOWtTSG9ZT3NNQ1ZiWllZUlFSSkswTzFkTTkzYjI5WTJ2ZmFkczZOYmZPZEZKN3JQZmk2MENIYk5hd1Q0K3RjV09BRXF0clFIRi96NjJMem1kYUg5dkl4YnEyTFJzYkR4ckNFTmkvdm1sN1pFUGg0UVRzRHRibnY3MitBT3Q3akhUZTV5bS92YzZKNEJZblBCN25hNys5M3dqcmU4NS8xdVZzdEZDZk93SXRaQU1GT2RySzF0ZUtybWxEdFlhcUl4SXd2dllLNjlGeTRhMXM3MnhPeUZMNHR6VEdOYjg1blp1azcycm8vOWF6eDQvT040YUlISVI5NENOb3pnWXFqL0NFVUNTRDV5a0grYzQ3N1d1TElKamVoRU0zckdPaFpGZmR0NzdkaXlsbklHcU1IVDRFZjBvaHY5NkVnM09qTkNvUERKR1VBZkpreTYxS2RPOUZkWUFRMU4zNm1GYW5HeVpqTFJoamlwa3k4dEdLb3A0eXBrOEV1RkJCZ2doOEV5dkMwckNNTWFvdjdCVjZBQUFITElPbFB6S2x1SXB4Z1dFN2V6alBPODV6OExldGN1Q0VVN2lxTlBNTFFnR0JaZ3VRVW1UL25LSitEeW1CZkNIZ0k1QWlGZ0h2T1ZEMzNrUjI2QllQZ0REUkFZZG5GNEFBWVg3SHJRelZaMHRHVU1ZNTFYbTcwOWYyMWUrUmIwb2FmdWRNQVB2dkNIVC96aUcvLzR5RGQrK1phdWQ3STluZTVVajc3MHkrY0RZeFkyWE5JNG5IYURsUlh1Mk9tVUFsakEvK2o4UkdXMEg1MFpQaWlEQXZMZVczaStvd0ZXb04zMGt5NkJWMVNqQWEzTEtWTHgydmVJQXg3R2d4Y0xoWGQ0THFBQTdGQmhDSGd4bVBBSHJpZG9zZmRzczFkN3Q3ZGV1YmRmcXpZMlFmY25KSk03TGxRTXhTQU4wckFBQkRDQ0pGaUNKbmlDS0ppQ0tyaUNMS2lDQ3dCWUhtaE5HaVEzUHZBS09kQjhHTWdBdUdBdUd3Z0ZhWFFJTG1RS1p1S0JSRmlFUm5pRVNFaUVRcmlFVENpRXJkQUtHVVFLcEdBTFVCQSt6eEkwQkZkbFBvQUNidGRVN0hNSXRHQUxab0ltYXRKa1lQY1RBc0kyQkdKRkJKTkY0TE5CQkRkL3FXTXV6Q0EzRW1BRk5wQUZLQ0FKWlZBR09mQ0haYkFENTdBR052QUFuZUFEcWZBc1p5ZUhkWU5DSFArVUNpcTBRcEpZS3JqaVJSNDBmelc0Qm1nUUNEaFlHSHlIWHUzMWY0TEhBUUxZWjRjbkFzQ1dXUW00aXEraUFNWVdjeUxnZ0lxR2N5NW1lN2puYy8xMVREVkFLbFNqZmZoVEpLQ0VHc0k0ak1SWWpNWjRqTWlZak1wb2pLVjBWYlZ3TUVCakN6ZDRmUXhnQzBUUWkxWWpKRXZFYjZOUVE1bnhqZUFZanVJNGp1TFlqZVk0Q3FqQU5rSlZHNnhRSDNqa1BXVTNTZEZpZzUwNFJnQkFDNk9GUzZhMVZuZ3hRV3BJUlN0eVJRdXdKNjB3Z3l0VWljREhpQXI1UHNDWFFpdjBDcnRpT0dZQ1EyaHlBd2F5UXhnNUFhQVRPaTFDQUxXZ1JRVlpoZVFITFZsWWNPOVRmZlhZV3Ywblo0RVhZNlJZaXFwZ2VCSFFhNzcyY1NNWERHRC93SW82K1NEdGdBVXJKM0l2QjR1eENHZ1BlSE13dG5NL0psdlpOa0s3bUV6TGxDWWJ3bDFqTVUyZnNpZWtRd1RTV0kvSHhBQ2s0SlRNVklaU1NSTld0V0N0c0FBTUVHSk5CUVFQTURmNXVDNkxaSWJkTlpYZktFWHQrQ1FCK1FRZE9aQWdtVUZVR0Q0amVaQ1Z5RUZ6VXdxRW1YemxRcGc4S0ppUU9JblhTQXNSU1FwQUtJUWZTQUJvSWlRWFNRTzNrRCtvSUVlaDVFaXp3VGJlQVpBYjJaRnVLQ1ZVT0pMams1Q3ZvQS9ONTJxeDVYZndCWUNrT0lDQlJwTUlZSk1pWjNtWEp3U0FzSk8rS1J5QTRIbVhGM3BBR1pUSkZtaEZHVzBTeUhOS2lWdS8xWlJoV0U1UXVWM29KSmNEOGpsVitUTllPWTJFRlM1ZEdaM0w1SFZoL3hrVDZUQUdTOUFGT09WZkJwQUR6RUF1RW5BdVVDQ2QyaldlMWVHWjNhaU8zdEdPVkdTWEdwa0lWbVNSR0RJQUFqcWdCRnFnQmZvRUdRS2cvdmxHV0VNRG1ObU8vQllkbXdtT2FaTVNzdkdaN0FpUUFxbEZwQU0wSjlDRm52aUpKdVovTFJtQXREbVRHMWVUdUttYnUxa0RZT1VHTENBRXdmQjVORnFqTm9wNXdTQUVvU0FPWUlVRXdqbWNsTmR5SHZkck0wZVVzOGdCeTNtTHpYbUJiL2NXSzlBRC8rQ05aeWdRVk9relY1bVZUWnFsb1hFR1daQUt0NE9JSmZOQ01jVkkwYlFWMDVRblZta0tsU1ZpL1BlYW9RZ0xza2w0TVZtYnFQaHJqN2NKQU5BRHNvQ0FGL0Nqb0NkNmxjZHlKQWVvTEpwNUc3Q0tUZkFDVE9BQ3IvK0lBRVVhZTBiNVlraVpsTGpJcEZycU1UOENRMEtpSmh6U2IxVnFsZEhJblpjNnFwWURCbFpRQ3I5bkx0ZklLMCtwVm1YYUZXTUpUSzBRS1ZNUUNKL1JwcUFZY1NYNmtpZUtpa3l3RHIrNUIzNmFBS0lucUMzZ2NzanFjY1lxZWpRcUJBM3dtM3B3QW5nd2xJY21lN1JYaTVPYWU3dEhxdXRwalp0ME1xNUtwY1JGVGFDNm5WcEpxcnVWQzJId0FPcGdrbCs2cXVsQ2hwMTJZSzlLSjhrQ2NKRUVqYmF3QmhDVEdMajZXckRHa2k5bW9xWUlhQ0tBQjcvNm13REFCalJhckN5WHJCQXJxSUQ2ZVd3UUNoL3dtOUpLclJIQVp4R0lyUk5JcVVLbVY5eWFBOTRhcndaQ3BwK3FuVmlLcml6TEZpdUFCcWxnRENiVFNYQVpsL1gvNm05UXBtQ2hBemVrVWlwaEFLSnk4YThBUzZJRHk2c0ZpNkl1c0Fsb3dBaVlzSlBDMnJDQWFxeFNPNmdUKzNsQ2NIS3N5QU43Y0FJdTBBS09TcTNKZWEyUGhwUkFWcWwxeGJMZHFpc211NCtwa2JKWEtxb3RHN2RPdWdkUk9xVTNteFhFQlNVOFd5cEU4QUNyeEtibXRaSnlGcWVsS0pPMkNYS2tSM21YbDZOQ2tKTW50UWZCd0xBMlNxaFZXNk01aXJYZEJBRElJTG5FR3FURk9hU3dLSXQ2MXJIWXlweG1LN0xvbXJhYnBDNG5DNWZpZXAza3FySndLN2UwQ3hlWDg1bWdkTGZkMTB0WHhXQ1M1UU0vZTZzT0o3Z3AxcEl4SnFlR202SzN1YUtGR2d5TUFLMi82UVp4TUtOQTZya2dSNlN2WjZTalM3bzc5ckVWdUpTaC8yRUU0anUrNUZ1KzVudSs2SnUrNnJ1KzVlc0pJVkN5cE5XNnUrUzJvWHF1TTZNRFRaRy8rcnUvL051Ly92dS8rWHNHU3FBREVKTUw4R1FBSzJBQTRydHdCZ0FCb3hCSGRxdTdNWkczbndKWmNXTTZxWkFGL2RwbXc1dXJmMGU0dmFxOHVOa0NrNWNBWW1BRzBKdkNlb0FFYkRCNVFvb0gyQXUyMW9xa2tqcUIzK3VjUFNKMEM3bkRERmtLYlNtL3owUy81bnA5VU1mRFJpeDl6SkFLTUFBRTlqczJCTVlLbk1xTkVTekJLNUZncHlScURmYWV1QUJoOGRIQm1RQ2J1enFiUjR1aUhZY0hMdUNpS3B6R3dXRUcvWENzTVl5Y00veGl0a2lCUzRxNis2TERSNXpIMHFLcXV6SWxWME1EM1BlNjN4ZTdiOXZFKzFMRURHbVlpditzeUhsTU5LVmdBeEZtV0FaUUJwK2lTSjQweGNTQ0NUMXdVL3BIT1VaUUZ4QmdFVFN3QjE5Z3lQNXFWOFFyaW9LSHZMV0pBRXd3Q0dvY3k4S3hnTk1xYUJ3cnRtTnJ3M1ZNVnhoWUE2L0FneXYwbUVFNGhFbFl6TVo4ek1oTWhGd25nbTEwa1oxYVF3VWh4Q3U3VitHeWcyQ2FPL1F6aENENGd0emN6ZDc4emVBY3p0NE1ndVFzRGJWd3prYkloRkFvaFNLSm1wWm9ma1NUQ2p0Z3l1QUNBOHdDcm15N0tSK0FHMGFHTDdzbHRMQ3B5clJtdEdQTWF5NGdCU2pzUEgwZ0JRbkFzSXA3bzR3TEFFM0xlV3dnb3pmYXVTWE1zRkpRQUR6Z0lPemdpa1Y2YUdHTHk5MXJ1aUY3dG5zVGRMeFlOWk95amNCSWpqQWQwekk5MCtIL1NJd05JYzJ6dTFUaDRxMnMya2xTSEl6TEdOUkNmYUhrYUk3cW1LRlBNcG9FRUNvRnVVRUs4d29NUU0rMFlnQUFNQTJSSXFiaGVpUWU5Z1JiME1tMVN6bGVQTFJFUzNFRVczZ3lTYWZKQm5QTG02d1NhM25KNEFZSEZBUXRIS2dQbTZ4cS9iWEhDWHNQdUwzYzY3RThWNEVXYUttOVRDcmc2U3VjU3A5ZmdkTlNQVUpjNlpYaVdaMW0ya3VuaEZWUVlBeFJqVmhHZ0FLNG9MYnh1NDg1azJBQk1BQmZvQzhkc0EzMUVBOUM1QTRiMDFSUGRRSWgwQW12a0FvUFFGSWNMTFFBNjNjQ1cyZTFKcWNYbDJzWmw5WXc1M0xCOEFLR2tuSVdjTDB3SjNPR1ZuTzNCbTAwTm0yUmhudUFIZGpiNm5UUWFRdlNlZGlRSFJhS1RZM2YvNG5kNFFtVzI3MjdBa0VEWTdBRmFHbFlSbkFDd0Z6WVVNa200MTFWZVFzQ1k1RGVpVkVFSHJDS0tUQmQ4VUVYTXdCLzhqZDF5bVhmUVZ0ZStoV3dLQ1pmZERackF4MkF2RzNXaGlaekVqN2h5cjFzZXkxN04wZUxqa1p0aytwZVpWdGJJL2JWSWo3aUFmWjg1QUttVncydXYzaGE4ZzI3bjNJREdsQ1Ayd1M5QnhCT25tRUFTQUI5Q2xrS1ZoQUdyVGxrZ1J0aytJWGIvZ2Q0QzY3YkZRZHR6cmJrTnJkbzByYmh0dmV4Zi8zaEpRYmtnazNpV0o3bHVUWEo3ZW1lVThQU2lDUEYxbEdsb1ZJTVU3REJ0OW9GWFpiR1d1QlpoOUZTNCtLSVlOcVlWU2lGZGo0cVZvaUY4Snc2TnFnRVhrMGVWaTZpcjBia1JXN2t4c3ZndGYvSTRWTCsxL29WNkhhczVaQWU2U1VPTXJWRE9OajR4NVdDeVpPQkdkLzNXRzlJQkI4cUdqU1N4b09rRzdiQ3QrREpSb2lUbVJFS0FoVUVPZ1JqbGVHRFhPNDZPTXFsQkVETE40RWVaT2MxNUx3TzRsWXU2Y0krN0psbUJPOWdBMTRxT0phZTRtUHF1bW9qMlo1K3dUWElkQXJDQmI3cEJqcGc0NGxSemRlY1Z2bHNFTjQzZG16NFBWTW9QbkZvZEVSZ0JVR2d3UHZuNk80ZTdEdGxBR2NBQStkQTdQWis3Ny9WQlRtZzQ3ZWpxbFFEVTlQSmIvUXEzOG9DVEtOR1pZYXdtdmFiTFVjQVZoZ1FQZXVqQUhjek1vbDQxWmdlQUpvdUVGR2tobFdFbHg1cG11U1htclZ1UHN4UUNpRndBdXlPNzJObUFBcHdEcVZpUHZMODV5ci9QL09RYmdDQlVBTTJFT0JFUi9Fc1JEOG44eXZQblBHdnNUMXVZNlZBNDJCRTh3clVUak1Ub3dnVVVBOHA0QWF2VkJ5b1lBSkRFQU1ac0RGaE5qTXJrT09EdzhmZ2JVNklUUkhodm9aWDVJWlRPRXdpUC9KR1YzOFozQUJnb0FQd3BLVUdiQUJBQUFBaDhBQ3Z3QXhzYjNReFQvT0FuNlZQWlFBNkVBYjZrQU1Qc0VKOUR6OTczSU5sMHFveVpJWkNqeDFrRGo1MldIQkVzQVpBa09zQ0ZnZ2hvT004ZjlXNEJKYlBKQktPUkpkSmJaRXRJbjR5bU9kQlU1aDczc2lOK0o0cTlBcTJMemVkVUExV1lBVVAwUHU5WDRpK3YvdlZjSWpYZVB1MEx2dmxZNWpJdi96TTMvek8vL3pRSC8zUzU0aVJHSkgwVXd5cWZnT1JMMVJPLzNZcG9CWkpmR0x1c1M4NHIyQURDa0RnU2hWM3M4UDR0TytWaU9Qc2wrR1BRbFdYTzZUNnFQU1JNbmlhVjRpRnNBOFFFaVFZSWxqUTRFR0VDUlV1Wk5qUTRVT0JFVXY1b0ppS0NKRlh0R2hCc1hXb2xhbGl4YVJKV3lDdFZqRlRwa2hCb1VVa2xRK0JEMlhPcEZuVDVrMmNPWFh1NU5uVDU4K2NFU1ZTOUdIeFlrWW9VRWdkU2ltU2dJQUJUMjZzbWtDREZhc0FxRVo5K0lBSjB6K3dZY1dPSlZ2VzdGbTBhZFd1WmR2V2JWbE1YRkVGWUVWajFZMEJCRkN1YkVreDVrMEp6RjVka1lSRUFSQWpCaFRuOHRMWThlUEh1UklyUGhOR1g0NEhGd2NDbGpBUm8xS1FCQVpNbllCVmE5ZTNxVlczOWNyMXc2aTVJRUN3dWtWand2K0VWWWx1NEIwZ2dBQUJreWhUSGlKRnlsWlNqYlJldmJyWVBOVkxvdEZMVFo4dXNaVEE2eEt4WjZmZVBYckY1ODJQWnR6SXNiakhsQ0JyU1hzS2RmU05SRlJwMExqRkNrU0FyS1AwdzZackc2OEFhZlppU1RueENqVHdRQVFUVkhCQkJodDA4RUVJSTVSd1Fnb3J0UERDQzVkYkxqbU5ra3JLRmx1S1crcWpwb3BaYjRIMkJvaHF0L2h1bSsrcSsvSnp6YXZWYXJUeFJoeHoxUEdmdUQ2WWk3WUpkTXVyRmxOYVdZbTVsN0xiRENnbUNjS3VxTTg2TXFVVzBaNUlaSUw2c3VMcXF4Mjc5REl0cjNya0NyYTU4SnZ0cXRybXMrMDIzSExUYlRjNG41QlRSVHJydFBOT0ZlV1VDazRXVzJTenF2bHVxYzgrL1BEVGFxc1phVnovVFV6K0FqZ3pUVFVqbFhSU1NpdTE5RkpNTTlWMFUwNDc5ZlJUVUVNVmRWUlNSeFYwMEt2c2s2MVFRdzlGTkZFdXY1UjFWbHBybGJYSFVmQ3JDN2NibnNockFTS05QSTdBaTZDclRxZ2xhMEsyczRtS01ncXBFRDl5U2tYU3JMb1AwVmh0MVhaYmJydjE5bHR3d3hWM1hITExOZmRjZE5PbGxkSFlycHJ2dHJ0MlUxRUEzd2dvNmFTUWhFdHYzeEpOSk9rM2V2TmswVVg2Q0QxdHkyelZWWGhoaGh0MitHR0lJNVo0WW9vcjdqWk1NVjF6YmIvOU5QYTRLMFV0Rm5sa2trczIrV1NVVTFaNVpaWmJkdmxsbUdPV2VXYWFhN2I1WnB4ejFubG5ubnYyK1dlZ2d4WjZhS0tMTnZwb3BKTWVXWmNlbGxEQ0FNaWlsbnBxcXFOTy8reUxFWnhRZW11dXUvYjZhN0J0QkdFRVQ2bzIrMnkwMDBiYmdDOG1DZnR0dU9PV2UyNlI0d0xyQmFqVjFudHZ2dnVPdWd1M1VhTjdjTUlMTi96d3MzcEU1Ujl2eVBENzhjWW82YUNJSWpwUVJJVXZ0dEQ4Q3pKMG9JVHl5aUYvM0lBLy9qazRZY1JUVjMxMTFtbU9LOWZaVUVFamI5R2w3cUNER0REUlkzZmVlL2Y5ZCtDRC8vMkFMNHFvbmVvVnBzREV0QzFiZC81NTZLTlgrSFZIMXpUSDhlTWQ2K0NMZTRUMy9udnd3K2U5SHVPemI4d0FKRmloNmhZUVVHbGVldmpqbDMvKzFLZ0h3VDhWeDlIQi9DSW9FUDkvQUFiUWQrNG8zL0VNZ0lZYkNNQktwV21mNE9qM1FBaEcwSG12cWQ0RThLS1hZOWpBQ05ucndCWlFJZjlBRUlZd2ZFY29vT2dNb0lDVTFFS0JWOExLVmxBblFSakdVSVpLaXdzcVFIQUxDK2FsR0llQXdpRlFRRHZSRlNFY0lpUmlFWDFIZ2hKQ3pnQlN1QU5vVlBpRVZWZ2xBQzZjWVJXdGVNV2UxZkIrT1Z5QUtYajRpbFJBWVI5QURHSU1qSGhHQWQ2RERCM0lYaTRjNEFxTDBNSVdyU2lHYUZnNFJRZGlVWTk3NUdQS3VOSWZDd0pJSlZCd0NVeGVBUU15MXE0RDdrQmpJMy8zZ1Rja1VYUzVlSWNWZk9DWmpSeWlqcVBCa3BaZTJFZFFobEpXTkdDRUI5NUFoc1F3eG55T1VVd2d0dkNIUHNqZ2s2cWpZRjFXOFFRQkVJa1VMWG5KWnBpeGcwUnlrQjZNZENRQTJWRUNTV2JQQ0dIWWpFQjg4Qm1tTElDVE5HamdMRVY1VFd6L2d1VVdHeUJETUZmNVRiU3Q0QTNpbUZzTkE0RERDeGFqRmJib3kzVU1JcEF3ZUJPY2pabGNFWlJBQVJ3Y1lRZ1l1RWM4bnZGUFRNUmpFRzRZQWhjV3NRVjZVSTRTODBRZURGNXhFQWs4OHhXZ2tZWUFwaUpGS21aVG8zeUVBQ29aK2xHUW51OFB0K0FhOVd5Smx5NStrUWlYVEZaQkpKQ0tHcXdncERNVm5SeEM4RkNFT0RPT3RnZ05KOW5udmc5c1ZLZ1J0QnNJTWlCUG1pWTFwRXFBd0Q5QU5qVEYzVEJJdUpUR0lOdjVsNFc4QWdVT1FLcFN6WGZBYXFTaUlUb2xnaHpwS00wYlZJVjUxaHhxV3cvWG93RDhBeDlkVGVybmlrQVBmTHJERFVrQTRBZE1NSVFZbEdDTm9mUHExSXp3aGdDODVuMCtzeDhPRTBGVmRlN3kveUlzYmFsRFV2R0tMT1FCQ0FiWVlHRWZvNWgzUE9JQnI2anNXRHNqVVNlSzVxTE15Nk5iWFdzNFhOSGxIeHFRcVZLTFFJWVVGTE9SUEZoRUVSYXExQzNjd0ZBWnphTDlkdldmQUZtMWtFcXFTU3FrUUZjVFBnS25OSG5TTThzYW90Q3NVSzFhYXUxcnZVczN4ZEZsQXFqNFFXMUJXZ1F6NmxhOTRCdkVGcEs1eWx4UTRBWXZ3aU5iYnhaYlFONEZsd1Fna2hlSFZTeUtNTGNnem9XdUVxVUwwZXBhQkNsTEFRbDdWbFNWTEFHMXU5K2xzTnhNNmg4YXpQV2ovZnZBZWowY3doUzg5M2hHVU1CdXFNSmFwTFdHZ283YTFWMTZzd0FCTVljaXJ3QkRnVWYzQ0Z4UTVET2tBTWtDb0FJZkNCc01XL2F0Y0pIZlp0S3BLbEFETnYvV0d5VW9jWUFQUjltSVdoQXg1SmJwNExSU3M3NWUweUk2ZGFoU1hOUTRwQVo0QkNtdVMwYzdkdEo5UkRaeW0rZFdTLzhJVWdBTU1LLzVLS0VEREVoWnowYkVRWlVmQndRK2hDVE5QNTF3MGJxc3Bna01nQlJXT0FjTU5KdlVYT1JDTVpNT0JCRENrSThSOUtFUU4zQnpweEVYRjBDaVZDV2trQUFRVkxuS0loQnp6NnNPSVFYWStFMEROTUFZUE4za0hkZWNzMXRjSUFPQllMSm5mZDBZU2F2Z0QzTUk2bHRVSEZRNmRQYlh5MloyczUzOTdNY1pJVEZreUlBSElHQ0d1RjM0THJsVVNVdElBWUJlbzIxN0gyUjF1ZjlId25rR0lndTRtS2dtVll1bGFxSU1FWER3aExLaGZXK1FHcUFMSStBME9uMWxVUTNpVytBREozai93UTJlQzNFMmxiRStrcXFvVmVvREtPZ2ozR2dyd2h2TWZYSGhrZURWNEFUQ0E4SkRDeDQvTVlvdExQYkRldEROWnp0WjVTdG5lY3RkL25LWXh6em1CcWQ1elcxK2M1elBkQVVibUprNVdSRWtIYTd6cXErb3djVFJSZ2x1UUJuajVrYm1SK1VnQ1Z1OFpNZW1rTVkwU1Y0dUxsMmdDeW1YZWNzejhYV3doeDNzdHlONzJUdkFDYlNqM2V4bEYzdmJ3ZDcxbHVkYzduT25lOTNsdm9JTE9MWFFGVE9ubC9VaTlKVzZVd0tkQ0lPOTU0bmVwYXZYQkYvWXVMTVJUb0VMbEZ4YmR0TkZQb3hlTmJobjNzbHVIL3Z0MHY1NVRzQkM5S0lnZlFWTWYzclVwMTcxcTY4QTZVVXZldENuL1hhY2Y3dm1NMjkzM09kZTk3dmZXeGNLLy9HUCtySlpYYUErYmw2OENBVVp1NU1nUHJEQkdaVDZ1VVdzSS9IaEd3SVovQ3gzZmI4Z0hXNTUzVDhXOElWVDg4MzJMS2Q5MjhrZSs3Uy92dlNzcndBSDNPLytXTVEvRnFxZ2YvM3RmMy84NTEvKzhYKy8rOW5mZWxGNFBmU1R2UTRvdjdZYnY1WGpQUVZjUUFZME9OTDVBSXphdTRYcE82RGpOc2xLaGV3NGlGUkFBU1ZvdHMvWkhod1lBcjQ2b3cvQWdDUElBQjBnckFZOG5oV2dBRURZT3IvSnZQTHpQUFI3UFZoWXYvL3JQdzdZUC94YmhtV0lBQ0FNUWlBVUFTSWtRZ1JnZ2hGSVFpVmNRaVpVUWdWb2dTSXNRaUVNUWg5Y0J2emJQeDM4djlNTFFBRWN3Tm5qdk50YlFURWNRekw4cUZ3SWd3R1FENUlUUG5MeE9mL2N3S1V1T3BLVmlvaUVLSVZxRUxNeXpNUG5pem0zbzhIMHUwRlJZRDBkbEwvOFV3VWZuTUlnakVJalJBQkdiRVE4ZUVSSWJJRk5hSUl6UW9KZ2dFUk1iRVJOVkVRUlFFUXF0RUw5NDcvK1d6M1hnd1hRKzBLeGt6blBNb0FhSUlJbWVVVllaQWhtQ0lITEd6TjltSzVZM0luT3VDd2lnSVkxYUFBRk9JTVZNTHk1NjRKNW9KYnRXaXlIYVkwZndaKy91MERLWW9qckNJSmFMRU1EZUFjVXdDa0plQVViMEljenFNYUNnem56Kzd6UlU3MzNpNy83TzhRcFZFUk5kRVJNak1RV2lFZDV0QUI2ckVjTFNBQXg0QUgxRW9kN3RNZDZsRWVBZkVkSWJFZEdOTUlXUUlCT25FSlFyRDlSNUFEVjQ4TFBLOEJVZkRtdllrVlh6RVgvakl6RldRUkhoaktBVzh4SWtId25DWWlubXpPQWM5Q0xkeU0wTnNRNnVRaTEzcWdxSHVLbGFKUUpJcWdHSlBqR01Vd01CVmdEMGdJS1p2Q0JISWduanB3cGNRdzdjcnpCMUlPLythdS9IMHhFRVhBQktSZ0VFV0tIQW1DQllCQ0NZRWdBcmJ4S05naUZEVENCaXpPRFBiQktyTlRLQkxoS0xFQUNKeUNpZUVBREZ5QkNJVnhJVlJERjFJTkl0WlBJMm1NNXBiTElvWUFTOGRBUXdBeE13UnhNd2l4TXd6eE14QVRNQWpHV2lDQUNXaXc0QTJDQWh4S0taZ0VQREhHUTU4ak03N2drSmFIRGhpQUNjS001QThnRFkraWhUVW9ybFJ5WjhKSXFGK012LzJxSmxZSUpyTUtKeTZxR0hkQ0hFNUNERlRDQThCc3p4WmdCQUlDQi84d2dndElLU1puWXhnZGdBQ0NvTTY5Nk9iRWpSeHhzdngxY1NrTjB5aFpRZ09uTFRnL3JBU2hNU0NCY1NMcmNRdGhUdTRtTXV6R3JnVHZZcWJQNnNTc0JsRk41VC9pTVQvbWNUL3FzVC91MHozZlJMeDNxTnBlQWdod1lTbkNLVEZ0QXJaQjdpdmVnaWo5SlVBVmRVQVp0MEZWNDBEZlpEVi9wRFh2cHIwTmdKeVNKeGxLd0FTQ2dPVGxBQWVRRERiU3FpZ2FTUEpOWnplUHlGZGRVcmtLU3plSTBUb3djQ3FQWWlHanBsM3daRHVOZ0NRQ2pyQmUxQ1dZZ0FnVWd4cjdodzdBN083UVR2YVNjVHZwVHh3Z29RbmUwQURHSUF1MmNVaUxxZzB0OHhFYVV3aUMwdjFqd1A5UUx3TThyVDVlYkoxWWtKTE9xTlRXVFFJdlJ0djhFMHFXV3NJWC9oRXdHTUxNekpZQUZXaXQwQ2EvaSt6dDJJZ0pTZUV5RG13RXJrRG81bWhJN1RZUUlYTWsxUmRFMWtSZmZTQzVoWVFubTJORmo4VXdZUlpicHNFeU1LQThHTXhFRGxRbzF4QW9aMlJoVWFKZmE0QlhlcUZBY2xWUkt0ZFNFU0FVRnVMeXVFenNqUGRKQVBMMXpaRXFuRkFGM2ZNUjR0RWMyWUFBcUhWYndBUUEyc0VkNUhNaUNoTXZ2Wk1ndWRVanhORVh5REx1dU02QWFNTk01UXROYjhLU1ZZVk1MZk5NNEpiaklwTk5zUGRUUzROYmhxNlZiR0FWeldBSUFCYWxseWc0b29TaUwycTZ0K0psamF4UTBXWk0zbWRCNktZbVFTSTlXT0FUaUtBNFE4UkNFVFZpRUJaRVFXUXIwS0pFVE1WQnFBVEwzTkpqLzAxRlVzMUN4UnBrTmZ1MFZDclZRREMya1Z5Z0RvNU01V29YT1d6VTkrTlBWWGUzVmVheEhzMHdBSWVpRDZmc0FjUUFFQUJBRFRiaEtJZWhackFRRk1RQURRR0FFV1ppK1NXQ0RtRVhXZUZUV1pZMUxodlJTOFl6SUE0UzUycGsweFZnQnJNMWFyYlZhcnUxYXIvMWFzQTFici9VRWhXTU5PTnMyTnlVQ09IM1hiNUkwc2JWYWFZdGJ1WjFidXExYnV1MU5NbHdCaDNLU2lKcTZFWlVpcnNpMll4c1QvU2hWVm5FVTJaQ05WRmxjVlVuY3c4MFAvZkNZTUpHWXFIS3MzdEFsVXdqWHZTbktJdjNEbEZWWmRGelNsbVZFVEh6WllHQ0RTQWdDRWlDM1Zkc0ROc2pLbU5WS2Y1eGQyb1haMkQxTElSZ0Jjek9EQWdBRFRYaGQvd3NJU0N4ZFZ1OEV6MmY5MHZIa0JMek1TL1BVUTZreEFId0lBRUF4R0dVRUMyOU4yN1YxWHUzbEd6bklBVncwQkdlNkNIcGRMVHp5dElYNW8rS3JxdUlvTmJ3OUcrZnMzRDlNMHRDdHppWWx3ZzFnM1dHRkFLUk5XdG9GU1AvOVh3Q20zZGdWZ2g4Z1Z0NFpoVFRBZzRUMFFmb0x6OU5MWHVVVlU3M2NYbFlxZzJub0lhclRybTI5TmVzOTJ6Ymx6K3lsWUJGbUpYMkFpWVVnS3lmU1lPNHkzL1BObGVNU3BKVWdoUjhTUDVlajFWcEZVdFJUU3RFZFFoSEFBeWFRUG1MOWdDcllYN1AweC84VlNDUXVYZitkM1pnTmhraVFVZ00rQVFVdTNxZUYxcWlWUFFsV3VSSDJBZ1BJQVZzb3E1Q3pxSkhiTWg3eDRHOVZXODNkWXY4S1JqZ3c0TW1CSUtzejliRUYydURxWmVFOFpUZ3ZTeW5rZTRVSGNENGE5anI0dGRVY1Z0SWRidElqQkdKaXZZVWhqdDNaQmVBV1NHSThjR1FCTnN0ZzRJZDJNT0Rka1dJcWJ1QXVyY3ZrWGQ1TW9Ob1I3dUl2QnJrcEVlTkU3V0FYdG9zUGxxd1FWbU5ZZmw1QUNBRDZ1QlkxdFdOemdiTWNVbDlDU2dWYlFJSnc0OXl4ODl4Qm50K21yRjllSlYxZlBjdCswSWZWWGJwMkVBTWlsdDNhcldacnZzY21qZ05LeERoeFlJQit5TXBIWmxvdGpRRGpoZHJXazlacHBWYUszR0pTQnVOVEp0K011bDRRVHVOWXJtZkRlZ09TcW1OY05oZFEyeUpSVzRuSnNvVkhZTTYwSWRKQURyM1B6ZFZDZGxLWC9WWGIxY3JjeFRnVFFJTC9TQkNDYWI1ZGpHWURJWWdEZlhBRGpOc0RJZUJmZWt6VzRTVmVLcXhpVDViYUxFNUFXRzVuVTFZaGVCWWNlWFpsZXJabm02YWFRS0NEZnloUmpOM25IVUd5eCtJdndMc2tIK2pqeHpIWmt6MVNwTVJWUXFaZlpHN29GckJIcldRREFNQmtxOTRka0tibWtWN2FraDduY3JiaWMwWm5VSzVXRTJwRkdHMlNYWFJubUI3amVEWmo3SzFwYVBQSTd6MXJvQWdNTUxLQkVBQ0F6V0picFhvSEFxQXZvT3BwbjE2VVdnSTZQcjBxSDhpQy9SRWRwUDY2V2cwOVdKQmZsdVhoWkVZQWVBeUdDN2hxemZZZEJRaUdjTzVxN3lUbktnWnJNTVZpNWgzVFZiSkl1cTdyVW9pak1JNXBMcGxwY09YcjdKSHIxYjd0ZDBxRjJhbTVGV2lBLzBSRFRaNEdwUTlvZ2cxNGc2Y1IwcjFKakM1NGd3M1FtaTVoMDZtQWhBWll6cEI2MzJGVzZvUnU2bU5tYUg5WXk4Mys3dC9wQXhkQVNHWVZiVTQyNTNNMjdkUFc0bnd6YThva2l2QzRUUGsya0FYN0NDcXhPakl1NDFWRzIzbW1iUU9Tekw3MHk3OU1UQUpIVE14OER1bm96QjQxQ05EMDcrTUJBbDlBa1dteVpmcWhnUmNnNklJakJFQllITElJZ0Q3WUFnYy82aG8rNktWV1dSMHU1UHAxQVFWZ0IwY0tnQXNBQUVDNDVHRTFndzFnZ1FhUUFVZUtoeVY0eTlDV1N3Y09hd0pVWjlRK3ovUXNxOVNpRmo5cFVDVmZjaVpYOGtnWmxCZzVIYmh3Ni82VzA2aTdMazN5c2RGb1R6VzVUeStuejAxUjBOeUlrOTU0VkpRd0V2OVdUWksvU0FWZ2NrQUFLQVllcXlqWS9yUml3NXViOWpYcnZtN3NUdEttZG1xbmRJRVR1T1FrZ0lBNnVBUVhjQUdCRE9CcU5rc2gyQUFQY3dKTktPSnFCbUFrYm9GRFo0STY2SU1Ea0FJZUQyM3pQbS8wZHIxVFhHa24yOHRyUFROdFJkZVVrVzAwRG5FbG1sTlVOMWM4blJnVmE4WUs1R1htd0lVZFFPNjRab0JEeUtUVFRGUEJ4bGU1V0p3NmNIREsrUUljSUFGOURKOTRhSU1Zb0lCdDhDMFJOdWpPQTcxeU5NZHpuRittUE9aMTVFU0N0T3hLbDhkZ1lBSGRPU05HU0FEL1JlSnc1MFJQLzhRcmJFaXdqbFowVHVmMW5tQlR4MVkwRzRBcm9lTmhueDRxcDJsWEh4MVlyOU03VmZVMWhiT2dIZ0E2Y0FCZXZ6ZFdITkQvV09mM2MrWGdyZEZUMjZDQWg5Y2JJVUprVmlPZndrSzRkNENCYXVqSnJBTFVQN2IySW4zc1B3UkVMZFRCNmFUT2RQVDJYWTNDZG5RQlFBaWhHaGp2TE9WRVQyVGdlSmUvTFB5L1VxejNJSGM3dVBzMUF3aUNWZ0NOT29JaWFrS0ZmNGVZWEVFbkM0U0NWaUJaT1owR09Ub0VZNUNta1hPZmlQbUFDV2lDSHRpQWZOZ0NPZUNzM1RPQ0UzaVM2d0lKN1pyMW8wR3l1NkFCUkdKc1JWQzZZVjJITFdpOHZsbDZYSURGVjhnQk9SalM4VE5BeC9iREdsUy82TlQyYlpkNSs2dENUNng4Ukt4Q3VYUldlU2Y2b2pmNmlFUkZBMFRBT3g5OTByZTdNN0NCVWdCZlRDcFhuMEw0b2ZramY4NkxZMmdGaDRlY0l2Q0E3M1lETC9ndC83K2hoeXp3Z1JQZWpzM2swUVYvaFIzb2d2WnRNZ1JzYk5vN3Y5aXp3Y2ZQUVpnZlJTMzhVaTcwZk9VRmZUQmNmbEV1ZmUvL2ZycDdPckhpMjZKb04xUDRXNnk0WlozeFZ2VTloQ3c0L0tOV0FobmY3QXk0dnFveGdKdWFDQVhyK2hRQ0NBSUNCaEI4OG9TZ0FBTFNpclVpQmVVVkVSOCtKRWd3WlBFaVJvdEViRGd3NE9VanlKQWlSNUlzYVpJU3lwUXFWNmJNNVBJbHpFd2RabktxYWZNbXpwdzZjODZNNlpNbDBKVW1oeEl0YXZRbzBxUktsekp0NnZRcDFLaFNwMUt0YXZVamtDeXBNbElzbFlvSUxWdXRpaEVZY0dQQ0xSQ29QbUQ2NS9ZdDNMaHk1OUt0YS9jdTNyeDRNWDFBRmVEV2hFUURDREMwUllzSXJoMUdvUDhXeWFEbk1lVElraWRUcm16NU11UWpSYUFhYUdEcmExaFRaTTJpVlR1S3JWdE1mUHNHWUVWandvMEJBcVNaYW1XWVNNUlNGRFB5dmlqaFZRZ2dIcThtRFdyY3VNL2t5ak1kYnk2VU9QVG8wcWRUcjI3OU92YnNKUTA4ZXRYYm9vUlNQbEs5Z2tMS1ZLMkJpVXF2VmEzM1BmejQ4dWZML2RBWHhPdllDMHc1aERneDFScHlTRlhFRmp4Z2RpQ0NDTmF6V1ZRR2hQQ0tCT09CZFo0MEF0eXdDZzJzQkhCYVczV3A5c0VvZnJrRzJ4TUpGY1BmYlJGTlZORjNMYVpTQ2d4QXJLQWRVczdaK0J5TlJPV3l3Z2xsRUZIS1JhbnNrRXVPUlJwNUpKSkpLdG5VQ3Uvc0FHR0x2a1VJbWxqRkxHQWhoaHF1aFJwOVhYcjVwWmQ4amRML0dnMnIzQ0JBTGZ3ZDlpS0xoaENCeG5CVUZYRUdGeDhrZU9kalExQlFCQ1ZWR1JGR0p5eUdSeVY2QWp5eG5wWmN5bWNmYXlPYUtkc0NKNUtTb2tTNnRSbGxsTXlrZ2tJTndpMjJKS2dqR1dEQU8walk4TXBXbVBJbUpKR2h1dm9xckxIR09xb0RqNXlhcXFwY2hlY0RibUVkWXNxVlQ1eVZZUUJiZGdnbXNza3F1MWVqZ1pXWUppbHJUc1RiSzBqTUtDdFZCZ0NReXFXRzdBcFdsV1dkZFV1eGlpcjdZWWdCZ0RCaUlyRUpFS2twaHpoRUMwU3ArR0RwYnJucWk1RVByN3dDelJvaDZBTUdFRWFNYXNDblNobzhxaHd6S01CQURqYjg5dU8rRmJ1NGd5Y3JhTHd4eHgxNy9ESElJWXM4TXNrbG0zd3l5aW1ydkRMTExidjgvekxKQjQrNkdEMW56UERPQ1FyVXdFQURJWnhqZ3hXbEVGRnZ2aGJ2UzlHdVg3M2lxMmdDQ1RzQnNhaHd1Q3pWVlZzOTEycW9nQUJZYklTcFNZUzlSZk5HUkJZZFlVdVVBVUE4R2VXZzRJNGxMdFFhVG4yMVhhdWx1KzVyZ2JtcjBJa04yUUxGWWJoSmRDL1MzUnA5T09LSks5NWI0ZUpKaU52U3RFZ3VPVzcyRW03NDRwbHJ2am5ublh2K09laWhpNTU0NHhKOU5UUXQ1djFhakRRQ21iVkszQ0NVYXgvZHRkdHV1NWpxY2kwYnRBL2xKamFtelBpUUF4aWo1ampxQ1RCMFFzVFIzeEpoSG5wd0V6djM3VjErYU4rWTZySnlTOTd0SHBUUUFyV2NXQnNwRGdGT0wyNWdEMzR2dmtpUHZubmhYVGx1ZXZxUlEyRkwrYTJZSXY5YTZ3T1pkY042SmlEQUNheWlYWVBwM1dFdTk3NEZNckNCRG53Z0JEa1h2d25LYjM2bU94M2tKQWVGKytWdmY4V29SZjhJY29NTENUQkRySkRkbHRoeXJPcXhzSVc0czA4QXlQU28yY1NMVXZpS29PZTZJaUdtMVVKY3NEdmhodXl6UWhmZTduclk4NHYyV09HYXZCR3dYVGM0Q0VJU1FvQUZTRU44eFJoZmJWcHhDSG1WcjN5MitPTGZOaWpHTVpKUmpHRHNZaGUzcUwvOWllYUtJRndBQVFUaXZ3RUlDNEN3Z3hvTlRLaWhHRXFOVWVhQ1MrN3dwamVFeEZFYVZhd0ZJaE9weUVVeXNwR09mQ1FrSXluSlNWS3lrcGE4SkNZenFjbE5jcktUanpRa0tCY2d5ampHVVFDbW5DTWQ2empDUk53Ump6UzRoUktCeU1mVENOSC9QVVM4SlM1ekNVZ3hpUWd3TTRSWFF3QlhyMHE1RDRmZ1FScjl3S0k2MFZ6cGRYRXJGb2VHcU10cHprYzFxL0VqaUVZUklsUndNNGJlL0dZTVFTRE9jWkpUbk9BOEp6ZTVxVTFhK3RHYTBteWhPNitKelhuU3M1NzJ2Q2MrODZuUGZmS3puLzc4SjBBREt0Q0JFcFNnOFl3bk5ST3EwSVVtNjNwMzI5NXJ2Q2NiaFlpdk5semM0T1Fna3I2TnBxS2pIdDNvUnYybFFRNGVRbjlYREtHd0FwZ2hGTkx5blF4OUtVeGpLdE9aMHJTbU5yMHBUbk9xVTZ0WmsxSGJET2U2bE1pOVBESnhnRVk5YWduemVBdFlubEIyeGVvam8yeTUwNmxTdGFwV3ZTcFdzNnJWclhLMXExNzlLbGpES3RheGtyV3NaajByV3RPcTFyV3l0YTF1LzMwclhPTXExN25TdGE1MnZTdGU4NnJYdmZLMXIzNzlLMkFESzlqQkVyYXdoajBzWWhPcjJNVXl0ckdPZlN4a0FTdURBdVRqQ3dhalNpNE1vQVFLaklBRU5JZ3NhRU1yMnRHUzlrdU9HSUVLNG9Ta3pGTGdBcWdvTFd4aks5dlordlVHZi9ERTJVaGlnQzljZ0xhKy9TMXdnNnZWU1pBaFliazl5Z3J5TVFIaE1yZTV6bjB1M2R3emlqK285cmhQNlFJRS9pRlY2SEszdTk1MTdtcitzWUZyV2ZjcXVmZ0NPdjRoeE8reXQ3M3VkYXpkL2tIZDhscUhFSlA0UjB2ZnE5Lzk4dGV1ZGd2QVA4WkFYdW9Vb1FncTBFSUtUSUFuUFNSaENCN1lRZ2Y0WkoxY2JPRUpJYUplZnpPczRRMTNOV3ZxK2tBZHFtdVZJZ0RoQ0haYU1QK0syeEFPQ1VmSEFBLzRoK3d3ek9FWjA3akdML1d3YTBZQkJ4RVBDQWhEUURHUUw3T09FakRvS2dhQXdDalNFa1NYMnJqSlRuN3l1VUNrdXdtQUFCODhaZ3dYZ3F6bEJHR0FEQjJ3U2k3QzhJVFlHUXZLWmo0em12V1N1eEhkZ0FiNnVISlRpcUNGTGRNWlR5VDRjbFhrQUFIWXNFZkdhZjR6b0cyODV2eVlCVTV5V2tTZEU0Mm5BL1FwVzFNUXpMaGtSN3RBVTdyUy9WM05sTHYyQkJqQVdTbVU0RVliRkMzcU94R1pLa0NRaHltZmtLVnlNZG5Tcm43MWJ3ZHRwdGtjUXg1QW1FcWZRajNxWFI4b0EwWG1EQU1FTUpwSWJ3bld4ajQyYmZraW9qSTl5eFRIT0VlbmsxS0VFdkM2MnBjWlFxTWJkQUpTakdVQnBLRkJqRC8vZ094eGt6dXlnMDVFczBreGpUSkVHeWxGUUxTMTR5MlpObkFqMjA4eHdnbDhaU1hTd0RJQWZ5dzN3QU11V0Ntem1ZYm1lNEFPY0EyRWU4aTc0WHBZMEZRTWdJWm9oWXZmYXZtM3dET3VjZi9lWjNlRU9ZVHZiRkdEZGgrbEExc1loY090clJuTW9nQVhFeXFVcXFlSDhZM1R2T1pyNVF1WllET0EvVGdFYkttQXhqdGFKUlZLL0RqbG8vWjF0cEFBQlY2RjVXMERXQSs1Mm1QenFWTTlyVEFzT0cxNmJqa3J6RURvVWFFRVBkeGc5RG92NHRjTllnQXV4S1BNUXd5YlBUT3ZPdHpqamxXY3Mzbm4vSGxJMkNSQUJBQ1FYTnJVSHZ1Q0QwQVBlMHZGQURrZ3dyZWFQaHBFTFZudWp0OHJEWndBZ1FLTUFBNFpvTUFXeUhBRy95VUVJaEJ5Nkx3U2dQQ0ZMYnhoQ1MvWXdBWG0wSTVSQ0ZmWld3dk1ZQXFUUU4wWXdnZHJDQVJ4T2dDRUF3RCtNamd3ZThRVmtLb3BQWTlDV0pKNXF4K3ZmSythb1E4WjZFTGZwWlBaTFl4QUhPSUc3ZFVKdlIrUSt5ZGZ6TWhCOUpkQ2lTS0VBd09BZDhjWmdFOFZmQWNLUEY1eDIrSW5rS2prTDcvK09rM0hDNkJQWDVBWVlRV3R2WDVpRVZ5Wm5FblcrYzYwWElRUDJNQ3RWVWNSZEVBNHVBUEQwUmtHeE1BWE5HQjFTQnp6K0liYXBZN1RFZHZiMlI4SXlsUTY1TU9BN2Q5UkdBQVpqRUZoRFJwc3ZNdmRkViszdkVJRGxLQjJVTUpNM09CTW9JU1I1QUlRMkFDdXVCL1RWWndIMGw4SUZpRXUwY0FMaEo4SkdzVnUzZi9YWDJGYTNSRkdLd0RPNy9UR0szRGFFbHFGRWJ5REQvSUdSZXpRZWFUSG9VVE5CeHFoR2VLT2RvMEFEV1loY1JqQkY0aURkdTJWc3NsUWlSUWdESDVIS1VDREFxd2hHekpoQTNnSDR4Q2Y0a21QM0pUaEdSNWlRNGtiT0x5QkV2WWhWUkFDUG1nWEVhNlZmZmdGWUtDYndSa2c3YldJM2lHQkFYaWRJNFpFMnF3Tkp3cGlsWGpiaFNBZklxNGlUOUhPQ0RSaUtFTEhGM2lEZWhraVdtWE42NjFDaVd6ZmJlU2RxZ2hOak1EaWtxeEFHS0FBSUdLSzg5RENlYlNkS3JLaU00S0ptR0FDRFRDaXE5aGdnVjFqQnpRYVNrUVlOaEtla3F4QWI1V1pYR0ZQem5WTjcvakhpaHpOSzJSQkRRU0NNRkxIQ2dBQkVsZ0JsT1NLRGxIL3lhOEVDOVNGMnlRK296L0dSZGFjeGhLODQ5YzFJQVZ3UVR0WUd5b013U0trSDU3bGlIMzlRK1BGRlM2NnhxTVFBQUtwajZVY1RpbThnZytjQXdNNGdIVVlnUnlFd1NOb0JlSWRqZzcxaWxpWVFvVjhXeUhhNGovT3BIWlZJb0JCQUVIRzJSZWtRTzlaaGdrc3dreGtoOFFoVVg3QkZZNFIycnRJQ2hYbUhlYmtTaXBJUVU0V0JYY2NvOFVnalhpQUJ2UU0yM3JJbkV6U3BEL2kyRDhBUWxRZXhmamhBQ3IwSkpBZFFBVmVCeGtzZ0xwTXBGSGFaQzY2Qzd6TWkrQW9rTDQ4NVZnT3hWUTJUOUtnamkyc1RsazhEYkhBcFZjZXBsejhsMnQ4QUNEd1lWVjB3Q2Z3SkZvcVdqd2dIWFc4QXdGc2oybDBKVm45MTlaRVZOY3Mvd1NLK0k2SzNGQnY2T1YwOU9WM0lOUGpwQTRwckU0ekFSQ1pGU1ZpMWlZZ1NkbnJzY0lrQ0loMEZNRWJ4TU5reGxzS1pLTjBHRUFkc01JelNSMWRvWXRmQ0pJQkpZUm95b3N3M2VWR0dnSXpRR1ZxZHNjeC9lWFFiQkMzTWROZ2t0Qkt6YzUyMmFaNXNtQ2JoVmgwZEFBWkpHUndwbHdNcUI5VkJNSTRFSkQ4a2VkZE9WUU1LZEZyUE1wZ1JLY042VjN4WkNjdUpDUDBSTTlBakZBSnlWSkw5YU41ZnFVQWtrZ3RPQUFveW9sanZHZnZEY0ZEWHNVS2FNQUVxSnI4WFZ4NStwZmQ5TklBOHM0TFJzUXJER2h4UG9JdDhFcDVVSWdQb1lXV3NKT0RQaWhOZm9qVzdJNEFtQUtGNXQ0WEpBR0dUaVlYeUdkVXJFQU9KTUx4RmYvaWpiNlZySjBKejBFQjJPQUNpN2JZSTVCQ2Q3SWRLajZUbitHb2x3S2tBTTRhSEJuYVZSU0JCd3pwZXc2Q0NuaWpWQmlCRFF5R3hSWGJFM2Fjem4yYzcxRHBYcG9FZDJEcElCN0tmWGJwbHdhcTZ5R25ZS0NKQUdoQW5vWkVFY1FBbW1Jb0QzalpWZndKTThGa0VNM3BqdFpwTVhBZllsUXBkQmdBRXR3Qkx3Q0xvY0JPSGpGcG9KN3FiVjZxWUVpaEtRQ0FjVTFGQjFCQW93N3BuUkdIQWF3QmJWeEpLcHBxWHdVQU9mekFINFNCRWhqQUNpQ01yT1JDWnFIZ0d3QkNEN1FEcXRibUhGNWk3R2xSS25SZG1XYlpyTDVuUEVDWWtjRkFNVkFJcFFJcVdvMkNHb3pBRjN4aUxDNEZTVkxBQmpoQjFSVENxNmFydk03cnF5VC9LOEtRQWVtOXdCNUFBQ0owQTJTdEdRR2xteTEwQWhCVWFGUVV3UkZrNjN0K0FMZGFSV2RNQXhSbzZiZGRIQUNTbFJyQXdiRFNLM1dnNEFnZ3dsMDRWRGY5QXgvRXE4YVdyTW5TbDhGOGdSWmNnQmtBVm9RUzROMGRSaGlRTEdQTW1jSk9waHQ0QVp0eVJobFFuTk14bm5KeVZROVFnR09lTEhia2dpZmtBeHlxVjNOeUR3RzEyUVBRck5GT0xkVmFsd0Ywd1I4VVFsM05JYUZPNjIzWVFnTWtLa2gwUU5IZGJPOVpabFhrd2d3c1Q0d0N5OFQ2VzhWT1ZROXNnZGhHeDQyd1JIbXR3QnRNQWcwTXdJa3NRQlpJYmRVT0x1SG1GdExDUVRxMFZiUmlxcWFtUWlkWTYxVlFBdStaN2RpVm1wR0ZBQzZBUmhndWFhWG0xQjUwLzRIZ1lzZmRqaTdwQmdXb0dJQURJRUhvRmk3cnR1NnN2SUhIbWhYT3ZaNSt4SXNCRXNFYXJHNmNNU3JsTnR5amJtaTJCQUV0dko4eXd0eXFuUVpOcFFNMUhrbnBPc2R5dkVUek5vZnJUaS8xVnE5U0dNQVNzRUljZnRYaWRrMm1VdUZFTU1NNTZDNVRmTnJrOWk2dmFZR1Jja1lOUUFnWXVpVG5JcTlDdFVVNlVFRGRpbC96UHEvKzd1L3pOcS8xL2k4QUI3QUJ2SUJiY0NaTkFTd21wc2x0RUU0cFBNQVo5S1prb20rZFBjTWJyTzlVeENNU1hJRXhiSkhiUnBxL05lbTV1RVZqTWkvcDd1OE43Z1FLcDNCTjNLRCsrbThBdnpBTVUyMHVVQUE0MUNJSU0xUWw0b2ZPYlo4QjdnWVJqSngwZE1BWERJSUVCMW1SSGducWV2L29QM0NUQVg4SlgveURMZ3prZFVSdlN5d0hUZXdFTEdTeEZvc0NGM054Qlh3eEdJTnhGM094Rm12eFRyRHdjbEN4U3NRd0c3ZngvaG5CRzdCQ2lLelhWRDJwd1VrTGl6VHdBZ1l4UFpSdEVWdkdNNmh2ck96STN0Yk9FMy9BanVHYUdnT0ZDWGNBRm1leEY0ZXhKRTh5SlZkeUpaTnhGcDl4Qit6dklnT0ZHMzh5S0JmSkN2d0FqSWxqVHAxYnV1RXhBbWFCRWxoSEIraEFCUC94a0Ztd3JCZ0JJY0FCTFhZSjl2ekRGQkFDVkhReUpmQXZEajV5RjF0eUJYQUFNaWR6TEN3ek04ZUNLand6TkVlektqUXpNeWN6TWh0ekJXQXlMR2h5VC9Bdk1JY3lPSWV6a2YwQkpweFFIOTN3TGNsYUtxdlBwWlNDRlFRZGRoUUJQZFQvaWNLNndZcnRiQ2dhZ0FvQXdnM1V6UzdQVjFQa2J5TmZjVTZVY1RGWHNqVWpNek5MY3pRdmcwTXZRd1JFQUVSSE5FVTdkRVEvOURJd2REUXZjMEliY3hlWE1RcmpvRGVYcmppWHRFa3ZoUUdNd0NpUVlST25jNWpDYkg5RUJQQlVTOUVHTVluVmcvbWxIQ3FrUURoRW1QV3V3QmY4Z1BhQ0NDcVFLZjdheVBPZU1Bb2J0Q2hnYzBJM00wTmJORVZQZFFTSWdGVmZOVlpudFZaYk5WVlh0RU16ZEROM05EWnI4elp6Yy8vZXlFbW50VnFYaEJ5TXd6QndhVXU3RUticHNQZmF4dXdaamdTa0F0OHRDVGRTZ2dxOHdTTEVnRHNNUVJ0Z1FEdVlBR0pqUUJzY0FBbHdRVDFrd0Jib3dEWGk4MXFQeEkwb0IwSGZCRk03dFRWVC8zTlVTelZWYnpVQ0lJQUZnRUdRRllBTGpEWUNiSFZYUy9SWGczVTFXek0yWjdNb21ERlBiSEp5MkVobDczWmFkOFl3REF1dkh2QkwwNUNtRXM1M3ZJSSsxRFJ2ejJ0ellIWkJRM0pUSTNSbkwvUm5UM1JvYTdWcXF6WWViSGNMTUlHQmJCa2d1TUIyYjNkMmp6WnJkL1ZEYS9RMHgvWTFXM0p0WnpKTzRQWlBIQWVOR0VBTlpLQXg1YmVxRUVFSTNHL2g2VU1xV0lHQUR6aUJGN2lCSHppQ0p6aUJQOEFEWkFFSzdNQSt3QUFTMUFBWXZJTU9FS3V4eHFJQjZBT2t3VFU2czVCTkVtb2RwaWhlcm9vTnZJTi9MM2VTTkhkTVpEWW5RRGNsVDdjemYzWnJWelYybHpjQ2pMZU90d0NQQjhNRmlCb0FCQU9QdDRDT2p6ZU9yLysyVnRkNGVrc3plM1BBSmNPM1RYUXpURWd2ZHRnM2Z1czNsdmNHTS9RM3JHdzRWV1o1eFhTa0JCQlBodWN0RE53QTNLU0ZuQXAzb3d5Z0N4NUNMMVpuYjFSREtqeEFHQ2kzOWVaQ0lNREFJOGlJMFI2SFR6aXlac05DZElleE1pK3pOSVAyVk45NGVSZjVlQTg1cEZ1QXBBY0RBUENhR2ZSREFraTZCVUQ2a0RzNmVlUDRlVS8xYTBNemUwL3llOGYzZkp2dWRWZzVtTGM2Um14NWluT0dQbnk1cTZ1a0RNYTZWWFFCSDRoU3VNYTFYTDlzN0pHNG5MZklLNVNCY0Fod0VIVENEMkpFUjdLak84WWljclQ0b0JjNkdDdjBqRU96ZFZPMENMaEFHakNDTzhBQkU3U0FlT2U0cDNNNmoyczZ1bXQ2QWlTQUdzUmJIN0JCcHFmL083cWJPNUdYdXdzMEFocGNBQkVQUWhpNEFGZUxPcFBIUW51SDhhbEhlVXdZUjVYZmQ2MjdPcXgzK2F3di9PYThBaEJqaXdIQXdINVV5SzRhSnB0ZnFpN3VIRVBFZElsakNoRllRUkNVK2RTdWdBTThTVk02cFpBb2dCemdPbkVFaGJUYkJDUkxzclZmZTdiYnVBdWNnSUloU0JMMGdRS2NBcnpMKzdvWC9ib0hneEFJQVFPa25ENndnUkFFZzlFWGZib25BTHl6UUFHd3c1MGtBUUQ0dXdoUWRVYVR1c0E3T2NGRE9TZkl0MHVvK2dVcS9IYUdSeWxZMFBxOFBkekh2ZHpQUGQzWHZkM0xmZHZIajBadythdDR1YTVRRU9BSHZ1QVBQdUFqanUzaG5xd1lRQjU4cS9FMkkwNEZraTk1YjRyNllzWHdpaVFvZ1BIMDRZN00vMEFEUUFPdGZ3N2loVUJIa0MrTnlEeE1DSHBORUxyTmN3Q2lQM08yVzdVTGdNRjNLMW83QUFJTEFJSU1LS3daYkFBQS9NQTZqQm9xMUFIWFYvUkdoNzBrRjN6Wkg3d25wejJFWEdXdnBJNTVsTThXVFQvMVY3LzFYei8yWjcvMmJ6LzNjMUVZQlk2OTZBWnd3SHhUR0FBRFFBaDNvZzcwbHhIN3Q3Lzd2Ly9rU0k2L2FGVGxWSXBwamcwV3pnb0RRS3p4QWNTTlZUUllCUmoxQWRNL2hRc1pOblQ0RUdKRWlSSXhmUmlGQ2dRckdoTnVEQkFnelZRclVsQmVFZkhoUTBKS1F5dFp0blRwTXRXckJ3M0NHREdReTB0T25UdDU5dlQ1RStoUEF3Wm1CRUhoZzRpRWwwdVpOblhxVk1Jcks0K0FyQWg2Rld0V25aUzRkcVdVQ2Y4czJBNmN5SEtDSmFwQzJyUWNPTVNLcFFydXNnaHpSZUFCc0U1UFhyMTcrZmIxK3hkd1lNR0RDUmMyN0hmVUNUd2k1a1pZQmxlVlc3WnEwNHFDVlpaVGg3Q1p2SHJWK2xsb0RWcElYMEd4MWFxWU5BSUNCZ3k0OFJwMmJObXphZGUyZlJ0MzdodFBQQkpZVU16VXlKS3BjT1V3QUJwNWNwNEdHRUR4a1lvSUxTaWtXcG1xcFZvQTY5YmJ1WGYzL2gzODl1elpDWlJmSUswV2NGT21EcEd5QllVV0VTS3BmSlJTdWJLVWpUUEsrU3MzRUlLVTBnNHBoZ0RYSnJnRmhBQVFtb2pCQmgxOGNLR0tQa0FsQUZadW1XQ1ZqZ2lvaFQzaDVxdnZ2cWRFWE1tSGtxeEFBWVlhd2dDQ0d3TldHTW9JbkxTeWFhZ1ZqRGpEQVFBZUtlUC9nUktaVVdwRUVWTWFzcFFpamJSdlNDQ0RkS3FVVjdJSVFvbmora091czY0MnkyUXNzbUE1aXpLMjNJSk1McnBFR05PRkRRNDdFODAwMVZ6VE1ET1l3QU9CTVJ0ekRETEpPS0NzZ2kzTDBteXpLcm1hTWlzRGFvQ0NpTkpJTVVVYUFaNjRZUUtDRWtRRjBrZ2xuWlRTU2kyOUZOTk1MdzJnd2dzekhPQzNRK0FqQWdyakFEMFZLT1pza1c4NjZ3b1VxTkZiV0FHQjFscHR2UlhYWEhYTmlKVmVlNzNsRmhxRW5RREQxM3JqVUtSUjZiTXZsU3lVUUJYYW5uS1pvUnBXRDAyVVVZSU0rZ0RDYnIzOVZpRUpLZFNvV0k5K0MrNjk0VTRhY3NsMjNYMFhYcGFJZkU2K1YyaVJ6cFo4ODRVQ1BscEsraERKRU9ObENicHpGQmdxLzlxYy9PVHFTc3k0N0xJdHlGU1pjMHdFTEVZQUQzK2NZSlBqamozK1dLOFJnb0hUNGpFWmErd3h1Q1REMHpMTStBUnI0VDhUMWtsUVFtazVqY0FCRWprd0FGUVdCQmZvb0NlcWFKUUthY2hRQUE1SmljOFdVMmVHVnRYb2NDNXc1MXQ2L29CYm9TSEVoR3V1c2NiNklrN0pUVVREWWxxeEpUNzZYZ0ZBeXFkUi9ROFhwR2c1dEJaRkU5SDJvSVMwM250dkNZdk9hQ095elFVdVdYOC9CRkhnZ1JWZjNLVjVvWXZPdEVQV3EyV0IxYndUd0xmMFFuTHZYdm5vUXp4eGQ1a3BvKzBwWS81cXN5ek5lbml0aU1Gc3pPU0w4Wmk5aFFSQ1FRWGszSFhmblM4MUxHaWhoZGxKamxQT3VWSldlVEsxTEx1TXJKZGhQbjNtbXFWR2pmOXFubjNXbSsvc3dTWGFhS1NWWnRwcHR3RmxqcFRwQ1h4aTU0S3UxMTVyN3NtOVFZQUZnb05pbWgxS0YzOUs1bkFwUlc1YnJGTjBJQVhKRy9zSXVEMi9CUUJ3eERKVy9EUjNpUGNZN25BQlV4TGpLTmk0ZWRFTGNyYWdqaWxTVTZCRjdZd0dzcHBWclg2MWtRa0k3bGpBYVE5OC92VzVnQVdKR2VIanorbFFGeGJWbVFVdGF2SFNXK0lDdTRwWlRIakFhNEVGTE1DR0d2QU9pVWxVRXlwQ0VRd2lBazk0d3pNWnl1b1VpK1JWaG5uTnV4SU5LUUcxUVptdmVsWmJYd0hKT0RTTGRBOSszeU5DMCs2SHYrU1FENHpvbTRENmZsWkdiN252YUx4WlJRN2s0RWFvUGVJVkVpZ0ZkT2IyUDRIZ0xXdDJWT1NEL0VhaGpGem9oTHYvNlkwMDFMTkNGc3JuY0NjcFVwSkNGeTlPcHFSSUozbk80K3pGTHcxV3B4aVVLNUJyZHRhb1h2WHNJRmpqV3JpOEJqWk9QWElqR2VySUFES253cEZBY0ZrdmJJa1BVR0NFL25EeFNqZGszVnErMUVNeGllQmlHS01kOEloSXhBUUlZUVJLMU9ZMi84SUFJU1NnbXIrRG92QXVOa1hqVmZGT2xHblpuclpJdzFOSjcyYlUwNW4xNnJqSVJlTFJlOEVCWHh2OStCazR4dk44NmJzYTl1d0pJUkJjZ0FKVzZXZTBsSkFGSHhoQ0FxU0JndVFXWUNBRStTeVJCZFVvZzJvWk5sNlprR3k3eE53QzBsTkpVcmlIWC8xNnhiOHdpY2xVdkJTbU1YMWNTK3QxcjVScWtCU0hxQTRIcjJPNUFYeHdGYkdhRmFjd1dzK3RmWTFDQ05SSS95NGxpVGxLYnU2Qm5nTlJLYTR3QXhsUmlZYkpkRmdPZGVnNlZZVHBtYktiNWhDcm1RQ3pKaUFZYXVEbVdyZnBoamdFNDZ6aEZDSTV5M215Y3lJdm5jckxZbWJhQ2IzK0dDQUkwcEJjb3A0d2kyR2dncUFidmVjWk5aTFBwYTFSaGd2OXpBb1ljQXpxRktPaU42QUJDRWFoV0V3RUFCeU9jQUlqK3JDQkY3emhDM0pBbUdUeFp3QVl2R0lsZ3BRYjNleUd5TVFxRnJjYzlWdllLbVNoWVdFb3BMeHBEWGw4ZzU2U0ZrTTk2MUh1Y2ptSTNGUmVwM0tyeVU1ckZ2V2FvQklyaEwxS0VDeS9Oc3N5ZGpTcENZeWt1VGprd1BnUWdSUjU0Q2RXc3BvNjFXMEpUMTZTR0ZoakI4U3hodk9zMTh3bVcvZGlBaVR3UXdoc2dHdCtDZjljWURZSUlRNzZrQUYvOTdLSGI4YTFtbk9kWFRUTnVZempXVEd2V0hUWmxUZ1RNOVorZUxJUStJZDNPY3JZbzZWUm41QmRMNGhaM0dJWCt6TUVSSkFYLzhBNFR6RWFOYmM1dm1NdHdRWXBUaUdRVnhZSzFtK0pWV1FqSC9uSXdncWhDSWY2WTFURXNydTMxZkdJeFlYQUN3bU9BR2JUb0EyZWxaelRKZk85eTl6aDY4SnFYendJTVp3V01Dc2JMQkdLRC9CM0QyeGdRNEh6bTJZNzAvbXN3Y0FtZzJ0Z0NTSEFOYzBTSGg3eDVpUXhES3R6blZyc2s0ZGYzR2d2ck9BQy94anFrMlVwWlh5aStMRnNkUFNtT2Qxb0F5akFQaTBSSkNHblpsRVFqSEhLcVNaajF5VDBOVmUvR3RheFpyV3FoWWJQSjN3a09NVmd3SXFERWpQL3JaWmxtUldRcnpNalVGOXAwZzZ0ZGdnQ0k5N000THkwUXd4ekpyQ2RxVjN0T3hNNEdIRm9nclAxZ2dwR3dLRWZjQTNlaEV0V1BEcmhOY09KNW10ZnE5UnBGaHRnREJOZ1phd1NORUNHWERwcEtkYTB1L25kNzZldG9BYXBtR0JzQnlrMURvYngxRGltOWNJWjNuQytWUVFqRnlxYlNIZ1JocXQrWm1FY1ZpWlhoVDNzci9wUUJDMXdRUm8yWUFadUE4YkIwNjYyRUZuZThwWmJtOEI3UGpsZ0RsQUhZYmpBM0JjK3RGNnoyQUhuZGJqZC9sNm9BVFFnRGRRa3lxSUN6Q2krMWJodm9UOGQ2bGxaZ1FLc2tBcW15TFpRcmNKV0FMY2xaWWQvSGV4aGo0aXQ4MzNTQitoQU9SbFAzVmJqMjh5UDB3VUJUTURMekFGeml5cEkveHZDY25YNU9LTjQ1cjJURmIvNURRWS8ya0gzd0NqR3JqclBjQVdXeDg1Rit5bnFyYzNCSWFRanoyd2xISHRNMTNka0k5OTVmNi9BQVNpQUxWVDRCNTFXMWMzR0NWZTQyRm5mK3E5akxlSWNBUlY3cHJNR1kzcTVTbUFHdHBqYndzTzNGenZ1Y3pkOFh3RHc0THhIdU9WOVYzNFVYVTd0L0xMQnpjUDNDK0lMWGFjck1sNVBqZy9Md2p6L05BUGtZRldGck5zaGxhNDN6V2VhODkxWC82WU5jQVlHV0dIMG9zYTZvZjVuNnE2N0h2LzVkempadjBlS1l1SSs5OXhyOStLcjk0aHRUUEJBN3FTUEx6N2c3bFFPK1ZodStTSndyTkFzelFRdkVxSkFBZmtDOFJMUCtoWlAzWDZPKzlZUGFzQXZPbWlML081dnhFek1zZlpKQlA5YlVPaFdJQXpXd0JaZXFnUVB6alc0RHFPOFR2OTJrQWNMQ3VJQ1FPSjRxUmhFUlRxbUlCRFNMZ0J0YU9NZ3h1M29LL2d5c01HTXo2enNiTzhra1BtYXJ3THpTd2dhQUFyM2d2cnVLakoyRG92Mnlua1l6UVh6aHdURlR3Qk8wTjdPandYUEVBNzd6UUJVQUI5bWdUV3FwdDVXcndmM2tBOVg3UU1RYUNNNlFuNUdRajZxd2FvQXNETitUVXM0cnVOOEQ2d2lJTzdZb1F2MUFnTHdiZ3FwOE84eThlV3U3YXlFNEFjbVVROCtZQStFSVU2b0tBeXZMMC9Ja04wNkl3Ny9LZzFOa092YVVBVXg3UTFiMFJiZGJRVkc0QjhnUlpiNjBCZC9rWXhNVFBaQWdoRFhpRzBRTVJIWER0Z1kwZVBvNjRjUXdBVmNnQWxlNEFBd1Fmci9Mc0FTd2NuYU5KRUNxeTNtek1Ud1BvQUVhc0FmbkVpSzdPcmNJZ01WUDNBVlBlTVczK2dWRFNrV2Y4WU5WZXdkNzlIZGxHQVMvcUVYZ2RFZi94RmNoTEVqaUpGUWlJTjBrTkJQRkhGMU9HN000SUppb0Vtcy9JNnNnb0VOTkFFTUNzRGtHQ3pPQnF6T3JNMGp5NnJBWkk2dE1FRU5HQUFMQk93QjZZcDRPRkJseERBdHNrL1J0aThFOGRHZjRuSDg1dEg4WnJIc2FwRW1lL0xGVnFBUGRyRWZBWklvaTlJaHNNWm9obkYrNU9NNXdPRDJRT1BMRkRMWW1oSGtvaW1JcUFra3pVb0lqb2pCM0lBRi9nelB3aExQOUN3VXhNSFprRUFLOVc3Y3lHMGxUVkVkUFZBVjI3RXJmTEltd3c4V2JTdGNkTExwMG84dSsxS3l2b0FBLy80d2IzVFFLQXV6Qnl2Q3ltUlBma1NsSkpEaS81QXhDVzJJN2JxcUNhdlN6Q1F5OExTeUR3eHZGTVJoQXdCQUREU0JJb1dBTkFVTUZNUUFERWFBRVdUQjhDYkJFdFV5aXVxS0pkOHkzZUx5OFNEUEw3SGkrK3hTSHZFeUJZdW1zV2pSSG5PVE9EL01BQ0FBRTVST0R3MlRPVnZ2QjFsQjlyS3NGVWFsUGw2aEFSUUtNcE5SR1JlU0NSM1JNbzhOTTdOU0NQUUJGTXV6QU5MeWlRUk5OdDNTVHRRSkpuOE82R2FTUDJwR2xPclRQdThUUC9OVFAvZVRQKzhUT2s2aUJtL1NOK3ZSNmVTUUFXemhreEpVUVJlVVFSczBTVUlKcHBpaFVCcXpHaDRBQlhMZ0VRQWdETTVnS0hoTi9RS0JEb0N3L0pxVFJQVlBCVzlOalZMQlB2OWVJUWc4dE5mYVN6SzFoUGNxczh5T3JSc3RJQmhDZ1RYTGswY0JRUWhna3kzTktSM2JrK2UwNzNuOGFueHFRTVlxaUVuYlpkUUNkQTF4TWkrQjg4UjJjamo5elFEMElmNmFsRXNISmlwOFFCSUFRTFhXendDVzRCWndjQ2hMVkUzM2IwSkFJQWl6akRGTllrVnJ3RVZmTkNwakZJY1kwcXQrejlpdWtxeTJqVWNETlM5cUlCalVzNjdjOGkxWnB1ZmswaDI5YUVtN0ZGS1g0a25Wa0EzcFVTODNyMDViTEV1M05GSTdOVjRFcmdhd00rcmV3UlJ1QUE4eGFrMVRsZUhxa1Q2VTRoVjJEVlh1RkV2ZWl4bTl5c0pxOU5pQ0FSQUVsVmZ6UWhiU3dBVlVVa2dWcnpZM1RDYmxNMW9FNVZFOXRWTWppcEN1WlExZFNVRVNpVUQvK1pMOXRKUlpzMVZ4bU9FY2pqRHFab0FjV3FOcXJpYWpWTlVmSjZBSmVzQzA4dUVOd3VBTDNoVmV3K0FOOGdFSDlxQUhuSUFHRmdzNFQwZ0l6NFlVcHNFS0dLQXFua2J0OEJTSHVwUE14T1JpV2lBTjRxRlhIMVlQbW1BVFNHWlkwV254M3BOUjNVaFpMWWlUanNSalB4WmtRMVprUnhaa1Q0S1FUczl1NWdqekl1UlMwUzlUM3cxYlkrdEIrYWMvYTlabTlkTkk2c05JRmhSZVJ1ZGwzdzBBNGlkS2ZkTmNXKzhER0NFZm9rU3lES0FMdEVBTitrWXcvMkVBQUlFTVJMV2ZDaFpMSnBNeXZmT1pYR0FQSUJaczlRQU9jRzQyRTlVOWpmVklXZEdQQkNXUVpBc3BDdVZlcE9PbTlJVnU2OVp1N3hadjgxWnZUd3FWYXNHRC83SmxSRm1XU2xmd1NnMDBrR2hXUG16S05FN3FwQTdCY1I4WGNpTlhjaWQzY2huWGNpL1hQZllscGVLV3BUSkpncHJpRldEZ1owSE1BRkFneXhBTzFZcVcxc0RoQlFqaEtkM05DSlFBRVBLMVFVRGdCN2JBYWwwTWE3TldSbXVWUnVuQ0JRQWdDY0kyVUZHaERzZ1dVVjBTK3hiMU5odFZZMFdEWHVndmxTcEhPOExEZXE4WGU2LzNDYXJMVkxGcjB0SjBTdEhJU2d1VTM1akRPUkozZy94V083aFhOOXJYZldOamU3dUR1TTVEY3pya2dmNUZrd1FtRmM3aGRRM1U2SEtHVVM0S2ExUlh4eTVBQmZyWDg0eUFERVFNRmZvQWR5TVBhNVVKRmdpd0FJbXQyTWdFREhpQVRXUmdCTVFnd1BJc3dFSmhBMHlBMjZKZ0QxaEF6Lzg0a2lKemRBOHlNazNXQVFESUZoMlBoemJ4QkNiWDdWalZ0cDlxNWxsZDVRWmRxY2wrVElpSG1JaUwySWlQR0ltSjZzbWdqTVFjb2xwSGw3V2lodjRJQzRTYVRGT3VHSXVUNm9ocHhWZDh5NFJXZ1d4NEEzT1E1WmNBSmlWZUlRU2dPSW9Cd0JSS0xZQlhsb0FWS1NFQ0lCL1V1RGpkeU5lMmt6c2haazhmOFlKRndBVk9nSVQ5NG1qcndBN0VEU3Vkajg3R1U1djZJQnVQTDlEUXpJbWtZQThLcnkraUFBeGtlRTdTOFJRWEQvdlFOb2VkZDIyL3FQSUErRUJVanpCMzhJbWY3cDlLVGFCU3QrRzZ4dFU4aWx3K1pVUG1KejVFNlFRUTJOMEVwUlhVVUk0Q040NnpSMEwrNFFkeTk0N2RMWStWMEdHQ3JSSGQ3cXY4dUdML2dqV2FJckx2OWc3bWdxRUhlSWVKbkdqbFhDNENxM2tsaGRSNGFMaVQ0WEt2Y0RodGRYam9TTm1WNlNtVlZibGxlYko4R2FCOEFJb0Fnbm1nRGhQMjNKUmZkM0tsYWlMcVhPc1E2Qyt6R2lWQkJuaVlhdzMyakJtWkNiWUlJcm9EWXJjTHprQUo1S0FESXJvSU9pQ1pmVUpXeFFJejlwaVBLM2krL1BpWlRBWWlxemtDc1RrQnFrQ0RRU2JPeENuNWxrK2N4NW1jVWNhY3o5bVRSYUh4akRTVTJYbUgzVm1leGhXV2ZYR1ZoYTZWcVVlZml6ci9ucE5mcFhNQllEWHFwZ1VhRXRkLzZ1WUpwSFNoNytpTVVHRUN0dURpb01Ybk11QUFQc1lFNmtFSGlxRHpiTUlCME82WVBocWttNW1uOGFSMTJLTDNmRTlpZm0rVC85alkvNnh5K1ZvZ0dMaVNZOXJCRGl3Z25NVVpwYzF0a3kwc3I2c0l3MUJSZVhwNlQrRFRuVWhYcUhPR3FKZVRCNDhhUyswNWpsNVpzOFhPZllnbEFNWWhET3o0M2NyZ0ZmcG5xT2NJQmJlNnhCZ0xCQWJnQ3hLbUNDZ0FBOVlxSHJSQXJSdU5yV0dnRXdMSkpZamdHR2NJUmdVd3BMZmtMQmlSZ25jSW1rdDZyL202cjZQSkJYWjFUV0s0cG0wYUhYRzZzVnZTVHV5YXJoRk51VU02TStCem5YSFRzbTNtblc4c252V1BzdzMwbnFkbXFVTWI3R2dBQXY1QUJWWWdyTHZQdFY2Qnh2QjVudWlvdlJmYWxpeGtBZ0xnRDFCN0p6cUFESEo3NXVJaEhIb2JmNHhnQldhZ0FhNUF1SU9rRktyaHRCSHl1SFdQdkZkblMrWTZ2RWY2cnYveEdreE1XcnBOcGdXa1lBUmVITVpqWE1aaFBBMFdJN0czdTV5NzJ5MitHN0xwbXFlVk81MG5tOE4rR2xsWnpBaU9ITWxqSkJlV25NbVgvQmFiSE1xVEhNbjNtOTkwQUFpdS9NcFZRTXUxbkF5NjNNdS9ITXpEWE16SG5NeS9mTXU3SUJDT3ZFTU5nSmZ4MFFCMjRFY0tEcGpuRWJZbEF2YTZKeEZxNFIxaWxRU2cwQVRJZ0tOUHhRaG00QkhnYitDOGxNUFZtSXU4WXNqZDY0YklHOGhKdk1UcitzUzcrMWFqRzlNekhkTXRMS2QzL0xGNzNEMkJQTVNGdk5HSjNBdzdHdFZUWGRWN3dnaE9vQk9HUktJb3lrQTJTMEVHWEhXZGVoVjRveFgySEZBNm9NOUJrUWNBSFZCMElBdEtvVk9KSUFnZW1yMFdYVHRMWFFrZlBibi9sVnZTdzl1dVR4ekZ1eHZiczkyeFA5MlRRLzJHUTlybnpMdlJtVDNvVnQzY3p4M1Y1VUFTckE2aTVQd3VoYm5Pdy9kOWVHa0E2a0RCR1Z3U0F4VUhKRnc1akNBTURyMHBlUFlwbUNFTFpxRE5zNExja2NuWm56M0VJNTI1bTd2YVBWM2lKYjdhcTMzU3gvRGJTWDNoRTU2TDBOM2pQNzQ0djQ4WlpteTJPT2dPWGR2ZTRqMHZ4K1dFVVBRWXJxQUxBSVVTaHFCWEtTRFE1N01NMkYxZVFNbGthYXB6WFloZFFEY0hBb0hLUFp6amw3blJ3NzNocGYzaEw5N3BXV1o1TXI1NXhOM1VqMzR1UVI3cnN6NDNnY0FHakoza0RRNno0Vm5sV1RiMkpzNFVzdURnRVY0RjhsMVFGNEhmMytpMWVQNXg4T1ZRbXVzNjBBTzVOb2NrLzh4WVJGNUJFb0JBd2JPVDJSZmU1MFpkUm9FYzhSTmY4UTIvdkozZDZydEk2eU5mOGxGOUJRREpndWdGbUVIYjFsVVY0dnc1RWZvMVg2d0FDQUNsQ0g0OVVKUGdDMjdlUHlSaHRVOVdjZ2lFTmJyM3lES0VOd2dBSk15TEtaRkVSSHlnRTlCQTJSZnE2QmRlTEpTZThSay8zS20rZVJkOThwZWYrWk41QmZSaFdiOWVPZ2Jrb0lsVzVma3Z4UTVCSHhTY0V1VEF3WGswd3ZNSERGWTc2eWdxWldXRnUzb3NLUlBoMW40aldScFQ5MGVFQ0I1QUFYNWZzaDYvaG9SZi84Zjk4UUhDaThDQkJBc2FQSWd3b2NLRkRCczZmQWd4b3NTSkZDdGF2SWd4bzhhTkcrV0VlR1VvcE1pUUVrcjVTUFVLQ2lsVDBnUThTVFNCVllCUkgvOCsvTHVKTTZmT25UeDcrdndKTktqUW9aZytvQUp4YThLTkFRU0tIWUx5aXNqSk1FWXVGdkdnSjZ2V3JWeTdldjBLTnF5ZU5vb29YVHp6SUZVcUlyUld0cnl4aW9aTW1waDJGaDBWQUNrTnBVeHJtVHBraXhZUnFhVWtTQmlKT0hFcUNRemtWT1Vva1pMa3laUXJXNzZNT2JQbXpXWWhTOHpsT2JUbzBhUkxtejZOT25WREE0OWVIVTVNMGlTUmxHNWR3cndGQWxYTnVrTjcrLzROUFBqT21rZjNMbDFnaWhSVXdxbkFHTUJZQklmWTZkU3JaeDJ5cmJQRkdWWjhuR1JiRzY3Y21SOTQ4eXhxTkFDcnZZbWU5UDBMUlRCaHc3RHJoM3hsUlYrZzU2b1ZjdjRQWUdiOUtXUUFFRENjbE1vT29BM0lZSU1PUGdoaGhLYXRvTUQvQTBUWVI1SUUzOUZpeXlHbUxHQmJUQUhvVnA1d0pwNkk0b25FSWNVWGNrOUY1Y05ocjhDd2drWkZ4R0JkanRZZGNFWUhHUmtRQkVnYXJxVVNTd0xjTU1GNE5SSDF3U2lvcUdlY2UwMzlGZGhnM2huMkdvYUpsZklLQ2dvWXdKK0VZcFptZ0E3NlBPQ2FZZ3FPeVdhYmJyNEpaMFlyT0ZCR21sb2FZcGhzdEpsU0N3RURJRG1lYnBpWWwyS2hoaDZxMDEzcVRaQUlVOFcwVXFVUGhZVkVCQUJoWWtSSmRLam95R2xXS1p4UnhFWkduTkRKWVNYNU1Cc1VyUlRqSjVLNENmcmJvRTArdVI2alN4RWdqU210S0NkWUtwSmllV2Q5RXJ6U1NRaGhnQmxuc2dVWkVBZ0FrcVRDVExDR0pMaWdzdFplaTIyMm9URUx3RGxFcENLdC8waUdlWmZxU3F6K0dSY3J1ZTJHYUx2dUhscFVjUzA2dFZ5TVdiN0NRSTJlRmRGQk9DUjgwT2xXYnVDZ1F4SGFiV1NBQXVCbWlDb1JSVXJ6WjVKejJXUWlldW14a3RRcVN3a3c1YTdMU1dWdmx1RnU2ZG9PTlFDQnJMWmtHdkFPQTJ1c0pmTElJVkdyY3MwMjMzd3RtR2NvQUlPRnpNUThjcDRiUXVGaG4rakdCQUo1aEw3TGROT3gxZ1JsaThsQjVTdDlJcFh5d0R1UG5kWkJCMFY4RFRhL0I1ZW1CQXJSaWp1a3crR2xxelM4TmVFVnRjWURjT3pYMVBMNVdwalZNbVBJWlNvUDVCREVDWEtBdVRYT1JvQ3BReGdNN0dCRlZLWHNIUzdOT0U5T2VlVVpIVTc0R1dFQTBFQVpEM0JKeE9PUTI0Y2x1V3dWeWFwTGdNcEU0di9TVHI4T2UxQk41bVhjQUF2UUMrT2tpSlZpeGJHV0oyU0VDbGtzUE5LNDVYNTRwTVJ0dnl2cjdPb2xaZXZjdCt2S2ExUysvcXIzNk5KcU9Gc3ExV1N4QXd4VUFBREdER2ZzQjJiNkJoaGhSQzd1SytSK0x1eXJuMzRnUUx5alFBME1oQ0NKRGRQQ0NEVHRhYThhdzNxRkFRK0l3QVFxY0lFTWJLQURId2pCQ0Vwd2doU3NvQVV2aU1FTWFuQ0RFaVFDTTlSU3Rld0pVSHRZTWtuRGFLR1NWdkRKVDA5WVhkSm9VcUxZeVhDR1FDRk9BSkxTS0FINGhSUzlzbGQ5WGlFSmxQMHVGM0tBQVVpRVZZcTFjR2hWclpyQXE5Z2xRL1E0S1MrMVVvcDc2RVk5VzhSbk1OY3JSZDRDT01Jd2luR01NaXVoQ1JFRVF1OThFWXhrYktQL0c5OEl4empLY1k1MHJPUGVTdWlkdFp5dVE2WW9oalJZaUNRbnNtNDNycU9oSVE5NUUwWFY2bGJGU0U0UFJZZ1lTZW5EQU5YQzFnb0FZQVhpd1Vab2JMRUZFeU0ySHJvZ01pY1dlOUx6MkhPREt5NmdGbzMwMkJhNXFNWXYybkdXYmpSakhnZnpDaFRhZ2hTa09FUXJEbkVJWGtKaE9YaGpJeTJQaWN4a0tuT1p6Q1FqbGs1MXk5bm9jaVY4V2dBZ1lTS1hwS0VDaG9VY3BUY1BxU2dRMUk0QU82eFgzb0wxaWdmVVlIQnNPcHdDMW1BbkxaMUtpZVpxWWloaitNM3pTTkdVR051THhwWXlOMXcxOGkrazBDSXRhQkVWV0tyeG1aQnNaaGdaQ3MzdjRCS0ZVTmlsQ3Z2NFJ3RU1ZQUJQNk9oR3NjaXIrUmpUb1NRdHFVbFAvNHBTdERIVWkyZlU0MFNuU1FvVkZxTVdHZVVvWEpLVXpSRnhzNXY1N0NrNFo4VWlqUW5nZHBEcTRUbEh4Z3dpcklFQjd3QlRKU0VEcGhrRTRSeHJLZU80bE1qSGxyekVpUy9FcDArRDByeFpCVUE5VmZ6bkZRbUFLMWFhZ25vRkhlWkJFenFZYjNrbmxtdUU2RWhIWjFjenR0U2xMeDNtTG1PNjFwblcxS2FKV0FWT1dhRXVFSUNnbjN6UklaWHVSbGVXU25heWxLMnNaUytMMmN4cWRyT2M3YXhuUHd2YTBJcDJ0S1F0N1dYbml0clVvcEd2Y1RYZ1FTbjZWMSt1dFkrMXNLWUFOUHFuRzhBa1NiZEE3RmkzU2NpdkNuZTRpWndkaTlvejFFY3BCMFkrZkNoS1h1RzlCNEJ2SHpDb3JuVkRVQVlVMktBN0J2eVpHRG1aUy85UEdnbVVFL01xY1lGak1iRlM4UlkwMk1zRVZwR0lHd0Ewb0FSWWdEU0tNVkJkQlpPWFduVHJheEVLMTdnS2VNQUVMakNCRC9oZnY4YTJGUmVsclRSc2k5c1c2bllDRktaQmI5WDFXeGlXWjFCU2pGcDhtWExmdGU2S2x3VWxzWWxQak9JVXEzakZMRzZ4aTE4TTR4akxlTVkwcnJHTmI0empISnZZRm45Vk1UQ0J5ZUFHQnhhL05MVW1BVzRiWWZucTFyQTR2WERTUmdUYzRKNTN5bE9XRlY0dzl0NWIrUVV3Q0pYclVWTXF6M0dka0kvbm1uQ2dvRWhsZDRWMUZFNHk1V0lSeTE3M3ZqY1I4Wld2ZXpZNk40Nmh0YjcybFVZdFdJbmZRQWQ2dHJNVnRLSC9MSTBIRy9uSXQ4V3pUZVZMWnlZM0diRVlocktHTjh5azlDei9scjBVcnJPU093cnFVSXQ2MUtRdXRhbFBqZXBVcTNyVnJHNjFxMThONjFqTGV0YTBKcldTYjQxcjNVWmEwaFRHcVlVdm5OaXhXcm9teEI1VW1vK05iTHZZc0ZZZkZxamRZQ25MbE9KUmp5aU02VXhiNVVMZzhqVFpzQXZyMjlwc3lyRXFsdEp3am5ONzI5dnJkS3Q3M2VzKzk3bHZBV3pFS2xiWVVJNXlzWTNkTGc0VG04Mm9DRGU5L3czd2dBdDg0QVF2dU1FUGp2Q0VLM3poREcrNHd4OE84WWhIdk44VTN5YWJpWTN4RGVPYjJ4enZPRkNhUnl0T2Z6aTUxSXRQUXJ2NHpEbyswNHNTemFWS1BPVEhWdTIydHpyRnRNYzV6bUY5WjN6blBPKzV6M08rOFpzTGZlaEVMN3JSajQ3MGZCUDdTWXYxcDN3REdtS0N1aFd1LzJwQjdXVHpxdGN6SXFpMUIxVUpZR091MFJZYVZpNnM0MmJTejQ3MnRLdDk3V3h2dTl1VHZzK3hNdFpXQU9XWWZmRTcyLzBXdEwvRDdMdmYvZDVqMmZaeHByYmRhQXQzYTJFTVIzbmJiMis4NHg4UCtjaExmdktQdDlnVTVkNVBPY1AzMDNkMk5KSng2K2hITDduWDdYVnlodTlOK2RTcmZ2V3NiNzNyWC85Tm5YKzd6ZlJXck8zSmJmdDUwN3ZmRjc4MzQyRVAvT0FMZi9qRUw3N3hqNC84NUN0LytjeHZ2dk9mRC8zb1MzLzYxSysrOWErUC9leHJmL3ZjNzc3M3Z3Lys4SXQvL09RdnYvblBqLzcwcTMvOTdHKy8rOThQLy9qTGYvNzByNy85NzQvLy9PdC8vL3p2di8vL0Q0QUJLSUFEU0lBRjZIRWZjRVB1ZGd1eVlQK0FEZWlBRHdoL3R5QU9lNkFGRktBQ21ITXBCQUltZ2ZBRmJ6QUNGNUFPRkFPQkkwaUNKYmg4anJBSDRiQWZwWkVMQmtBR2Z3QUJyR0NDTTBpRE5maDRackFCWDVDQkEySUVjcEFCRUNDQ05paUVRMGlFYVhZREk2QUNPeWdodWJBQ0ZOQUR2MWVFVVNpRlUxZ29rMEFCK25JdFJrQUlMM0FEVk9pRlh3aUd2UUVCT2pnNUt3QUhYUmlHYWFpR1U1Z09iNkNFT0VNSUc3Q0djMGlISmZnRGhQQTdCMkVBRkpBT2RlaUhmOGgvZGZFQkw0Q0ZlWWdRS2pBSi94QjBnTWlJalloK2d2Z0hiMmlJQnFFRUVQQVA1dVdJbWFpSjJWY1VOekVDaFRpSkRhRUNoWENKaTdpSnA0aUt5NGNlLzNBQm5oQ0tFMkVFRkRBQmw0aUpxV2ovaTdmb2VxdTRDaFJRT0s4WUVTc2doM1FCaGJoSWpNV1lkdWlCQ3Y4d0JxQTRJSkxSTmMvWUFXUERJRnZRaFdabmpOZUlqV2kzVHgrd0JKSVlHbDVUQkVwQUFUaHdCRU9BQVlPUUJQSFFiK3R3RCsxd0FPN2dBUmxBQmw3akk2cXhBaGZ3RCtRUmhObklqLzJZYkZZV0FCOGdBRitBR2tXd0RlSGdEandRTUZyeEFRZXdDS0JTajJReUF2bllPdjVva1JjNVhJb1NBSmhRQ0VwUUdsNFREa093a05NeENQVkFENkZDR2dhd0JCK2dUV2lHa1M4Sms5MzJOdXFCQ1pQZ2pSZVJLUm5RRGlPcEl4OFFBNG9Ra1o1aEJHK2dlS0lVazBlSmxHN2pKRWd4Q3BNZ0I2TFJBVHFRQWp3NWtpWVFEaWdwbEVSSmN4V1psRjNwbGIwUi8wNDBBQUtWMEFYZkNBUnRRSlZwaVFvbGdKVWNZUUIxRUFCblZvdGZTWmRmdVd4N01RQU80Qm1VOEFra2tKWi9tUlZKUUFGdHFSRUdBQWlvd0ZYTFU1ZUw2WlVyc2g2cndBcDFjSk1TVVFSYUFKaVhtUlVra0IxUTlRQ3NvRHhHeVppaCtaTEllRnpETUFhVEdSRWRNSldZaVpucnNBV0VlUkc1NEFBRU1IWVRNNHlpaVp1bmVCZEhnVU0zVUF0NnVSR1VvQU51d0pyRnFRZHM2Wll3UUFQaU1VaTNtWnZQQ1lpa21SUkxNUUVoZ0pvT0lad1lZSnpHcVFXd2FSRkFBQVh5eFRhZ0NaM2xlWW8yaEVQdVlRb084RlFXUVFrSHNKM2JlWlVJQXdPclFGNkthWjc1eVlqeHNpaXI4QVJIY2c3WDJSQTNFcC9iYVFKQUlJMFVrZjhMWVZBTUdyVTYrS21mRWJxR2lrUURRZ1V4azZRUkhiQUZBRk9neG5rRTNxbWdOc0F4RWZORXBpaWhKenFGc2lJdnQzSU01TUNlTnVJT0hicWQ2L0FGUVdrUkt3QURBMUFMTG1GWXpZbWlQK3FGL09tWk9WUUx4MkFGT3FBUmxBQUU5eUNqMjFrUElDb1JCbEFEdVFJaUQwcWVRSXFsTlVpaFVuTU0rQ0NnQzFFRTRkQ2syNWtDVUJvUkJnQUdERlptWEFVcldlcW1OTWlmMCtrb3ExSUdYNm9RUmJBSVkycWNiZUFGQ1NvUm8wSTBSc0tjRVBxbWhXcUFGR3FoeVdFTU9XQ25DUkVkZWxxY2JpQUhmaG9Sc2drSjF0WkVKV3FvbTlxQThiSllqREtubnJRRGpZb1FSVkFDa01xYVEwQ3BaM29DZC9Bd3lYTlB6c21wc3lyL2YxQ3pTTFl6TmFTUUJiMVlFUnE2S2FnS21COWFtQW9RR0o1MExyY3hJbk5KcTh0cWY3UHptUCs1UXdkbEJVQ1FwRjZBbHNENmx4bGdwaEJoQVBwd0NDbmhJZmEwTHJMS3JPWDZpRVp4WEtFcUdIZmdIRGFTcDloS2xXN0FEYXZLclNGZ0Myb2pxT09wck9iS3Irdm5xWExhRkM5Q0JLVFFBS1I2RUdaeHJmQzZrTWlwRVdnUkZXM0JKendhcS8xS3NmQlhGRkZ6SEZNRFhhK1FCVWlhb1JTQUNRb2JNTzZ3cmR3S0FMU0FLa3QwckNKeXBSWHJzdWRucThZaEFMbWlISEwxQ3BheUVaVXBzcHhDRnZUS3JYV1Nza1N6cHJlUXJPVDZza2RyZlRHckZETTdOWEpGQkpKZ3NLVXFIVHRiSFJpZ0F6NzdFR2g2UGFkekNFTTcvNjVJQzdia3A3UTN3TFExV3pVM0c3VUhZYXBVT3gwSE1LOXV1UU9oRTdSZG02bGZHN1ozKzMwWGU2dklZYll4Z2pYVXloRWQ4QTRtd0xaZkVRTWxlNlkxNEJxeW9iSitncXh0aXJlUnEzMmVXanN1VWkrR1FRVFd1Uzg0VXJoYU1RaXZDUm01OEE0RWRDcWR4RVJiWlp1U2k1dVlvQXNUWUFZbTRBZ3lnQWd5MEE1bUFBN2RrSXp6OTY5ODBSU3RZRTR5Z3FHUUVaVWlXYmlMZ0xnU0VRZ3ZneWNic2hJNytnVDZhclNxaTRyZ29BWUY4QWNVUUFhRGt6NW5tajVLNEFCTEFBZzlnQWo3S0g2S3hDalFhZ3BWa2dxNmt3bzQ2eGtkY0FiRUM2OGZZTHlpWVFBNUVDMVhoYThMY0ovN0tyMjJPQUI5QUFkazBEN3RPUm90R1A4SUZPQUJhcEM3Mytlc01rdXpVR0FsV2VJRDdmcU5IZUFCSEtxbmJnQzY5bXRFc1lFcTRPcTFrUHUvdHZnQmpLQUZTV2pBRDhJK0ZMQUhBOEI5dTh0SVR5RVl2eUlTcWZBbHBGRUVaM0FFR215Z2JHbWpVUFVSNHNLOEVmdThFMXZDcCtnSWdFQUdhY3VESy9BR0VEQUsxMGVoeUJXdDM2STdsRklEVGp5Z0haQUJRL0FNbDdrT1IvQ2FRZXdaQnJBRFo0TW4zQU91SDlLLy9wdkVhZmdFSTlBRlhDd2hUV2lKMUFjMUxETERseXN5cjlBQXpEZ2FYNk1DV3VBT2hKc2pINEFCUjVBQkJXUEdvZ0VFTmlBNnNZRlZLelFBTU9HamNmeUhQYkFGZHZ3bXViQ0ZNQXg5aUlxK1BDUlgyWk1LYStDUnpRaU9IU0FIS3ZBRld5RC95MXZ3QlNvZ0I2Mk10VkNsQURGU1BHd2NxUHhycGVTcnlXQ0lDWHVRaEw1NEVDdVFBWWp3ZkNzQ3NJK3lSVFpjUEQ3Z3ZzZzhFUVl3eEwxY3hNNkx5VVU3ekdyWUI4ZHN6UXF4QXZud0JNeUhxR1Fid2JrRE5FKzd5dVBzRUdoYUtvbFJ1bzFMb3VzaXpOOWNoSUpBQVo1c09YRzRmSTRKcXVUa1NLY2NRUGdpeVBCTUVMblFCZDZ5U1hyeXkvZlpzdm84aEh2Z2lnb2RwUlRnQ0lwb2ZOTEp1NCtpdnMyMU94SUFBQWtOendid3dROGR3cTg2cUJOTjBTWllGd0VBQnlhTjBRNmhBcFpvb3JuNHdCOWRWQ0pWSDZVQURRcEEwNkc0QWcxd1JKdkVQZmlxVlpnOHJ0SDcwdjFuYk9EZ2hqV3RFWVNBRDRybzFHNjNwWXpVLzlNaFpCOWVWQU5EWFRsR29BVFpqRVFyM2J3TzZrVEptczlQN1lDZFNBTlRUZFVjWWRXMG1OVnJ0OVhxQ2pJTkpTNnZFQUpLNE05anNnSmhrQVZIZmRiSHM2UDNISkJ3N05ZQjJJbVlBQWVCUGRjRTBRVnpZTmZBbDlkVFlzcFN3ZGNqd1F4V3NNVXJyQzBHb0FRTlFBUWpCVjZ2ZXNtSjZaS04zYWxMc2dkaVBka1dFWXRkMk5xckY1YU5WVTdzZkZlRzhBbzI4Q1dpSFNmTXdnQ2RvRW1ra3pZcUN5SmI5VVNNN2RxQjJDVC9JQWhra0MyVGdTMEdNSkhXMkhyaE5KMy9tU3Mwdk5lOWZSOVd3QUNBYlMwck1BTXdrRVRiVTdyZzhVbk1pYzkzL2R3VzJ5UlRUSWhqUWduZ3lBMWZFQTVhNEFGSGtBSWtNQVFIMEFZSE1QOEVKT0FPWEZBUEdiQUZYZERLYktJQzN2QVAybzNiZHlrM21pM0JQaDB1UHZBS2ExQURPaURicU1HRVFNQUFhRExKd2FLL0tGUTBhbzNFODAyQXlQZ1A2RURkRU9JMU9wQUJSNEFCUHJ5UTdEQUU5YkFGWHBQTG83RUNnSkNQRko1NnlJaXhjL1BkVzFSTTRqMFNIUDRBRFJBR2NyQUN2RW9hUnJBQ09xQUFJVkFOcjNEaTdDMGI3bDBNeTMwYlhTWGZMczUrU1A0UFB4RGllMWtFaWxBQ1E2RGp4amtJTWZBRi9OSWd1U0NMVHVMU2toZE9ubm5oalJSU1RhNDlLT0VEVWlEWkJtRUFBQ0RKWGs1QzdjMGhIdElTOThtVmFPN1l6dk1Qa1QwZ0lBbWY4TG9PWEFBRUJqTWdTa0NLYkgzbVJvZmt0MHB5eStWbG5YMG5xWUQvNkdUU0dnTEVTYWZUdkRLWG1IMXU2Zm1INUFFd0FSUWczTy9iQVl1Z2tKMUxBbmZlSHl0dzFXYXUwMHVwNmtRMTZOZ0RPYkNlNk1zeTYzZFU2OVhXUnl5RVRZUGszTHV1dThZVkFBT3BHbUc2azUzYkZVZEFENDhjR3NENEQ5NSs2cWh1WEkrNU1kTVRVdUh0NU5NUzZ5bDU3ZUVpTkdzUlhqQjNaQzBrTWZFTjdnRzRiQUdBQ0ROdUdsM0RCZWd1RmlZd21LZ3g1UCtBRzRSS2VSMm1GM0t6NmliWDZxNSt3L3MrR3F4aDJCZ2lORU1qWG4wU0lqbGw1QWV2ZjlMSkNqTE9OZlN3bWhBL0hmSEFzS1V4NUpnZ2wvRmVkRWplZEZiMEhoN1RaWGp6WmJCQjdiSmU4b2lCUncwVFh1WXk2V1ltRS9ybzh5NC9mdHhOQTNscC94cjVIYU0ybnlOSk1KODZyd0dqMFBPdnAvSE1WdStORkV3ZWozS1FsUFQ4dnZSckRFMEF6eUdBVlZNM0ZTZ3RiL1c4dnRNVDhBWld6aEdQNnZXZDBnWkF3TzZGT1FXK2Z2RzY3dWR2RTNJVWxrb2cxa3JWQTIzQU1qTWliNy85M3ZUVVZsSFVOT1lPMnUwdGFYTjdINGhDdWhjQmdBVFZQaEFkQUFURU9mZ0wrYVNsMFFWUXNCZGlpZkdyOTIxVTVIU3FORkFGMVdVZzgwWE1ZTUVqUCt0NVloS2MzMHUwZFdTNVJXRTBSL1drLzMrcC9sNnM0S1U2Ykptdno1TnRRQTlCL3FjS1FHZWYrZTJRRjNkQkh6MVl0Q3RWWXRCRU1QeVo3eG9hY2tJdjEwZld0RkZtMWx1aUgvN1FEMy9MeGlpSllBNEFRY2JMUUlJRkRSNUVlUCt3eUJFOURSMCtoQmhSNGtTS0ZTMWVqTGh1UzRlRUhUMGVOQUNJMVkwSk5FQUVHUFVCMHorV0xWMitoQmxUNWt5YU5XM2V0SW5wdzRkUnFBS0FZSFdMeG9RYk53WUlXRkRNRkNrb3RJaWs4bEhxRlJnREg2MWFOZkFJVnlrZnFZalFna0xLVkRGcEJBWTh1YkdxNUMxV0FRS2cycWtTNTF5NmRlM2V4WnRYNzE2K2ZmMytCUnhZOEdEQ2hXUHU5TWxxUXFJbkV4aFV2UnJaWUFjU0dDMWZ4cHo1WXJnaWtqMFBWRUtuYU1tMktWY2FSbzFhSjArZkFZSk9XR1VVYWJGV3RweENuUXI1cytlc1VMcCt0ZFdLcklBQmFVbWZSQVYzNStuVXpaMC9oeDVkK25UcTFhMzN4YVFURlZEWWFLM0kyUzJac21ieTVjMWJ6TkE1UE5iL09vbUtUMkNMVXU1MStqV3pJLzU1YS9HTjJZZHNQNldGcXZVa3k4b1dyMmdKcmhpemJrZ0V2clpRU1VrbDV1cWpzRUlMTDhRd1F3MDMvRWVuVVZ5akliYmlhdEJ0d0lTS2NPYzhGVmMwN3dNS09ES3hJem1zTUlxa1cwQlFia0lPcjF0dE8vMFlFMENhcGFBZzRpc0JZL3dvSzFLSWVDVXNVNlFSZ0VINGNGeHVSeXV2eERKTExiZWswRU1RaVJwZ0FDc0NRZkxFZWxoRU0wM0xUQUNDa2pKQjBvZS9BUnE4VVRrdXE5UHBTNk1XTU9VUUtGNGhBcGNqMzBSSVNlQ0VXM0JLdUhTOHMxRkhINFUwMGl4WHl3OU1BcDVBb2tSQ082RGdBelUvQlRXaUZOUWpsQ0FnZkJGQWdDZFdvYUcwK1NSVjdRTWZMUzNHVDBBRjFiVFUvNEVNUlJEUk9TZHdsVkZZaHlXMldHT1B4VXU3QUg0Y2dBQnBXbkVnRjEwSDZtQ0lVSys5TnIxcHZUQWdod0VXZUs5VitZUkZWaS90UU5EUEtBSnEvVFBRUWJmbDlwRWxlMVh3aVFhRExUZGZmZmZsMTFFdldRbVJQeWl6a0hiYUlqTEFOdUZQRDNCeldnUFFFRURCOTI1NTY5VitrNVVWWFZwdGRUZFhYUTFvNEpCWDZMMzAzbkV2UmpsbGxWZCtiaWZYMG0yMkdBRmc4QmpKSWlwVE9HY1dPWnMybHhudUtLWVdWVm5GbCtXNXpvVjUzVllPWWZxWWQrSFZ3WUV3QUFpaWdSeXltSWNBR3NnMXVtdXZ2d2JicFg5RGZFS0FXa3haZ01ScE8vZ2lIcDNmUG84TFVrc041SUZqSkNiSnBFWERwbWxDR3FEQUJ3WTBIRkRDQVAvRDRmVXNGeU5XV01FSU1paDRvUUExd09HN2Nzc3ZKelpQZ0dsdGhaUXdqREJZQzdoSEo4OE5lQTNZUVVpaDdSWFhOTXhaY3VTQ1A3YVFZd1VEQ2tZOGR5TU1VT0tORVVpSTRuWGhoeWVlUjU1QUJQTHNRNGg0QjNkQ2k0aUJkT2t2NDRFTUdFczFJSVJqRGlrRzNMeXA1RHBsWFJnWllZdkRjMGVmdDBBbzJLQ0pEd2dyeEhiRDU2ZS9mdnZ2eHo5Ly9mZm52My8vL3dkZ0FBVTRRQUlXMElBSE5Kd1JGS2dFRlpEaEMyRjRneFpHc0lFK01NSUpaaGhGOGZxQ0dCQU1SVjIxSWtVcGdPQzhOeTFrZWllMHlBYzI0ckFHR0VNc3F5UGF5VmFHaUEyWWo0VHB3K0Y2akJDSU54VEFESHpKemo4S0Fib2NGdEdJUjBSaUVwWC9pSkJjNU1Kd2N2akNHMTdRQjNGMFE0TTVPUjdBWWhPa3BkaENBaU0wV0lwUU9FYUp2SWlGcG9DQ3Iyd0V2b3VsQXhCZk1BQVJsemhIQWhtQUFnV2czRTN1RTVjTXprT09kQVJrSUFVNVNFSWlaSGRkZUlNSEdIR0xLN1pFV1VtampTMmdJSUVaM05CbURDRmpKaHNTanhWK0RBYlRjTklDb2tRYStlVHJBeEI0UStNS3Vjb2tLUUVPbFpESkhqL2tGbGI4WXh4L1pHVXVkYmxMWHBiSmlTckl4d1dDTnp3T2V2QmJmV3BLS3FKbHNETnBNcE1tNkVMRHNCZUNROURpaGFveW1ldUlOWW9MVUdBRnZRVG5RWExoaVF5b29TVTc2Y2xQTmpjQkVGZ0JsK0dFWnp6bENjN2RiV0VEanJoY0ZqM0lSYWE4NGc0S2VLZk53dUhNLzB3TzRYcllPd2Nwd01LOVJGRnNiNUthUXlybk9kR0JHSUVRZjBERVB6N0FpczBWWlFBVGVFQkFLVHBTa3BiVWlFYVF3eHNnOEQ2di9Xc3haVHZiZjBpUmgyL3FpaEpLd0FCQngxaVB1UkhxREZaNFJaTU9nYmFKbmNSaVhLSUJJTHBRTTVPRzB3QmYrRUdyeXVhc0FXUkJwRTNGYWxhMWlxUVZ2R0VPUmxPV1lqNVlHNmZZSWdSTU5WRVJ1S0RURTY3akN3ZDlreEhDVUtRbWlVVWE0WExWbmRLUmo1cnFraEovQld4Z0JUdFl3djYxbHp0RVFpc0dJSncxWEhXcmo0VnNaRDFpZ0M1c0lBQXBlK1RHbXNJa0czUmhXMnh6RzF0SmQ0U2V2bWtGREREUVYrd2FwUmltUkV1Q2VBTmFrVmhZMnRiV3RyY3Q1T0tDUUFTclN2L1d0NzhGTGtJSUFZakw4Z3RwWU9JVHgzeEFCQVhJZGozUUUrM28yR0c5YlJuaEhLODQwRFZYMVRxVzdzZ1JTK2dySFc4N1h2S1dkN0NEVkZ4dzFidGUzK2FDREQzWVY1NDB0aWRrQXNvSHVLRFp0aWhoQkRkRTkyMkxLRzJaNU9xRDMxalRGRERrTG9jQ01BTG40dEM4RDRid2c5azdZUXBYT0hjcmVFRUd3K2V2ak1Fc3VlMGlzQldhOTlrdG9NSy9Dbk5IZ010a0FCaThvaFRaUGZEUUVweWhIcERCc1RtTXNHQXpzV01lOTlqSFAvWnhqZ05yWVNJWDJjaWZlUmdqZ3ppc3pINVF1Uko0eFNQQ1c2cURuUmhiUXpCc3p4d0FqYWpBV0docG1YRjlWa0lET0V4WmlUa0djcHJWdk9ZZUMvbkliNFp6bkEwQWgvY2RsY1AvUG9Ha241emlBd21VNGdvajNsWVJTbUJsVUxWQkVkTDhXQWhlSVlIZk9BbEtlY3NyZlZhaWhpL2MyTUVQWmpPUU83QnBUbmVhMDVrT01vVGpQR3BTVDNnRkc5Q29uYmtVMXNYRWpLeEVpQXFVejRxNEtoTWFUVmhHOUxUT3dJQUgyQUpRb1F5WFViczduZFBzd1JPQWhEQ29PODBKWmpmYjJjK0dkcWRCTGVwU1Y5dmFqMVVCTEt2RTRROXBrVDluVStoVFNpRUJDUkFCQUExZVR3ZTJ3QTVicTRpMFJWd0JFQnBBQjZRMHRHSWJMa3lkWDJCbUl5Wjd6WnlHZHNBRlB2Qm5mM3JOMUw1MndoVXV6em4vSTBMNDNwQStpWUtVSVQyRnorUitBQkJ5UjRsdDRLemRtdEZXRWxmd2poQVFZQlMzY0tpcURhT1RmNEFnSCtpMi8ybUUvOTBCZ25NQ0ZqZkhlYzUxdnZPYkUzelRiSGJ6d29VKzlFSjJBWlk1dXROeG5ielpXQnVDR1dXQStYTUgvZkhMRElFZXVVNWlMbGF3aFRHQWdDVVE5d3ZMV2ZIeWpRdFp4MnJldE1CekxncTJWOER0YjRkNzNPVmVBYmFMUXVjQy8vbkJ6UzVZb3ZmZDd4Y0d4RC9rby9JTmpTMTVTOW56dUExaGlGYzBJT3Job1VRSHhFaDFpcXlEWjRYVXVrcFRjNTkvb0lMc2I5bzdZZG1jOW9DdnZlMXpSMzNxVVYvM25BYzg3M29QUGQvL1BudmFmOFlJYjNETDRNRk9JWWtiUlVqOWhBcTVGLzhLZlR3K1BCMEF3Z0VvTHhFY3FKaVFXcy9BVndXams1WHN1MHl4RDJ5bUFRN3R0YXNlN2h3QWYvakZQMzRPZUIvdWRzZTU2LzlmcjJic0Q3bjI3NGYvUWI0d2dBOGhIVXVaZFkvUy90UDA0UWZCK01jSEFtdFp2ZzhBc0hteXFIeUFKU0RpaVgvWUEzN3pqUFpUTnBwVHU1c1RCZThqUHc2SWhRelV3QTNrUUEyOHdQSkxQYlpMUDd6ckFGRGJNZXlMdnhTc3ZTNGdoMUVvR2lzWm15MzZQU0lKUGdsWVBNYnp2eHpxZ0cxWXEzWnJCd3B3UG5qaUhZeTZDdy81QnpWUUFSUFpPeFBNaE8zalBweXJRTlViUHc1VWhTcTB3aXZFUWl6c3dQRlRQUkVjUWZWandrd3dPeFVrdzc1VGdrSkFoUWZadGgwNXJ2eUxwTnRRdkJ0OEJRWndRSGdwQWdwb0EvLzZnQmo0QkxocUtzb2FnUUhRbzUzNEJ4cDRBMHRMQ0RRelFTZDhRZ3FNUXRRVHZ3M013aXhjaGtyL3RNUkxYSVpKMUVJUERMOHVSTCtlR3ppRHk3UWNLOE5TVExndWdBSjBPUWx0MnBIZTR5Y2lnVFhoazhQODZyY2lDQWZsMDZSNGlBRWRDTUtzTWdBeTJJQThlb2tlK1ljTitEOHY4RGZ0STczU2c4SkhoTVR3azBSS3RNUUlvTVpxdE1acnhFWkwxTVFORkQvdjgwSlFKTUVTSEVVSk04VnlITFV2cUFXaFdFWENxNUJ6VVl6OEF6YzRsTVhGUzRVMVVJSWtvb1FpT0FNUEdJVHBHUUxPNkVYSmVxbzlvQUdXUUl4L0lJQXZHSkR5VWtZSm5FQkh0TUJJek1CSnJFUnN4RVlSd01pTTFFZ1JzTWhyck1SSjVNWk85TVpQaEFXZld6OGdLeTl6Vk1rak13SUZtQUJTc3IrSTZ6RE8yYjg0dkVFSjZJUXdPTVl5NllBaTBJRVMveUNCMEFvVkRJaUJMU2lDZ0dTdnJmdUJXZ0tFT3JRSzhwbzVoMnpFdWpNL2lZd0ZpcXhJaTh4SUJIQ0JydlRLcndSTHIyd0JqZXpJQ01oRWtNeEFMaHpKVHd6Rmsyd3o4bHJKdUt3d2tBRUJrNG5KRElsQmdSa1MrNXBIT1d3QXB5eWludXdBTWlnQkxqZ0FIdEFNVk1DQUZLZ0hDcUNIbzhTNlV0dEpxRXl6Wlh5MlpxeEtxN3hLYWRUS2pSUUJCR2lCQzlDTVFXQUNQUEJNakxUSWo4ekNrQlJKVDJ5OWFIUExFeHd2dWFUTjlUS0FCNkFCdTF4RHZKUVYxM2dwczZtNEdyekJHL1NCQjNnSFJEeWluanpLSXVBSUhWQ0NMZ0NDTGxBQ09WRE9vK3lBeUZUSjhhcE1xV3cyekpSQ3pjVEt6dHhJQkNCUDhyU0FIaWlQZGY5SWd4WW9UL0wwekk1VXpVM2t4TmFjTzlZRHgyYUxUVEhFclNWU29QNzB6LzhFMEFBVjBBRWwwQUkxMEFORlVDT3dwTnJjSmJsQ0M5MGNOZ3k1ajFuNUlNU3p1TDZjeFoxazBFSzZyZTJjeXUrRVJnM1V4S3k4eVBGc1QvTEVBeGNvZ1BOSWd2WEVneE4xejQyRXo3TmN6ZmtFUDljc3lXaExzLzA4SWdPb2dVVWp0eUFWMGlFbDBpSTEwaU5GMGlSVjBpVlYwbGZJQVExRm56TjRoeG1nMGlxMTBpdkYwaXpWMGkydFVpQTRnek9ZVHZ0WlVKTmFBUTJZQUhzQkZ2RFp2ZWx3bWRlbzBIQVR6dUZjUEVZREFNRGNVRjZ5cmNyODBHY00wYzNrVFBIY1NoakZnMEVkMUdCNGdSVXhnWDZ3QUVJZFZCaEZnUGRNemZpOFF0Yi9CTUg2L0VMOFJNbmFTaUlmSlFJNTlkUlBCZFZRRmRWUkpkVlNOVlZRWllaWll5VURZQUJjWU5KWGhWVWk1UXF2Q0Nyc3VnSWIySUVHR0J3NU9CK1NraXR3UVZNMWpOQUxHUnVhdkkyTEE5VlVlQUFIZ05JN1BUUGEwalR1aE1pNXMwcXNYSWFPOUV4SFpWUkdUUUFBUUpNbTJJUVcyRlpDZGRUVG5GRzBURXY2ZkRzdkxEaHhmRXZhUWlKT1BkVjVwZGQ2dGRkNlRkVm1QUjE5ZUlWNzlkZC9OUVJHd3k0YmFJQVQ2RldHdzRleUFiTVg1TTF1TTZaMXNkQTQ5ZFJxWUlZc2VBZDlkVlljZzlZZmsxWlljTWJ2QXo4Ui9kTnJQRTF0SFZjOGFJR1ViWUVFcUlKMVNKTWVTQUNWVGRtVGZWRVlOZGRJcmRGWVVOZDF2VTlPLzNCWEhyT3RIcTJCVGdYWW9qWGFveDNPZk0wbEErQlhwSFhhVXkwM0h3aUJpMlc0SVBnV3ZKSWhEU25XTnoxV0RKVlRackFCWmlXNmc1V3NQUFd4anYzWUNxaldLeVJSYXl4WlFUMVptVlZaQzBnR0ovaVVQV0FEQzdBQXVSWFhreTFYU1BWSUdyWENkTDNSdUVPL2dzdFV3aEphb24zYXhuWGNVVlhhVlczYXg2VmNVQzBGSW5nRWpNVWhuNEdDc2lpcUFDQkVEdm1YcEFFM0VMUEpUNjJHVkxBQ0JiRFRJak9BTThnQlhIaUZCMkFBSU5EY1ZkcllIck5NQ3BTN1BzWENheTFSalRUWmNlWGJGdERiNHcyR1BnZ1ZKTWpiNDkxYnZxVlpSMzFVR1EzY1Rkelp3OFhQbjlYUHdqSWllYTNjNzZYY3lGMGxwdTFYOERWZk9mOHN2bkNTQXh0WWdOWFJ6VFVsTnBmUkdDQVJFdi9vV2hzVTFYSnJBRGtZVXd0YkFUQjRBTVpkUEttd2dTQW9uSzNLM1IzYlhZK051eEQ5WFl0RUFKUjFnWnB0VDVwRldibDEzZ3htQXlUQUZqQm8zZ3crWHVpTlhoUjFBUXRnQWpRNGdiSE1SdXN0WEo3TlVVeDkxL01xSXU4OTN4b3VXdkV0SlBLMTRmTmxobk1BajE3cUZqN3hIbEppUmEzRmozZmtqNlI0TmFnNDNWQjlCUnNBZzliOUxjcUNBU0xBMzFEMWdWZFlBd0FJaE50OVZ0SFRYV2ZEdWQ0TldUOVZCZUN0Um94MGdUVElxWVpJZ2g2b2cwdm95cjY5WUF3RzRlTk5nRHhtQXhaSW1GdW9nbURJNHdTNDR4QVc0UllvNFRUWUFCbUFpQ2dBQXhkQVRXc1VYTUwvbFR1N2M3YVQ1TjRaSHRvZDF1Ujd4V0ZDMHVGTi90NVVPQWZrbkNPUVdRQmZvUk0yWXNNamZ0alN0UzlrSlZVb0t3T3FuVEFEa0FNRzZJUlVxRmV2T0FlQTh1SWlLaXlPN1U0R2JtQU1OR00wam9DTWRJRVRhQWVMYUlJWFlJSmdDSVpCeHVOQUR1Umc4QU5IVUJnM0FBVkF0dVk4cG1ZTGtHWW1HSUgrc2doMlVBQkhmbVJxakdTZHJWU2VyZVJRVTl3Y291R0FQZEpTd09kODF1ZDk1dWQrOXVkL0J1aUEvbWNrVFZwVkhkL0ovZFJZVmVnalJkckcrK1dQMFlkakVBdFJnclNzTGJ6UkpZcXlrWVphK1E5WUc3Y3JIdFhMTFFNSGtHS1NNZ0FkWUFDS05WcG1TSVV5b0lxSFJweGdEdVB1VE5zeVp0czBWdU13TUFITi8zaG1NV0FEYi81bVBSWUNmc2dEUnZDVW5NRUVOV0FBTEJBQ05nanFQQTRHTnRBRU5DQ0JvOGFNZFVBRGRlYklhcVJSU1Q2L0YvWlplWlk5SEpKWEllVUtBdXNLcnlpU3RXYnJ0bmJydDRicnVKYnJ1YWJycDRBS3RQNW80U01DZzg1aGhEYnJmRWJyd0Jic3dTYnN3amJzZlM1U3FLMEdRRnZhUERBR1d4Z0xzOGdtZHJTUUh0R1RaaW5kWS8xb3FIMkZMRUFEWHRVcXJYT0FFRWdGWFhaY1dBc0JuU1RsTHo0N0hwTktZbjQ3YUx4cG5IWUJNSWlDRlVscWZlQ0hwaFlDUDZnQkNEQ3hNZm9BTmRDSFNCQ0NwcTZDRFRBREZrR0ZKVkJuU0o1VWRiMVA3YjNrOVBGUklEM3J0UjRac0lDQzd2YnU3d2J2OEJidjhTYnY4djgyNy9QdWJscFFiMEN4dUk5K0JiNzJaQVlBMGo1RDY3YXUxZnZHNy96VzcvM09iN20rNjZqSWE1RDIxRmVnZ3BMZVZIMUFvNGtPTmdnWjFvdVdPQ0JSWW9VQ2xCb1VjRkl0YlpjbVczaHlvaGw0QktDcWNNcnRWeGdnNmRVRzVzRVNabWE3dVdMR3dObW1SaEZ3QVFWQXpPV0xyZytBQTBlRzdzRjE1NjkrNGZXcmJ2UzU3dXorQ2lpd0JWSVlLbE1ZaTJKQThpUlg4aVZuOGlaMzhpZUg4aWgvY2lNMzhxVmhDbHFZOEtod1VwaEdFbFpkTkNBZm1lNGVjbElnY3FZeDh6Tkg4elJYOHpRbjh6WW5jMXVRSk85ZTc3WCs3N3oyMUZUWUFSTHZVUVpvQlFORE1JYUZRVllHRXk2cURSQzd1QThuVlpaR2dTQTRBOXZoSlZ2L0JvTVFxQVlYQStVNWZRVXJhSUFaV0lIKzdUY3dkdTFoZGthYnRrSTBkbkVBU0FJWnQ3VVhlTlFiVjRWMDFYRVlCdHA1OXZFYW9JVUNjNUtnV1FBQ0lJNHc0ZlZlOS9WZkIvWmdGL1poSi9aaVB3b0NjQmFsdVBJaXllSW5YZHBXNVlvaUFRc2lQL0pha0laY1IvWnMxL1p0NS9adTMvWUZBUGNGa0laeHI0VmFTSElxdDNKSlV1KzFKckROdnNGU3lBSWQyQ1VXcTZZRXNiZUgwaEl2QVlxQWFaYjY3V2lKdFZjb2t3QkowSWVMM1hRNk1wd3pBSUFRQUNyVHJuUlFoVExhdFYzeE12R1p0am5ZZGp0UlZ3VzNkUUVQUVBWMkk4MVZaK2ZvZm1lNkEydnFsblhFOGRFN29GVW5xUVZkTHc3amVNbVpwL21hdC9tYngvbWMvOWY1bmQvNVZVaUVHM2lDby9EMzI4QUZaMTlWMUZvdTFSS09zdGoxb25ENnA0ZjZxSmY2cVovNm9PZjFWQ0dBOWxXS1BsbjI5cFpGQ2JBQmpkTWxBeWdEVWhBcW9sb2pPMWsxUVJjUkFsQWVTY3J5SUMxYUNVaUZWK2lFTldnQUFKaUIzWW1qbnBtZk13QURCaWdES3lnU1JLOVhKVDFhQXRhSE0rRHlSSlJwQlJiamp3M1pLM1RiejJ3RWMvNzRFNnZ4ak9ScWtqZmNrNC9oc1Q2ZEdvQUNHTU9iQnFFQnRnQ0IxV2Y5MW5mOTE0ZjkySmY5MmFkOTJlZW9vUkNSVi93MW94OWYxRHFRQkJHbDRsQ0xra2g5bERQKzQwZis1RmQrNUtlQjVuZitvYUI1bnkrS29CZUFaRGVGenRrc0ppWTNIN0NCTTlpbExyQ0JYMXV0aXY5MnJVYXg3TmZJL2JQQmZzMldlNlNsKzZBcVRoUUlnVWNJQWdVNGdYY0FBaDBBSGI2Zkg0REk1VVhPbVJudnBLQmhBR09IRFdoRVhxVXFaV2dpeFlvV0wySTBKR0ZqS1I4ZWZhUUttZXBqcVkwYk02SkVXZXBWbGhvNkRIaUpLWE1telpvMmIzcWhwSE9uemt3K2ZYYmdKQlNXcUFwR2pYTGdFRXNWVTFYTElrQVZJUlZCaTFDajlHRE5xblVyMTY1ZXY0SU5LM1lzMmJKYkM3aEFnRUNxQ0tnUmxqVlZGU3ZwVWFPaVlBbmwxT0duVDU0OGNRSU9UTk5BRFNnUG9Sd3l0V0RBalZVVGJvRUlnR3JVaDhxV0wyUE9ySGt6NTg2ZU40OUNGWUFWalFrM0JoQW8xc29XTFNLMmNzQVVMSHMyYlM4R0dOZzZUTXFVTkFGUGJrei9vTUVxc21SVXhvOGpUNjU4dWZJQXpwODdCd0dDRmF0YnBTZXN1dkVFdFRSVHJVaEJlVVhFUjBsbTUycWpUMi9UU0JpUVJHanRyaVdnc2ZBQWxQL2h6NjkvUC8vKy92OERHT0IrbUh3UTJtaWxaVGVBQUFzVVl3cDRyWTFIM2trcFVWaGhSUnlCRkJJekc0b2tvWVVmVW1oU1I2a1FVZUlydEtDSW9uZ2xSaWpoaENDaVJDSUtBTWdSbTNxQStjVVRYNWtFTlJRc2RWV1FWQ3hMTWZWVVZGT3A1VUlOWmpIWnBKTlBRamxXRTV2Z29kWmFVcmtGRjFORDBsVVhMSGdKdFJkZk9lNTBvMnlFR1VZTEZLMFVRd0JqajRHQVNtV1lDRmlublhmaXFWOWxvckV5UVNKUENGQ0xnNjI5WnFPWmh3SjJXMjVxSHRMbW0vWEorUUVtLzVOU1dxbWxsMkpxNldlaGlSYkFkS1VsY2hvQmdvSW5Ibm0yUExJQ29xc0N0Z0lWdHBBSW55bnlQWkZJZlpUUm1hZXV1K1pKNEFkODNvTGRhUUtrNXQyREpYcFUwb3N3TXR1c3N4V0s2SU9KYXRwQ0NpbXR0T0pkSzRkWWF3c1V0S3c0VWluS1N2RHNSU1R1b0lBUnJNWkVaazk4OVRoVVVVY0pTYVJUYnJGbEpSNTRCUE5DbFA4Q0hMREFXTEhEaEFYN1dzbFdsazF4eVVGZGQ0R3AxNDd1VXNKdVRXaStad3ViYmlieW1HU1M4aHF5eUFJU09NcUIyUVU2cUd1d1dkeXliUXlRa3ZIR0EzVE15c2U1aml6eXBKYnhDU3FnM1pWYW9oVkF1T3l5RVNpOElpMHR0c3pxMnlxM2dweXoxRG43YWpJSTF2a3BLb09tY0JzZXN2OHVsbXV1MkdPSGlLRjdKMEpCU21MRjFMSUFBVysvdllBMHhUVDRuYmNRamdRMjJScFpNUU83Rk84WUx5ZEUxVlZ2VTBaR2tLOWErKzRiekI0RFF4NjU1RjJCa1FEalZhcWxNRlJheWpXWHcwZmRsWmZFWTFKY05NWkx6OXp4TFRkUDNick9CWjU4UThxa0VNcHkwYXplRmpQcWJkWTZnYzF5NHV3NnJ5VjdHbXdpQ3BJS0xoUUtHSHI3b1FhQWtYZkdUZGNLZGZEQ1kxOW4xYzVWSit4MkJNek45ZDBsNWszdTN1YzdhNUlFSFVuN2tKclhtbExNQWdJTXdOZ045K08vbllJTDFGSTNLZU4valZ4aGE5WXJHTkE4OVZEc1hVQVJIZUVLcDVURDRRdEpDTGhjQzFvUWpBdE1Mb01hL0JjRGdsSEJ5MlVPU3d2YlVsSStaNWYvaUkzdUp3bXNtTVZPcHpGSHFZNTEyWnRoZ0loSEdwUWxiMlVIZEY1NmNpY3ozdFZNaGpUVTFaNnVaaHJVRk9NUWh5QkNHTmJGdzFVWklBZXY2TWg3NHVNYlc5a01WMFBjNG4rcUJpd0VuWVk3RGVvYXVNaEhIdk9oTDQwWEVSSDdTUFFlS0ZRclcyMmozMjhjRTV4YjRKRUdlcHlBYWNLNG9QNXg3VUY0UzVaSllGU0tCNXdCVVN1a1JPRHkwa0I2UGJBcGJrbWNDS3cwd1gxVnNBVVdTQUFqTnVqSlQ0cGxBMnl3UUNZWlowa1JRaVV1bmdOUzZNSTBzUlcyc0RBLzVKakhnTWZGVytMSGhqVEFvY29LOWNUbndXeVd2ZnRkMUhDcFBkajE2WGdFT01ZQVFyRERYNkxIQUFwSXhmcGlaY1VuUEMyTEh6QW1OL1BqeGRGZy95MUJxTm1hM2I0VkxwS29UNDNtVXQvNlBPTEdONll0VzhXUUJnSG9kNE9PQlljNnprRk9kS3B6blZBcGlBRDhNMFVndnpWSXZWR29nTStjelNJYjZTTWdDU2t1aUZQY0pmR1FTUXRzVWhOTkFDVkhPNnFISG93U282VkVXQWpic2psVmR1a29YOHBMQjhTa3dnU3l5NFdwcTJVeHU1azlYZktTZGpxRTVvMTh1RHNDREZPSU52VVBUdmtJQTFYeEZGRnlXQU0xM1pNMjNzd25uL2JaNWxDNytjMVBDV3RZNFBQZjNTQkVoTHlka1owRFZLZEcyRG11ajd3VGJYR00zeHdIOEp1TzBlQVdOcE1NWmVia3E4b1lhRHJoQk9qK0JGWFFNbjZWa011aWlBVDZkcWlHd3N1Ump3eVNVdXcxVVFreTdxSVl0VUF3K09FSWoySTJnLzhIU0VBQ0prdktENUwwU2laOUM4TldDYnFWdXZLVnBZT2lMSDlLTTVwZXI2cFR3Nm5zY3VqTHBFWXptRDhOcWkxbDJ4OENUZVlmdDlBQUdSYUsyOW1zNEJHdjBJaTBYdkhVeFFDSEJuR3FqRyt0ZWxYUzhERlUyeUZXK0FMWjFSV1prU1FDRk90Z3kwcGVObjRrUXl3NkViWFVKcysyMnM4eGNaM3JaT3o2MjZybDFaOVpEV2gzeVhoT2hCcUNDREF3Ym1CV3VDTWVLWFplU0drc0JJOVV5Y1Zoc29LZTVXd3dzR0NHekdKWVlPMklSREE0NjltUllrNjBJeVNoQ1NzQU1aWWVlSkdJa2lrTVlWdGQxOUYyZHJVajhIRUhvOXNYQWpXSXZYMnhmZ1N3Qndxc1FDQTFmaDRBVXFFUktqcTNVVzRDRG1RQ1VGTWUzM0puQmVyL0ZIWCtxWjJBYnBXZzI3SVdGQXdLV0JaOUZhenBIVE9aM2ZuTzliSzN5OVU2UkxiWTZqYjZ4ZmVPdzNGT1haOE1JQ2tieUZQNnpZNVd1L3MvY3diUUpLbGczbzBNN05EQkxkWndSWXJnZ3lzcVdZeHlsck5DMEVlR0t4MmxFUWdoMHAyZExJZ1Roa3JPeVNXbEprWnRDbDhLVXpPeG1KYXIyekdVWDJleUc5YTJsN1lic21COGltUGUycG1idDNEQ0JVWkFnUzRZd0ltMFJoUjdPbEd1ZGs2dkdQVFRjYTVidlVVcFQxblBwTEd5L29nbE43b1IxRmpkNnJLWFZmU0tiNFBYUk9CbUw0cTRuVFpyc1ptZ2RHdmIyK2g0UHp2T2x6aDFucFRPdmprYTdIcVB2Lzc3bGhsTFFZUXM2S0RRQ1R5dzRCWWJwQ0UxbUpLTnBxQW0veWZNV1Rhd3dOSmJXWWNNR0hHQkgreWhBSDJBZ0JPU0lIR3QxQ0RUa2Y1d0MwQlkwaEUzN0dHa2RxbXAzWFVvSTRBaEJESVBRUTdLVUFZTm5PTWNZeGdEUG5xT2p3c0FQZWhDSHpyUmkyNzBveVA5QWlib0ZUSjNHV3VkM25iWWdaa0JBQlNnQUFCZ0hldG8yUHJXYStEMUpZQTk3R0lmTzluTER2YXR2K0VORktEQUZzalFCU01ZSU81Q2xyclJISENGWTFlemlsQ2xqelpqNjJ4dTNqWFBldDFqMXU1WFB5ekxyWDhOeWphMnRzVXRhMEUrOGtwa2M1dlZ6VFpwdUsyZWNQN05QZmtvWituUTFUTDBGaDZlTzRYVnJIMHZmSWRnalhoU1lZc0cwTmdtaGs2c0l4WE1XSVF2MnNINmltekRKeHRwTm9pQkhaVTJ3UVpDRWY4TUlRZ2hHQjNXTklXUG4vd3FqRUFHbGNaRUtOZ3djcEtYUExTYUkrMldUSHZDaUxWVXRTNm5PL2xYQUFHbXY5cnBNdDRwK2R2di92WWI0UVRRQ0J1eWsrd29KaytYcW4rdkxyU2pMVzNyWEFkMmhNcjk2RS85Q0FDeHdJMUFMY0FDTWlBREpxRG1IVjc5NEU5amVKNGVDY2VjN2RPOCtkMU5XVWFlN1psV05jaXgwQUlBeEY1TkROeWhEWTd0M1Y3Q1VkTHVSVmp2YlJLRnhZRWJaTllvN0VFa0pCL3o2ZUFPUnRyeHhjRUlyRU5tUlFFV0xOK21pUlJvYWQrbmxaYW9uVmhxa2M3NHZkK1FyVUFQL0lOOTFWRFQ1ZFNNUmVFV2NpRTBHVUNSWFloN3lBcXRCSkVXN2QvZlFkc281Sm0wK1JQaDhkRXFyRUlpRE9BRTBpSC9IY3BoSXRoUkJjYVZYQTBIY1JoSG5VbktCaHBUNEgxUmdnZ0EwSFFaTkJCTmVwd2c3Y2tMUk9IZXZlaWVDejVhREQ0Y0JHQldEL0NEeVBGZ0ozb2lHNEJDQVdDV0U0QkNFWHJXWjVtY2lKMVU5NVhZcUlGZmlxMVdGL0xVQ2x6QVA5QlZYWTBlZjhTWWJjMmFMUHJpTDk3SUNqVEFjaEVXa2lHR1lqeUt6VFRiR2JaYXBYU2dHbmFLcDB3SGRWQWpIZ0dnQldLakh1RVJOVklqY2V6VFpBQmlwVENqci9UTUVSWExicUNBc05WR0l5NlFZa0VVZzBuaUpESWNEQjVmTUlRQ0lMU0RSMjFBRHU3Z0tmcWpQL0xnOFNHQlI2MUREOVJBSkxDQjlYRWFFb2JZOW5HTzk1MlE2TEJjWDBBaE1EclBDa3pCQndpSHZGbWhmdXlpLzZ5Vm9FV0twQzhhQVJEWWdBOVlSTjZONGJMNWpsQXg0MHNPU1AvaEZUUW1CM1JBaDNLb0lTQ0tYaTdDNUlEOHlzbjhqSU1ZdzRBaGtMdWc0SmZZbnFLcHdpUkprS05WVUFLd2dUMXVnQWxnR0FRb253NytZMVpxcFNYMklCdjhRSWE1QVNDRUFsUW1BRU42MmlROXBLaU5ta1RDSXBtTTVPMFlBRDZ3QWdYR1ZXVGdvayttWHhheTMxdnk1VWdtRnpGZWlERXFXVEk2MlRMMjVHSEdaS1lvSnFVZ0p2b0I1ZXdjUXcyRXBFd0F6bEVtSlR6R0kwVmhFbWVsd1Fia282VUJBQ2RlMzFhU0prQXlueEN3QUNwSVhCUVVBQmljUWpBY2pLZU4xa05DWkJQcXhVVEdZbC9pemcvSWpsdEYxKytZWVM1aDRkTnBvVzRhWnhkS1UvOG5TRVJLU2tCelBWVnZZSlAxTk9aMFVxZHMyWkNmSUpIZHFBc2pHcVVqcHVBN09oYWpxVVVMdU1BbHZJQVRmQnhXckVNVldKK21iV1Vtd1dkOFNsaFdNbCtGVVdWNjZrRVM5QUVZa0tjcWNsL250S0p0VG1RbVZPUnhvcG9HRUFCdkxGazJmVXd4ZlNUVTlhS0JTaWl0R1VBWVdBRktycEZLN3NiOXVWaDFldWlIY2xFUmxjWnBNQWkzcE1JN3pCMXRkS2NqSXFVRFJlSkVJWUFMbkVBZnhBTitaZ1VxVkIvelphVjg4aWlQL21OOVlrRVUyS2hXdU1FU1hNa0lwWnlYZ0I5dXV1V0VvbG9aR01PR1FwZFVCZWVERnFlVFl1a3NBZ0EwWUdpR1VwRnI0ZDlVQ1NLSWttbVo3c3B3SHFLRGtNSVZKQkozNXNoUi9vaUxzaUQvQWpCQkVBNXBWdWlEYUJvaDl2Vm9uMWFpNzJtYUVJREJuV3JGQ2VEQmJES01XcmFTRTFKa2syWnBiVVRSSWNnS2gwSkdwSGdUbXZMaVpEN3FwczZHQVNnQkRCREJXREhubDY2Si9CQm1jSnBwcXFvcW5seW5NcWxHdGRoQXdMbXBYMWltaTRablZOQ3BuZDZwT0JTaGgvbGpqMTVPc0ZxVWZQNW9vUFlBb1dLRm9TSXFLNWFZZ0lxZlgzQXFiVVFSS1RqWGJrZ0RZVG9vcG9Ka3RITHJvZEJERUZ3Qk01Uk5LY1NLTFF6bWI0cnBxcXJydWw0aEtoaVJxQ1JSMnVDREhCUWxyY0pMd1YzbWkrSkxyaUlyQStqcHI4cW5zQXFzajU3aWFRSUFzdXFCc2s3U0VqWXJxWlVhZ1RwcXQrSkVGQzJLdGM0SGcxS1hjT1lsY2U2bC84UjY3R3ljZ1Q3WXdDdUlLbUUxWjdteXlaUkNpbUd5YTh1bUt1eUF3SWdPd0FJNFNOcXNnVG95RkprRVRyeTBLQ1RwYTFUZ1FaMGlhNDY2SjUrQ21NQUdLOEU2SElXSndTMGdxN0l1YTZnMTY2SStiSUYrN0V4UXJON0pCOStsNno5WWFjZGViZGkyeWd6QUFFaVlMQlVSd1ZOeHFIUzZiTnUyTEJZQ1N2S1F3amxvYWs3bzdMMjZvNjNtSGlVRnJhN2E2Q2l3cDQ0YWJmWWg3Y0RHcDJsU0dEOWNHS0ZDTGNvcEtnb3hhWTZJN2NYa1FNVTJEZGVhNGRkRzNlUnk3azE0S2hKSVFLZ2FZM3dzR1pXeXJOdWlMblcyNmhPTWlpbXdoaTJrNDZ6cUNONCtsTjVtcGdqMDdkQzI1MmdlWVh3V3JyQXFMYUF5cmRNeTdxRkdiZjl0VW0za1Ftdm54a1RXcmlUbVJvM21SaWp6VXE5TWVDb00yTUlkN0E1MHFvNWRubTdxZ3U5aEF0ZG9tT09ycWtrVzBLdnNLaEJROEd5aVlTYU1DaTJoK3F2Z0RpN2gvdTZ3d21leFN0ckJQdTJoTGl5enFoemtQbXVaVUsveldoSDA1b3IwMW0zMWV1d0toTUVERE1EOVpWUCtqV240V25CUGptK3d3T3NoaEFjdDJJQVMxS3U5L2dTK09sQWtaU2EvRWlxdjB1OUNCdXo5Qmkra0dTdkNLdXdxQW1qRHZ1SVRTbTRCVjY3V1hpemJLakFEQTdGTjVFSWdsQUVyNE9IS2Z1OEZLekVhZmtEeEhCSE5jdkMzV2NFWnBHak92cWwzR3R6NzdtdjhFbXFlcm5EdkFpdnY5YWorSm9BUThHLy9IdS9qc2lVT0x5L3pHdkRsTW1qLzVtb3JoQzV3RUgvc0NnQkNFemRvQlM5eEh6c2JnWGlLek5Jc2VKU0lCRGhBRmN2R2lyWmo3ZnJzclU0RkFHd1VvZUxvN3ZycUtmcnBKWk54QWdTREdBanBrS0xDQlp4QVdvalFNbWhKa3FxVUFMTXhBZXV3NVc1dEhFZnZIRitwSGN1eVRPRHhQOXlsSCtNeVRGYkdnUndSSXBZSUxSQWFlaWp5SW44bkpKbndZMVdTQzdTQUZCUUFEOWhvUEFSdTBRTHNKZWR2SnRzbmZzckFDRENCQzFqQXlkR3dLYnNpaWcyd1RqRHdHN2V5RDhNeTJNN3lMSHRDSDFSaEV1ZHlQSE5UMC9WeXpaYUlMZVJCM1ZibUNETlFuRFp5d2pVbEhsRFdLVEJ6SjRQbXY3N25HRy9sYWFhbXBabkJIckNBSm1mZktZMHl3d0xKeWlsdkc3dngvdzQvcnlzbmNEcHY3anFMOUJjZ3dqdnpzVHlqZElpbVh6MFRjaXBBQVZHcTcwN1VxakhmcXNLNTRMQ1NaUm9BQW5wV1pTbCtjV2t1dEtZRmcxZGlHR3RHdFBVZHJXdzZib0NpY2lxcjhrYXpjZy8zbmNiR3p2cUZ0RWl2OHdxOGdDM1BTVXA3dFUzUjgybjRjaXE4d2hxa3J6QVBNNEw1aUFwcThTUldGUDc2WGtKR1FnMzBBUEZ5bENqMUt1OEN0ZkQyb0JBTVpFZEZBVVRYSS9hbG9rTW1LaE0yZGN0cE5GVHpNQUpUTmF4WjlmUmk5VHFUUVVsSHlrbC9kV2FQVEZnUGdDOS9sU0hNQUNJTEJqdnlTUHZtYTAxcjVndkNZRmQya2tkcG9wNWlKZUx5SUNpS29rYzFnVTlYOG1jaG9WSi9jMjJ1WEZ0R0xHTjNORHB2YlA5azEvRmtoKzBLL0lBdDNySm1PN2ZyN0hMTXNyUmhqQWN0U0dZSVgvRUltN2J0M3U3Q3ZXREJ5aUFOWXBZTjRtQmVlNklPK2lBUVpwWVpFS0ZlZDVvMy95YzQyMmJWNXVZcU43WkhQN2I2WlNweTg3ZHRiRFdkd2ZOekMvaWROYkYwazZnOWo4Y3JPQk4yaXpBLzUrMC83MjFxd3pWZkExODNERi94T2Q5Vm92ZFFQMS8wVmRvSEVHMXV2N2Qva2pJQUt5bExaWFFPbHpOSEh6QitleTFJUzNaL3k3SUJMTUVIUk1abEQzaU83d3B3dmV2TWNvM1hnTVFETEdKTXo2NkRyN1djU3BKNFF0aUV3L0REUlJ4K1Vod0pYRUFCWkZ3ZmtFREgyV2pJU2JOdW14SjgwNlphT2l4d0I3ZDlEL2RVdjNoeDc3ZU1JN2NCb01Gb2VDLy9adXQ0bkdkdytVYnhlS3pFZFJONWtSTnpGaDh6VTBMV2QvTzFFT1FCd2lJcnBtMzVpQi9wVXJOU1lrUHNxWm5KREZoZHBFdjZwRk42cFZ2NnBXTjZwbGY2T1loSG1YZnREOHVpQVlEckE1QjZxWnY2cWFONnFxdjZxcXU2RGJoNkZxd0JDa2hDR1lRQUREeENIbFNkQXdCQmpjZ2RwOUk0S3NqVlZPbGZuQk03VWYxa01tVW5hOWc1RWV3QXpxcm83TEh2Z3k5WVRkdjBrbGRpcElHQ09CQTZvYTVuZXhKMmFDWDZONnV4T0N2Mm1FZFREUkFCV2FuN0dvM0lmUk4zVmFjNWN1b0RZSzQ3V1cyRUR6RER0MG1BRFpRQkE0REJHY1RkaEJwQUE0eUM3MUJ3c1NNOFhqNW1Ea1ZFY3phUndKRzJXaU1hZUVxVVd6dmxhclBCLzdGdU82SHlnQmpBSmdzWHRoS1MyRVV2NlRqL0JXdWxlNzJydkliQzhidERkcnh6b1FITXU4clRQRWI0R3hFOEFBeUFBZHdacHdHTVFRREFTZGNtZk1LSGRacTJ0QTlJd0N2QU5JTm45NTVmWnA5SDBFMC9HaHM4enNZamF6dGdnUkdPdUdHYmVFU1NlNk5hYlUraGU4MnZPOHVmczVtRHVyelRPOW16UFVXUXlEa3dqMmo3b2dxUUF4K3g3ZEFYZXhGcHNJOEhEZEpMeENHYkNXSVplVEV2R05UTEkrOWhGQnY4dGRVanF4TWtRMmVacFpjZmRzT3VjYmt2OXZPTWZkdXJrZGxMOWFmRCtISC9rc3l2dmVhVC9pdllBQmlBUG00WlFCMllobFN4R3Q3bitKekRheXZ3RzlJbi9kSkQvRENUTUlSM055VldVRENjTWVNaksvOGpRRDdoOG5aOCsvWU5XLzdKeDFUbWsvNzVjTDVqbnptOGIydW96L3p6WS85RVNFQXFCQUZTQWFNQlRNRXNTRC9zeHo3Y3JwK0xsTUxESzlJK0wzTFBUanRxLzdsRkpVQWErSzN3RTJvUGVGQ1hrN2hGbnhaQXdPSTBzRU1tZ3dZcEpWUzQwRXREaHc4aFJwVFkwRUFOSW9Zd1p0UzRrV05Iang5Qmh0UW9vVlFxSXJSSW1aSW00TVlxR3F3Q2ZQandqeWFtRDZNQ3NLS3g2b2FBV3FaSTBTSmlLNGVCaVVlUkpsVWEwWUMrVnlLaFJwVTZsZXBHQ2RYQ0dGMjZsU3RYQXdDZURMZ3g0V1dBVVI4dzBWUzdsbTFidDIvaHhwVTdsMjVkdTNmeDV0Vzd0NjdNbkRRbTNCZ2dEU2lVVjZsOFNKREE3SnlScmtjWFJxWjAwR0QvaDRHY1lNR3FzSGt6Qnc2eFlxa1N2U3hDYVJHbkVhVEdnNmVGSFJsNllNZVdQWnQyYmR1M2NlZld2WnQzYjlnYmdxM0drL3EwaU5LbGw0bFdGY3N6NTgyaUJGNm1uRWt5dzhkTEsxNnN1cDE3U01VK1VyMkNrbEthV0xJdzBhcTFpVk1uVDU5QWhSTFZlcDMrNDZaUHUrZlh2ei9qSzMzejZ3dHdLeU1lRUd5c3NzNUtpNjhGR1d6UXdRY2hWR3VVVzdycFJwZVpJclRMSmxSQXVDV3dBUWdvNWhBb2hCcnFBUWJPRURDaTZoS2F6cktCTW5PdUFzOUFVNDQwMDFCVHpRSUlmT3ZSeHgrQkRISzNGMXhJRFlIaWpsc21PZEdZNDBCRzZDN3JvS0NEV0tSRVJhU3k4MGl4TGJuczBzc3Z3UXhUekM5TEFlK2tsSW9od0x4Yi8wQkFSU2IxYnZyTHZaK0NHcXFvSy9HVTZENnJ4dXpUenovLzVPK1ZHZ0RNMDFBREdMaEJ6YkhZTkN1OURDR05WTkpKMVdxbmh4SGVJTU1JQXd6SXhkTmNJdm8wRjA2TitPS05FWG93UWRMMTVIeENnR0tPRVlBUEpJQW8xTkFxS1hzUlJsR2M4K3d6RzQrTG9MalVYQmhCeUdPUlRWWloyaFFvOGtqamtsU3VTU2M1Z3pKS3lxbzBWRStMTU9xeWxESjlDRmZjY2NrdDE5eHowVTFYWEpPSUVJK1VWb3BaUUN5WFlFb1FUdloyNm9uTytPN1U5bEFHOE5zUzNIQlRLYmhnSWhCT1dPR0ZHVzdZWVlNaGh2amNiMHZwa2lvSnJKZ0JWSC96ekNXTVZoWlFNNUVKWUhKVFFVcFJUbGxsdUdUWWdBSURIT1BZQ3dQa29HQ1BkdjhndE9rdkdsQXhCWVlaVnBCNXhlcGN2QXd6WG52OWRiUmdpN05BZ1dXaGpscnEzYUpnQW8vVGdsMXl1U2FkZ3k0NlRxYWtzanFoSGNwT1lJSVZma1Z0V3RodTIrMjM0WTViN3JucGhzS1dkMDJwWmRGVlNHNVRwcE5aYlU5ZitPeTBsV3o3QUZZTTNJUmZjUnVLeHlHUFhQTEpLYS9jY2hMaFZ2c1ZoaEVMdDJJdVEzcUZBY01QN3lxUUJ4WllxU1VFSDEzWjlkY2pIT1dDbHpjdUhhSlIzNEFBdzcwd0JHZURMNEsySFNJV2k0WVJGcVE3K3l5MHBZOFRBUUZobkpoYSt1bWw3Nk1GYUpHVGx1dHFNN3NXMjdGTHIrZ1Zrc3hzbHhhN1NTSGxrUFZiYWQvOTkrR1BYLzc1NlpmZmxQdUxxU1hrQVo1WW5SVVFZdEs2ZndUL0xsL3ZxWk44aEVjZlJPRkNBdUZDMlBudWRvaFczSStDRmJUZ0JUR1lRUTFxc0gzclN4OHBiQUU1dGlXc1lKN2Jra2VZMGE4RTJpY0hJWkxYZ2Z4Mk10ak5rSVoyS2NRYlZsQzdGVTRrRnl0WVFoUHl3b29DQUcrSEVpSGVRYVIwbVJnbFRXbXF1SkZwOElDR2RWQ1BpbFVFMGdmZzRBTHNSVUJyb0dsTzE3NEd0dTlKUm5qaWMrQkp4alBCWWhSREdpRWp3QnZoR0VjNXpwR09kYlJqSFFXUXh3SHc3d1lqbThBdFN2WTN0aEJ3VG9SRFlCRzNnaWdvbU9sOGVHUGpHd1d3UjBsT2twS1Z0T1FsTVRtQVBHNVNBSEJjUU9wcXNVWUtIaUo5SWFURjVvalF1Yzl0SkJXTlFhUlhrTENBdkFuZ0NTT3Jsd0JybUV0ZC9nTUMvMThnM1N2MXRJVTV5QVVFZmRqQ0wxOUp0T2tZYlltYzhkWHltQ2NzRWJnQUFPeXc0ald4V1J0VTFFR0xXK3ppOXJobnRMQWhCSHpocXdFdGZOQXV1OEZMR2dTSVpQOXUwTWRFekpPZTliVG5QZkdaVDMzaWN4VjhtOEI1L2hjQU53bHlrSEVTbkFINWhVeGdVb1FCdGtpbnUvTG1UckgwOFo4VnRlaEZNWnBSalc2MG92M3M1enpqR2MrdzdER1BCRmhBS0UzUkNoQ1NDR0dJV1NWR1dobXpoV0twQnNjNGhDbGVlSjZZeUhDWFBWMFpPVjQyMCtzWTRBM3BXRXNBakJrOG9ScFJtVWhrSnZLU1Z5Tmc0V2lhQ3JBbXNuaXdoeXF3UVFoQzhFTU5TRENLYk5ibUEyclFSeVNFd0ZWTmdGV3N4NG9IR3JycFRlMTlrWHRmRy84bmRjcHB6anVZaEJhMmdOY0NJdGtTc3REZ0ZvQmt4V0VSbTFqRkxwYXhqWFdzWTBFQVFJR2VCUzA4dlplY0JuZEFGUzRWSW9peXhRTlRvamV4akl5d2g0M3NhVkdiV3RXdWxyV3BmV3hoYjBFRDJYWTBFZkVrS1FGUWVnaGJuREtWUGxobENoVTYwNjhVSTdTMDVOc3RMZXRUNVdab0E1N2diSUM2TUFJS0tQVzVFem1pVTVVSTFSa3BUemxPWk5wcFhDQUZNL3hJRFVGSWhoQ0NrUUQxcmxlOVhPVkhFQmp4Z1d1S2d3RllTR3Q2MmJ0ZU5yQUJDd3hRQXlaNmxBUUF4RFZyM2ZVaXRlb2FwYnV5S0lFVmdZSTZ5VVBMQXdVVUZSVzI4SVV4bkdFTmI1akRGUjdGaDBFTVlwbU1HQk1sbGdzaE01dlE2bmEyb2VxODZRdi82UVhBZ1k2WXhqVzI4WTF4bkdPWmhIZ1VGZzdBandNQUFzVEc5cCsxM1NNQkNLTlN3L1JXTWJob0FIVlhQRE1BVEFNS2g0aVhlV2pndDkwdGw4c01TZ3NxNEJEY0tJLzVPdGV0RERPUEo2Tm5RbE5KMzUzbUNVeWdtM1lBSWczQkNJWUY4SnhuUE9lWHZjRmdBeU9veUFNc3NJSFA2OVh6b2UzY2p6OGNBTUMzNFVHemlpUFh1U0w0T2Qzem50akkyT0FhUFBoOFZsNlVUaWxiWWxHUG10U2xOdldwVVoxcUUrTUZ4UWd0SEpsbjF1Syt3dXZUalNKb0RVdHQ0dytqNHNkQ0pyS1JrV3dLM1FyRnBhOEFnSmlCK1pWV29FUWx4bVZkY3JzYzdST25aUlJoaHZXMTg0U3JYS0ZadTl1VmFqU3A2b0lUdEdNMkp0akRDU3lRLzRBV3JKdmQ2ejcwb2ZNYmpFaVFlM29BSURSNzM2M25kck9iTlM1d1FTUFEwSU9yNm1FUVVpQndnU2RONlFwNFRaelR5WmFtT2UzWE5BMWdaTGNRS0M2bHJTR0RGbkJmcnlZem9raHhFb2tUb0pZa3V6aTB1VnppRWZjNEp4NENkakVJWjVJSEFBSGJCZ2pDSVdZOWNWdWVQT005ajR0TjBnSUlLR09iNlBYUk5uYXpLeU52UXhQY09HcEJHcGJBaEJhNFlEZ0lFTTdWV2JQdkZ1UTd6d2xnUXloUUlUMUFDQ0VCWE1lejFsdUFkZUVZeWVvdVNQdlZ0cGc5QTRNendaZkdkS2JMdUdtUjA1cmlmK1M1eisvUzZvNGZjc3dnMzN1YVNoNUlsR2ZjSmgvZ3RVNCtGS0pXN0pZSWgwQUNzcFBkZ0VPSTU4VnJBaURHQWMvNE4vL05vUXRGTjcyS2pvNTA0eWw5dTl5MTBST2JGMm5uc1YwMWFzLzZ2dlBOQmdCTWpRUjNmamZhYlY5MTJzcys3bHpzN3RhbXBYUnIyWjJjZWJXZGd3OHZNcitiTFBRYXgxY2hOWXY1SWhvKzV5VGZPZldyWDlEckMwYVdwQmhQRnVSQWRBUGtnQlFRVlIyb3R4eitMamQrRlArdzlnN3hmdnJEcGY3TTNHYjltby9QdTRLRnFvYUY5bXBQN2RBdXo5akFXS0RHQkxDZzdDd0ErR3pQQUlsRDlnWlE3dWJPVjFpUDRSck80UjRPNHFLdjd5d08vT1R2NXpZTysxVHM0eGdnNUxvdjhmNnVCR3ZDOFRvazhvcWhmYTZBNW9oT0NSNWdjNWl0RnB6dGxtQXc1V1FDRmY1QkVNaWdkRHFnQ0RwQUJjS2hIbzVnQ05vQUEwekFCTnIvd1EyR3dCMDhvQVMrZ0J1VVVQKzBwVW9tdzBWMEJUTXlvOXRhRHpTWWJqUmdML1prandLdERnRzFMaGdLWUZrK2dBWFViZCtDendDSkQyc3VVRWtDRUExOVJlRVdMalBDU0l3OGtNRjJDUHE2VHdSZk1BamJRdkFNYWJOV2pQdEd6Z1ZKRUFZRFp3SVM0UWxDUkFEd0lmMkl6Z2pBSUpWRXpoU0tnWloyemw0Y1VaY2FqOWYrNFFLR0xrK0tZQnN5SUFYaUFVaWVvUTF3NEF5S3dFcE9UNGZvQXd5bm8vK1VxQXovYjgyKzdmWFdrQTBqalFKdGo5MFNnQVNVcFE2Q1lkM3ljUGlJN3dLUlEydm03c0FFc2RJc2pmbWFEeEZYU0JGSGpoRXZjUlV2NjZBR1R4S3JpeEpwelJKQnIvb0lLQkVHWUJXSVFRRzBiNkVNb0FFVy95a0V2MjhlMVJGbFZBNG5RT0FmOWlBV0JZUVNpbUFMcERGcU1LQUV1cERNTnVVRVFpQVZDQ1ZBd0RBTXhkQm95REROamhFWkExQU50VkdhMnRBQUVkQWZvdWRZZ0dNQ3NkRUN0ZEVQUnhJUU5aRDFCakVjQ2VLdXh0SDU4aTdpK0s3aUduRWdCK2dFVTh6akNtOEZvMDhlRjgvbk5pVEkvdUVHQUtFTFpLcm96c0FHaUNDZEZqRWdsMUlvTTZRVmMrSWZOa0FoNjZNSXlPQWhxUWNEM3FBSW5tdFRIQUFHT21GOE1PSVZRbUFmSDJJak9USlh4dEI0Uk1FTW5Ra1owL0QxU3BMNDNIQTFXcUFmNkExSWVvRHFWb01Dc3pFbXVWRjd2Skd1TnBBRHhVa25kekwveWxIdnNuTDZCRElJSVRIN1lBMGVFVThyQjNJQU5HQUxjdi9JQzJmbW5Nb0VJRTB1SGJseVVsaWxRekJCQThUeU9vb2dISGhnck9wQkxWK3BoOW9TR3VDU0kwcmhBVFRHNkRaeUdDc2pMejl5TDIyeUwvMXlKSlZrR1FsdzltaXZCWmdnem42RUVSYnpKWkdrRDJYeStOQndXaVJ6TWduUkk4SEdNdkVLREpPdEJqNExKVm9oVnA2QVhod2xOdGNDRTNvTThucUNNRWpoRG93eXlrVFQrMTZ6TTdzc0FKemdCK0FBZU9oeXhYUWdDMUtoTlRkVDhleVRVcnhTSndJQUFoWlVJb3FBQW5aenJHSmpFWHpUZGtibEhXQ2dHb1l6ZElMZ05wSENMdSt5STlHVEVKM3pPWk1uT3FXVE92ZFFOUzdoTlhxRUVZeGtENHVQaXg2VFNXaXlKbVhVYTNDeUE1V1RSV2NLQ0JTZ1NaMzBEYUFVU2pQL1lFcXB0RXF0OUVxeE5FdTFkRXU1dEV1dE5FcWoxRW1iMUFHdXJTbm13UXF1Z0Evb0FCS2d3QnNFUWJRbXlneWlZRTdwdEU3dDlFN3hORS92MUF6NHRCMGNBUkdhUUEwbW9RY0tBQkQrSUFPMlFBWGtBR1pVVXlrUVpYeEtvaFI5MEFWVmNVSWhwUlU3UkxhSzRRaXZoQksyd1N3OU5EWXdnQXc2UUdoNjZCMGF3QXBPVkNxWUFRV1VBRG50VWptWGt6bU5wd3hqOURrRFVYbVNFVEMxa2Zqd3dOK0FOVmlGTlZqaEx0SWNjeWFIOUJ1ZlpDL1BFejF6VWozWGN5TWJkVnFwdFZxdHRXUGVvUm9xaHBHS3kzL3EwMUl2TlU1bU1CRnU0ZjRFWkVOdk1WUnJRd3RDOUVwNmFBWWVRVlVsWUQrSW9BWlUxTHBZdEVXSE1ZbWMvN1ZXajRjdm1ZaEdkcFVrUzlJa2ZkUkhDeFpJa1pVOGxSV01DTEVRS3hOYW85VXVyN1ZpTGZaaU1aWWlKQ0VWREtHQklBeW5zQXdJd1RWQ1p0TkR4dUlCTXZRaGlxQUUxQlUzdUtCZDY4TUEwRUJlK1VNalVpRUxWQUFZdHlKZkZVSlc4WkpXaTlGV1piVDFCUFl2Q1RaaGtUWnJ3ck1ieVhOb21iVlorMVZLSlBZeXBUVmpyZlpxc2ZiYVZ1QVJudUk3WEd6aUdDVW9SM1pCQXNka3hlTFlWR1JsV3pZM2pnQm1yeU1YSEtBYTVyVm1OK0lWbmd4V2VkWm54UkJvL2ZWV1E3Sm9qVllOcDdQTkJuQndsL1lQSTdOaEY4NUlJVmJCcHZidWVOWVhzM1p5S2JkeUU1RmJPaFpDYmNFVUJWUkN4N1pCR3U4dlB1UUdyQUFVQS8ra0E3WWdYZGYyTm5wVFJRd2dCTFNEYmtlaUZOQTJHQ04zSWZSMlgvblZXUjhXWUlsV1Z3ZDJKSVZYUEpOVmNaKzJjWjgxZDhmb2RoUENjcDMzZWFGWFd3eEFBVGkyWXh2SUpNWURwMWdDL2o3WFFZWndCZ1dEQUc3Z2JnV2tBNFpnZFhNREZiYWdWQVBrSzJKWGRtMzJBZDRoUTVtM3FaUlhhdnUxZDMwM1Y0RjNQUDMzZi8yWGY0dlVTS05XU3BTWGF1czNlaFY0Z1JrWU84REFCektDZkVLUVVXS29lNzNNOFhKQ0V6VkpHbzVCQWFZU056TUFmWFhESGR6Mk1XYmdBZVpXUzd6a1c3d2tkRkFBQ0Q3NE1lcFhHTzhYYUdIVWQyZVVmM1ZZaDRkMmNhSFdJNlZXZVdmNEF4dTRpSTI0Z2FlM2VxMlhXNXZOV3l2Vmd2UC9nb0FDUXdBNG1BNDROVUNLd0IxRU9EZnVnVlFGeEFoUVFJbEhRbkhXSldMRTVYTVVBeVJlb1F5VVFHZkxiSWpOVEZaMzF5UDF0NGZ0dUlmM2tuR2QxWUJ6RjQ3SjhZZ0JPWkNmTjBzaUdFS2hnTzlnYUtDZ21DLzhBbnhCQkZZZUlCQVdVZ2N3WUl0ekl3TksyQ3RDZ0JraW1JekxwM0hZUm9SNHE3ZGU2aU5lSVFmYStBdjlXREp5ZDQ3UlRHanZHSStQRjNuNVdGWlgyVG9FT1pkMTJYbFhvQUh3bzF1dWx3aXlWM1hvODRrWFdlTWVUeE5kNVNlS0lRdGl1Q3NvUVFVNjFKSnRBMFFGeEFCZ29HdkpKNTNNWnp6VTU0SklLWVEyeDZYU1dJMTNBSWFGWjVYMTFwWHArR0gvTlkvaE9aNFo5NGVCdUphVGRJWjNPWi8xL3psNmxTQ01yVUp6RWZtUEt2aVlXYzB2OUhNQVpPbW1uSGtoZ2VBZXFQazIyUFdhWVlDQnlzUWtHaWVOVExHTjNHbVRUQXJtbEd5Y0U2T2NUWGtONWplWm1MZVYrYmFkM2RtZCs3V2VKVGFCOXptbVpacHlEUUFNUkJxWUg2cktRSGJDSEdVckNWcjhNbmdUY1Fzb0RzRUdYbFVqamFBTkh0bzJLQ0NURXlrSFhzR0JHc2NXYmlwZTNpbWU2RW1rUUVRYWF0RDhOc2UzYnJvanFpRVZyRUFCN25YL2JyZUdVN3FsQzlpZTd6bHlaenF1NWZwcXNmbVhPNW1iaHhrVm4rMm5DNXBEQUNOOFJZUkVYT0U0c1pnTGxwbzJNRUFPSkpjKzVDQUxTQkdpMGlTdytJYXdBQ20yQUFQWWZtTFlTRG1zTzZJa1JrZW82dmVBTTBGcVNmK2JPVXZicmZXV2VlZDZ0Vm5iV211NkUxSzRreU9WMmNCV29CV1pyNjBQczZnWVBsN2hEdlN4ZkNsQXZnNDdObUxBcVpjQ2JxSEJvck5YdEZZSGtIN014MFNYSjBDRVRsZ0tNVGpiSTE3aEhFcDZwbVpZdEwzN2dHRzZ0Y1Y3dklzdUY3cmdITjVYdHZucUhHRW9nSHdhdDJPUVBaVDVWVXlCOGtpQmZMSDRDSVliTnRyaERCWjdxSUxnSHhlUnAyZU14aDd2cnpWcEFicWF0OExsdWp2Q3QvN0RqZkZ2aUwvYnUvMll2REU4d3d2UGwxVjR0dGtiL3Q0YnZvZVNROHcyUkVha1JCNGdSU2E1a29jYmsxMVhFZzdqVEdaSktjWHZ3RDlrdHlldlJNQTZ0a1BIQnNEZ3JFdm5sb1U4dkRXOHlJMzhsVllBQ2V5YVR4anB3L2YvV3NUcllrTWNtUUNFYmNsOEFCZUNJR1Vib2dPK1lKcXBHUWVNZXlsRThTcjVLc0tjR09Qb3IrVW1RTHFIK3NRM204ZEJRZ0plWVFmZUFjalJlc2p4bkNjUnlRQWNnQnVPL00vbk9oZmtJSnZqUEpnSFhLZGdFOHJoNG5zUnZQeXNQQldNK2tvNmdBd0c0YUd0MlhYTElLckx2SW1MZVI0cjFPVUF1OHAxSEkybG9oVFd1TTZmSzg5dm1iTkdSUUd5NEJBa1FjSUJmZFlCMlFEZUFRV1duQ1BJWjlOcis4a1ZuUzRZL1VNYy9hdmwvQkhzSERLMjRYeEZPQjZhK2twa2RueVltSmg5M1MzV3c4WnZJQ3hDcERCRzNjRS9RczdQSVF4U004cFUvWStmaTFQUVlBZGhhZ2RrbmRiWlBYcU5RQTRZSUZ5cXdUdGFFN0kvYmRwLy8vM0VaTERSQzRQWUd3Z010TndoaWtBTDBEY0ZPdUMvNjJNR3JHQmJOMTNhMFNQK3FIM0hyQjNiWVE2RWREeWs0ZHc3WHVFQmdpQVFBaDZSaVBqMERBQUlHcUFUMGpzVjFMM2RWWDZCTjZVR3JDQzlWWmlSZEhvbFJCQ0FqRG5mVFpERWFYQkUvTDA0Y2JCVE8wQy9ReFVEdmlETXVVSU96b0ZqcnhlaWNxb3NDUFErYjhMR04zRzZoWTN5M253N0NxWU1zdUtaWjUxbUFHQU5WdFZtVTM3bHlaNm16K0FSb0FIbU81eWJhWHR2eW1LZ1Foem5tOUxsSGpuSHI3SmlETUVIMXVDbzhZUVNPc0N3c2FrTml2NVFZSGVKWGN3VWFtMmdvMXppUlhmcTI5eXIzenpqb1dKOFF1QUVPQVhRYVVZQmRxQmdSQUxsMTczc1FWODF2ZjhlMXlGWUtyNUR1VVByM2dQcDZYRWU2cTl2bVFrSHJHRUtCU1JaVzNLVHhhVW5IdXBCU3FTWDBETVhLOC9SbGhSZlE2bzl1Z1dEaWl1ZXBhNXl4N3REem4yZ0RCUmdVY2U3aDg0Z0NOWWdsYWJDODBOLyt4dlZDRmFnK3E5ZmpLT0NqQkVtamE2czVCcmw1bHQvTGpidVEvanp3YXg3Ym4wZ0MvamVVSktRQXBSZFdUQmdFYllCSUlwNEdVaXdvTUdEQ0FjYXlFSEVrRU1KUGxJUm9VWEtWQzBCVDFiUllCVmcxSWQvSUVPS0hFa1MwNGNQbzFBRllIVnJ3cW9iQXdRc0tHYUtsQzFhcjRpazhsRktnaytIUUlNS0hRbzAxYXNIRFU0WU1KQ3dxZE9uVUtOS25SbzExNHBBQ2tKVWUrV0RxRmVocVhia29rcTJyTm16YU5QL3FsM0x0cTNidDNDbkdsaHhCa0FPYUs4a2ZOMXJ5R2VwaUJPaEhESWxqY0NBR3hNMkJrQjFFaFBKeDVBalM1NU11YkxseTVOTm9nTFJFaWFCWXExdUV1R3A5NkdWZDBiaURpelNZVXNNTjNwaXk1NU5XL1k5ZHhub0ZhR2syb3VTTmFtQSt2UkI1SlhnWW9ZUjN3SVI0SU5qekk5TmZsREptY2FFRzA4R0VKQm1xaFVwS0xTSTZDVDlrNjk1Q2N5T3dsQ2dZd1hUM3ZEZkxnV0NKc2ZXcnViTmh4MGJ2Ny8vL3dBR0tPQ0FhUmt4SHdBdzJHQlVLZm50NVJkZ3RBaG1DbktIclRMQmNoMDVCOTJHSEhibzRZZi9tRFRLU2pTOEpBQjNwSVMzVTJsQUVWSERDdjFSMGtFUlJTanlCUVVaTElJRERvdVVFTTRXWGN5NFczOEcvNFFCRFl0OWxTSVJSUlpobE1nRUhESDJISWdobmpRaUNLeFlsd2hNTXRGMHlIZmhqVVplZ3cyVzhrb3FXYXdIeEZLcEVmaWZnUWJNVUVNSUQ0aUhKSmw4N2VmbW5uejI2ZWVmQThKcHdCbGg1QkZDRmhLOHdzeWRlQTcxNEpKUVZJUWNSb2dweHBpR1ZHYXE2YWJRYWNiWmRkcUJKaHBwUWhGUmhoeUFCcmhDQTY4SUpjRmZ4VW1ZWEdJZ1hNcHBsU2lweE5JRTEyVkh3RXltSEdJTGVPTDVRQjZqalJKVlNucWRyQUZERFE3SXNkUjdxVUkxclE1aEJCR0NEV2FtZ215eWVZcFY3YmprbG1zdWZMbE1PNWNCUnVnd1F4Z0FNQURET1E5MDhzcVozNExyNnF1QVRXVExZSk0rVVdtVUhtRXk1YTBJSjh5cGlDU2FpQ0lVeGYrV0o1d1BBRkI3TGxzR25HQUZnMEg1dFdSRkZ6MlJpR0lGS3l6ZGlDUzZoSjBBQk5SQ2swMDRGWHVzdmcyK1dwd1BENkFBZ3o0S3pLQ0VnZTRad1o5L3VRaHF4Qm52QUVCRkNHdFlZUlF6SE5OTWN5azJVR0gxMVZobnJmWFdYSGZ0OWRkZ2h5MzIyR1NYYmZiWmFLZXQ5dHBmUC9KSUF3M0FFRUlPTzZDd2hnMFBYS0ZrY1RtdEtIV3lQa0VFbUhIL1drUUFwWW14VW12SkNqZnVlS2FhQmRCU0lxSFdwR0pQaktaaXd6c1dYMnhXTGtyczBLcWpzTkppU3lzVUtsZnJTWStmVEYyV0Uyd1pVOHVtQkR0c21EdGhMdkhmTmUrZFV5bFhQTERHRGlFMGdFUWVBQ2dBUmhnT3ZETURFR2RFTDMzMFFNendqZ05oZ0tFQUFIbi9JQ0gzRG1zOFVJMlpmZWZMKzFlQnAyLysrZXkzNy83NzhNY3YvL3owMTMvZW84VkZLR2xoQTRpY09ITWV3ZFRqQmtoQTZLQWtBSi95aktqQ1F5cWl2RUlTUUdpVDU2aVNDem5BWUhTa0k0NXhCck9Bd3lRdVF3ZHozTWtDc0JMWXlZNWwwdkFTbUhJeUh0MnR6MzVFVVo5ZlNrRkRGNzRRaG80S0hBMk54Y05qM1JDSFFBeWlFSWRJeENJV1VZZkdFczhyOU5jS3d3bWdRaDlFUlFCRFdNQXFXakU2Qjh5U2lSWVFMQ2prcElFT1JNRU1PamZCaEJoQkNTSEFZQTZKUTRSSUVRWWpGb3FTQUF0b01DdVJrQ1ZhZ29sMlV0Z2RteEJyUEQ0MG9pRGJoMFJqU1VROGlCVFBUc1kweUVZNjhwR1FqS1FRQzhuR0pVYXFpY1ZZLzhBVGIvQWtHdHlDWUkyNW9paEhXWklzbHVnSko2cUpGMGZUazcya3dnb0tnRkVaRVpLeExLZ3hnN0VDMlJPZnBEZ3BrVEpFSXl5aGRWNlNIWmE1ckkrM1krRWlYU2pKWnZabGhvWlVJaTBpQkFWYldCTUs0T21ic1hibnpHNTY4NXZnSkdMNmR0Z3ZTNUppTUU3c1g2VStTY0lwL3ZLZHBLempabTV4eWxRZVlwVmc5RXFpUXJDbVdYckJBRXBvUUNxaXBrOVlHVWVYQTNnU2hrSUpUK25rQ29Hd2k1MGVaWEpNN3lSVGtjYWlZZnJDaWNOeDh2Q1FsclFGS1pwWXU1SWlNMHpiL0NGSFY4clNscTUwbkgvcFYvNGlOZElKRldhVFQvcmZZazR5UjNqNjFJb24yVXlXRW9GS0xncUxnWmpUVHlwZzBFOXpBUlFKblFnT1gvOGVsTXMzZW5BNWw2TGlPK3NZVklqUzB5V3lpOGtDS2tvS01NVU1venl4b1V2QnBiNll5alNrNTZ4ZE1RcHpPQUhZOVZjcDlFN004cm5XdnZyMXIrSnNxMXNQbWI4SWlSU2RjejJjT2kza1NjVXR4cDAvamF3b3BhTXJsY21rTzZKWjBROUxRUVJKZ0dFcGZ6TFFDWEtRQ3FuZUQwSVNrb2FUTHJTNm5rb1dWdy9GMGxkZmdwM1pwWkFtM3ZrT2VNS2trMFdtVlgyQWhlbGdRVHJOYXA0VGs3VllnR0lGeHNrdDFiWkxlaDBQTndGTDNlcGF0Mll5ckdFUFpWcFliSmFWcE1WSTduSTV5YXZHa3ZCU3JuMnRlZ2ZZVmRncFVKVmZUQ3FaUmxNR0FBUmlCUkwwandIa0FJWVEyRXVsVkozSVNGT25FVG1tZDcxY25jN3J2aXIvMFluKzZwakJzc250em9yV2pOb3djSTJVNGF2SUdSSENkbGVrTloyUWVKOTRtQnRZS0RHM1NMRjFKQnFxNklwSnd6Q09zWXhuVE9NYTIvakdPTTZ4am5mTTR4NzcrTWRBM25FTjNkckQwaWFTYjhVMTduSGxPdUluTXZmRUcrSElZM21xMWZWYXVYV21CSlU5aWFWWmNQbmdGZFVvUXhCbUFLZTJ3QWtJQUFpQkZjN0VWb2hJNUtDRzg2Q2xEbnpsa0NRNEpYZk0wb3FkTzREWmJhY1lOT25PbDNTN1d4WXEwcmM4SEhLUWF6ems3WFk0a1V1a3BqV1hMR0xsMmxXZEppN3ZKNWxEd2s3djZpV1ZBOU9oSFUzcVVwdjYxS2hPdGFwWHplcFd1L3JWc0k2MXJHZE42MXFYOXBDMzl2Q1I3elZOYWlxWjBpS1docVg3WE9KRS8wQjUwK2NOSUozcnpHeVRIUkJMS2dzMVB1V3JMd2tZSlJVUGtBUU04cUFBQjV4Qld0TmFnYmluSlFjZHZDTU1OV2hBR1I1Z3BrVkpMY0FVUVowbS9ZY2h4alU3TXc3Rk0wVHh5S3RWOERrbUxGdkFiVXM2YUQvdUZpZUdQbkt1YTIzSVd4OFprWkZPTW9nUFFkSmdXOXJKTitEa3NWbmgyQ256OU5uMEJQV2ZJenpoWHB2ODVDaFB1Y3BYenZLV3UvemxNSSs1ekdkTzg1cmIvT1k0ejNuTXNjbHpubHNUeE9la2VNVUJIVjVoMTdYUHpDV3ZwcEc5R0NsUytkNVF0eUpsVThhbHZLWkladFA5MjRaVGtaNTdlYjJGS3NVdXJQdzFHUDROYktmTGpucEo4bzBLbGV5YkJpdjJkOGF6QTNBQzROVmxnUlowd2EvWjg1VjcvZi92Z0Y5NXozOTkzS0VYWGJtS1JYckdWN0h4anJmOTR3WVR5ZFJOV013LzU5MmttTSs4NWpmUCtjNTcvdk9nRDczb1IwLzYwcHYrOUtoUHZlcFhUL1R3MWtJYVJyZjdwWW5OWEdPZk9ER05kYnpUcVZ4bHRmdGVZWGI4bE1ocllUdVUrZ0REZm9WMzRXcVJISVVDTU8yL2g0ekI4cTF2RUdBSmp5c0dhOFpyMitlNzRsVWFlTCs4U1Z0Qi9rT1kvL3pvVDcvUUsyN1MxcjgrOXJQSHRNWjVoZnRQZHR6amplazlydHdPTzduVDNhNEFHSUFDT0lBRVdJQUdlSUFJbUlBS3VJQU0ySUFPK0lBUUdJRVNPSUVVK0lERWRvRlBrSUhibDNIR1JuL2xCWGYyZDM5U3BHek9FWG5SZDRKVk5IbVQ0eG5FNXgycmxEdkl4MUg0czBUL3kyY1kvak5uMEllQytPWlFLS0Z2KzRaOUh1aHZ6alYzRjloOUFtaDNTTGdBaUllRXY2S0VURmhYQUZpRTh0ZGN0MWQvSENlQ28wQ0NKb2dacmxOQ0ROWnZqQmVHWWppR1pGaUdabmlHYUppR2FyaUdiTmlHYnZpR2NCaUhjamlIZEZpSGJPaUJlUGlCbnBSaVYzaC9UWmVGSDFlQ09qaUk4ZlJRSnVRWjNPR0N4a2R0enZRZ2d4TXBnOEY4NmhSRmtFV0ltcEpnVnBJU2JvZEExOGNTOUFSM2NKZUhZWmdJcExpQnBuaUsyMGVLdGxlRjlBZUt1Y2R4MXRkcGJRZUlrS2QvbDNGbmJtZDlmYmlMdk5pTHZ2aUx3QmlNd2ppTXhGaU14bmlNeUppTXlyaU16TmlNemdpTDFoZUxuWFplczBpTHRXaUxscGlOcmFPQzBkWWwvOFczaURFNFNJWDBadnBqVTV2RVdLQzBoZHBvTXBpWWlXMjNpU1FVamI2WVl2UllqL1pZajc0WWpkUFlkQ01ZaUNXSWpaRERnNW1ZaFFSWmtBWjVrQWlaa0FxNWtBelprQTc1a0JBWmtSSTVrUlJaa1JaNWtSajVrUDY0a2Yrb2p1djRrWkhGamIyQ1FpOHpMTXFVVWVIWVVZNUlYQ0pWTzh4M2psR1VmeUE1V2RNM2ZSelpnd1Q1anUrNGo3TDRqaWxoa0RkWmt4NzVVMEpabEVaNWxFaVpsRXE1bEV6WmxFNzVsRkFabFZJNWxWUlpsVlo1bFFBNWsxcHBaVnoxT25rME84Y2tMTm1FVmhxMVVlNERVOUUwVXkyWlR1UzFFY3lSVlZtNWxmR0VsVU1wbDNaNWwzaVpsM3BwbDEzSWIyRTFjcmF6VzRua1cyVUpYSXdTWS84Y0psUEZKVktZZEZNbGhtSlNWb2w3T1ptVVdabVdlWm1ZbVptTmsyOTNORnZQQlpoZk1peUNPWmlJdG1wR2xraTlabHlJOVpKOTFwYklOa1Z4cVpteU9adTBXWnUyZVp1K1YwZFo2Slc4c2lXVjF6SjVOMmlpZVhBSWR5K1E1blVtNTNObFJYRk1ObXdDazFOdWVWNHlpWnZVV1ozV2VaM1ltWjNiYUNVTEZuZSsyWDEySjNDQU5uN25WMWJtZVo3bVIzNGxCV2l2SjN1S2wybVErWmJLRnB2YVdaLzJlWi80bVorWGlZdnh5SEhaSjNmY0IzQXNFNTVLS0hDd1Y2Qk1HSDlKbDFQeG1XeFBwNThRR3FFU09xRVVxcFYzVm4wY3AyTC9LWVNvMktHMjE0cDdDSTJQTlovMFdhRW1lcUlvbXFJcXVvMDhxSW1kcG9zWlNvOW1yamlqOUhpRjB2aUhXbGlpSzdxalBOcWpQdnFqa1ZHVGdaaVRLdEYyUEdtazFVaUNIUW1rVE5xa1R2cWtVQm9kUWhtVVFobWxWbnFsV0pxbFdycWxYTnFsWHZxbFlCcW1ZanFtWkZxbVpucW1hSnFtYXJxbWJOcW1idnFtY0JxbmNqcW5haG9RQUNINUJBVUZBUDhBTE9vQXhnRHpBUEFBUUFqL0FQOEpIRWl3b01HRENCUCs2N0hGZ0plSEVDTktuRWl4b3NXTEdDZFMyc2l4STZXTUlFT0t0TGppelNRYUE0cVpXcERGeU1pWEVoWEtuUGt2M1J1SE1ITys5TWl6cDArZm1UTDlIRXEwbzg2alNHSFNUSWhKSUtBVlNYY1duY294cU5XclZ6dG81Y1MxcTlldllNTnExWXExTE5XTlVkTW1wWW5wdzc4UGNIQWVQVXUwckYyc1l6dUU3UXFyTHl4Um9pb0lIa3k0c09IRGlBZUw4aXUydzEyaGROR3FuUXl4WU5zUG8vNzlrUXVUN3VOTVcvZHk5ZHNYTU9ERWhUbW9YaDJyZFN4VnNHUExWcldzOXJJSXVIUHJ0bDE3dG16WHExVWZOczM0NjlqUGtDTjdwTXhjNDlDN2VzR1dEcHc0dUdyWHJYM0h0cTI3dTRqdjRMOGoveGhQM2tJZlBlalRxMSt2M2swakJPRy9kNC9RK3pmdzFZa0JGMitNL0d6enVUK1ZGUjFmZnhrV1hIYXoxVFlmYnZHQlI5NkQ0K0VoNFlRVXRtQ2hoUlpFNGdaN0hIYTRuZ3gydEVDaGhCQTJ1T0F5Mm1FWEhHTDZ3UUlXV1dZUjlaOUlRR1hsVldtcGNlRGFkdDZKZ0FjQ2UzaTRYaEo3VkJGTUFpMVlvT1NTVENxWndKTlF4dEdFa0ZSV3VRRWJUU3A1b1lVamtsaGllUFBWRjF0citCbTJtSXRkd1hqVlR6TldGS0JWb1hHQzQyQ3N5WFliZy9DMVVlV2VmUGJwcDUvaTFCQ01FRWRDQ1NVYmJQUlRReDlSOU1tT0ZDN0lseHVLWThZaVhHR0xlZVhZbWo3OVZ4UmVCRkluMkhXdndYWW5nK0pGaUVjd0kvenA2cXV3eHY4cUs0ZnRwTkhDYnBWZXFoaWFYRzFxVlU5UlRRVXFnVGtpU0Z0dTRaRTM0WVZMQnRQRHJOQkdLNjJzSklnNEhuaVQ1c3BCWVgybHlTbXdJOVdGMTRCejBxa2pqOGltaWtDRkdDNXBLQnZuVFN2dnZQUVdFSXdGRjA1SUhyYTRVYW9LbWR6eTZtdFFRMkgwWEZia0ZtaXVzYWM2cUt5RXpEcUphQ1JnYk5ERUtQVHlLUU1EZmdqQmhxRWdoL3drRzBMNGdVUTdHZS9aZ3hDR01zbWx2dGVLb050dnVncldiYTlZeVNoUmpUYnlKV29GZFpxS0xBS1hOSnB5dEc3dzh6SElXVGJ0ZEpZaHM4SFBoa2VyQndETFVMb3NJc3p3eVp3dGJKWnV1NnZBTVlMN0VNOUJEU2puejZTaUc4RjNManhiTmF6c2lGRm8xazF1cVhlWGVPai92V1hUaGdZVGlSbHpWOGtJQUMyNDhHUE1YdE9YSzZhOGNqSndjanlkM2RPd2NpbzhxbzZsSHN1Z0N5OFUvdW9IVlN5Tjk1Sis4NjA2eEhwRERhWGdSb3Z1cHdJdE5PNHZtV0lMZHFhMzMxYnV4WnR3RWt0WTI3RHBwbTZGUjRMUnd3ZXlyOGZJM1U4MjdmZjAxTGZiSk1oQ0JObThuM3RFYXJ1MmhPMk9jKy9MV1k0MmFEZitERFRENllyd2NOL1dXMkNvRUJzMDMwY3cwRWYvOVA3dWhpd0VFdHY3a3hzMllLdXU5UXQ4NFl2YzVOamtuUE9wVFhPalloK3EzS2NxK0NXcGYwSUFRd0E3aElrbWJBQUFWZEJFTUVnbWhCSitEQXNzYUFBSjFySEJEeW10WmFoN21aZTYxcmdJMEN4M3VsTmcyY3hta1lPbExYM0Q0NXpiLzQ3SHVoYXdvWDR0VE9LMEdHRzZCT1JOaHZ2aWwrUEFGcllFNmpCbk9ndlg1WUxuczJJTk1WVXUwSjRTeHpndlFHQnBTMXlUb3IvK1ZiTUtaSXAzdnlwS1dod1lxaUNlNjRzdUFBTUx5Y2pIYVNsQWNWSDgzcGphK01ieHhiRlRNd0xlRCt0b1IyTjVib0l1Z0VPSFROQ0hHdlFEZjA1MG1zZ0d4UVlBSm5FVTR0aUFHbzdtaGhQZ29ZYTNxMklDTllWRjM3V3BnVnZzR1NOenhMbk9DVzArOFlGUUJaZlZPaVlsWUpUME1nRVc3c1kvZkUzUEFzRmdBaUJNd0NGMkxNRUZOT3pPR25HSFF6ZGU4WkN1UklvRGRLQ1RUOWxGYmFGU254MXJxUjBGNGRKaEVLS1FDMExCdkZtWlFBekczSnJxZEJsSU1DM29nTDY1VHpWekdQODV5UzJRZ1dreGhFQU5VWXBxaElFeklZa01jc2F5RjcrY0JqRUhjcVNwVHRXKzcrREJCUmpGS0I2RXdZUTBwQUVNZnhqQkNEWkFnaWJJWUFUUWJKQTlUN1RHZktySU9xalIzWm42NmMrN1pIRXlBODFwVG9rUUJLZ0FTRGtlV1NnNFIxTXVBN0ZtUjlwSnFsSlQ5Tkl5eGRTTkxkcVBhSTdUSC8rMGlRaXA4SUVQU2lHQnJ1cFVwNi9JUVNCeThjcWRlUVk2UTgzY1g4VDUxTGJLbERTaThlZmtrRU01b1BLd3JCRjV3Z0FJSUExVEhNSVd0Q0FDRWJicTFhL3ExQWVkUUlOUDhXcldzOUFWTkF5TjYxN3k4dGk2MnBXeGpNVk1BRUJ3Q3hwTTRBWjdyWVZmQVN0WXdrckFzS2hOaFFRWUlBZVhZQllpZG8ydGJEbnlXcEgva0JXelM4bXRUUGJRQmRmV05xR3pEZTVkZitzRkF6Z0FDYjR0cTI1bDBwUjBVQUNoeEcwc1VDdEwzY2NDTmJwdFdtNWIvcUdMSlVDM204TDE0V2NpMjFEU3JOVTA2RTB2Y2N4TDAxNnBhWWMzeFc1T0V2SUJ6UHhqQ29SQXluUWZtNWUwM29nMHBtbXJkVWlGSFlsU3NjQmhXeEdMWnZxaTk3Wnl0c1Q5d2c5WThaWlJvQUlOMzZXUk53WGtYd0M3RldqV0tiQlN1WFBQdDZuMHhDc05rNWdPck9EaE1KZy9kTDJ1Zkhzb1hpNFNDSUxtSXJBdDdXVE9lNTZZbnVzYVVRdjhNU1ZaYlFDYXVveVBpbDFLelgxYXNiMlNlOHhVWmd4Yk9zNHl4NDdzTWFwYTBBaDNvSUlSY0dnRUlIY3BaT29CTGhreW9CY0FnckczTGlWWi84bGhZbktMcmZnaXV4U011QTVNbVBxSTk4aTNJYUFGSThDRXRNd3dBbjRRNmttY3hFSU5mb0F5MGFrQmVrOUxYWmMwbW9ZbGJNQUR3a0NBTktlWllNUHN4OEVBYlZPTkUxYXN6bEhVWVMxZ1JCOVhQYXM5dEFBK3VCcGtHMjltU010S1JpM0NrbVZmU3UwMkV6K0lsd2xJUXp4WVRXeFk5Y0Y3c2Y2WHBTREhTbXdhQmJ3MVJsOFhneWhCRTFNd3lFWDBaUUxZb01GaWU5dERQVUJTR2lVMVJUWldrOVlEQzdYQkZMbElvckx0T3IxR0o3c3U2S1RYa2VEYitGYlBDSVR3eEhFTFV0azFLMlNVbloxTjZYWkVRRUNrZHJ5dmpWRi9LR0FQYmhBMHE4MllQNmJ0VDJTdll3TWd0bWVHWVo0dW52NytHc0J4S1BCL0lyTEtQUC9CM05xOGVNdlBMU0hmRzhEYXg1OVlQYjg5RFhzYmIxNDgraEFLTnR3TGpUTlVvNnlaRFVlQ25kektvM2wzdGQzSGhEMFcrMm9XMXhyUVZ6ZnZpRjN2VU93c2RqdzI4SjUvcTNJdzZEWjUrYzRuN2N3cDNkUVRGRUhpcEhEdlZSZEE1dnFUK3RTcGZzeXJRK2wvMzVaQjEwV09PenAzNWNGalo3ZWVxZDA1NDExNzNyNGNGQlpHd0E3UjlhQ0ptWFJhemEwT3VQbmxITiswSXplbCtrNFlXZytjNExjMkg5SjNUZmpZR1A1OWxIOVh0N2ZuaUt0VkhPT3dSN1FRcXFCcU1nWkFEU05nd1NsOExzL0ZSUk9mSXc5WXM4bjNiSXFNV25nTCsrTGhzNjJrVHViNytXb0FCYVJqMlB0QTh2M3JOcnNtNkl1ZkVVVStjTTlMSjJML0FncncvUExySVFsRzZuZklnVzl1a2l0UTdPcldZc3AxRFF0ZXQxenRxemUvL3ZYZ0JuOVVuM0hYUjBqYVoydmxNeGxJdDNLRWgzYnBnZ2UvMEhheEVnVjlBQUNHeGdac3QzL3lnbElHRklEVlZIS0F4MzJpUm5ZUGhHTWdKa1RiUVZIV3BpN3Z3MHQvbzBrSkVBeFZjQXRWSXdOeGNHaXhOekpZQUFpeDh5Y204RWNaeUg2ZDVuZWZaM1FGOTFyaW9uTHVCbEZIdFdPMFlZSW5pSUprWmtFV0VneVhGeTFtSUFhUnB5WFRRM1ZBMWpVL1FtNlR3bW5ZeDAvRzBZRzBGVkNHUUFRQWtHSHJ0bUVjRmhZZVZoMFJwWVJhbG5iWE5oNXhFeXRPRUNJejlHWW1VbUsyb1ZSTjVXUmlPSWJ3TllSSVlWZ1NZRkJxZUJHeFJWZmsvL1VWMHdHSHRTU0hURmhpbHNoU0xWVXAralJuTVJWVlVFWlZkalpselZGWXFDVlF6SkFGTTVCY1NSRmVqeEVuTi9aUVNEaGdrNGhnQ1RaZ2JlV0pVS1lwb0ZoWmw4VllwdEFLcEFBRnI0QlZoRldLQS9VS2tnQUVpL2lCdWZaTnJpZ2Q3QldOMGloWnV5aGw0WFZ5VkFZUnJPQlppZkFFQXJBQXhRQ013amhZWEhWYXhqaFFSUEFBQ3JCWXRkV0kxZldPRUphTnVQVVBsNEVLQWJDTkU5Q05vZVZYVUJCWTVFaUs1M2lNVnFBUGdiQ01aWFdOTWlhUEZHRUFRQUFEUHBBS3FiQUR0NFZYeTFXUkIvRUJCYUFDQmltUENDbEhDbWxjNTdBQTByQUdxcGhkRnJsY1BVQUdHeGxkSGRtU0hxaVF6SEdTTTdFQm5nQ1RLT2VPNy8vNEdjRmxrMm9oa3dQUkZQOXdBVjNBa2JKRlhmMTFsRWhKV2RaRkZ6eDVGQmE1WGFnQUIreUlheTVaRlk3NGpPVWxqWEFsV1RWbGpWVFJsQ0tSVzl1bEMvbXdralRXa3RYMWlOQVlpUjkyaXpQVlhnNUdmSGNHbGhQQlhQWDFEMCtoWDNhVmsza2hXZVlGaTZnaGk0STVtSUk0Tm5BNVY5c1hHVlIyRUcyUkdRdndCUlBaR1djMVhsanBoZ0FHbUpLWWhBYTJWSndaaUlJWVZRMVdWVHRKa1FKUmovOHdDZm4xVTBYb2pLSnhtV3dWaTVxcGhCTlZpWmRvaVN1bWlaejRaSk9GbUlWb1ZUT3lBaFFBQ0VPcGw5R1dOa1AxaGpFbGl5S1dWSE5vZUNvVlNXN1FCaVN3QnlMMUIyRGdVVXdnREgyVFVZcGpZaXpsVXJrWlBpLy8xbUM4bVpqWUNKT3JDU2ZnNUZDWk9Za2pSbUlMOG1OQTFqZTE5eXFNNEh0OXVCdVp1SW1vQVpvd1psT2lTSlFndUo0aUdHS3kyWnpPbVV2enFUb1dZZ2RPRUMxL3hEWDFWRU1pWngrMVdKZ3Q4cDlrV0lEeXhXNWxsM1NIUVdBSkVwODBWSWZwdERyVjR5UWFJaS8ya2k5dTlpRDVxWjl5NWxTUTQzbGR1YUZseUpJSFdGUWptR1U5SWdJdW9BRE14QjVSc0FGTWNDOUYxRXY4a3dCKzhLRDA0Z2JKRUhsdE5pSjhLRVZmT0J2OFdhUHYxNXM1Mm82eDFHNlpZMVRWaGlvdWNBSlU0eXJzc0FGaThESDFobkdjSkE1end3SnNLajFUU2lGVlNxRXJkaCtIWWFOekZYK3Y1SDMvZFhaMm9oc0l3QVJEY0RST0FBaU1NR3hKLzdRQmcxSnhrcGNrK05NUEFGQUFhY1loTDRCc3lSWjhOVHA4UXNpaGZ6cDY5VmQ2TFdkdExsQUhGamd0YXJCbUpRTUFQekNrc1hJQWpYQktxS1F0Sk1lQmN2a1J6UGlsWlZkVVFkTm42R1FCb1lBS3FWcCtkUkFweWNaNXUrS3BCRWdaemRodXZrcUN3RXBFZldNQndGU3N6N2NFdGFPQlFBaC9vYWVhZ2pkNEM2T0FFNFI2R01JR0RJQ3QrQVlCcjlhRE5qUjBxMVJyelFwdEh2cDlMSGQvS0tpQ1RCSU1XQUNyNnNwSEpHQUJRYWQ1c3VaK1hyR2hrbG12NHBwOHlwZUNxWGQzRi9DdlpIUS9NclE0UWtkRkFZZHV1ZnF0YmhKdElRaCs1R3B0RGhzLzd5STNFdHVvV0lLRjhoUkZ5WnF4WkxPeHVucVc4eWRMWnRkSUMvLzNhOHpYUHkwWUROZWFSS2lnQm9BQUJtSWdmU1ZVdE1HZ0NXSUFBSUFnRGhqRFIvcUFOVkszZnVYMmd6bFVkQVRZcFJFaGVJRjZydzNqTUJYU2dzTDZBaVNRQkh6VUJLRkFneldZdG9QQ0FrNjZQWGtnYzFFN3NMYXplZGlIcStZWnM2SVhWRFJMZXVNNlJIK1dCb0RRdHQ0V2M2OVhURGNYTW9PQ1JLTFRCM0FYdC9oSnNHQWpnTXc2bDcvRHF5Rm9mNC9rSXlkQXJQajJBM0FYZDVGYWQ0YzdQK1JYT1BFQUNGaHdhSTVyZmNDbnJOWTB1UUMxb3lDTFI2M3liWThYZFRRM2VXYm1PbmNYTHdHRUNSQ2dBQzM0ZjcrWFNpNXJ0VmVidDFacFl3aTRPVXMzSGdmd2JYdnd1Vm1TaFZTWHBKVFhwazhpQkxYYlI0eWdBUGovVXJ3SU5JaEJtTHlWTzdOZ0NrRy8yakI0Y0FMdFJHeWtBM201VzdIWGk3MzBwck10R0FrNXlHb2VnS3l0dTJ6eEtxK0l0S09qeXJDWkt3TENNQUprKzNUVU83KzlkNzAyeDd2YmxuWGVaa3BlVjdjYXU3SG5pNzRmcXI3d2hxK0g1d0lXb0FBT21FUUJVRHE0cTdKMVdtWVJiSGN0NkFlWFdtd0hRS3ZjT2paV3kwQmFPMjJiYzBjSHZId1dwQ1FqRkFvRjRIU0wyOERWcTdzdDdNSUpnSGY0bHFtUWEyNUVKOEE4Rks3STU3d05XMEhaZXlnc0lEdG1nTUl3WkxoZ0RETEJBQXIxK1czeHdBU3cxcm8wS2o0Mytxa2VlSHc2REdMaDU4TVAyNEthY0thaTh3T2dBSG1nYTdpYjlEOFN0Mm95VUFBQVlBY2FCWUJxZkx6dS80V2pzR1M1UHFOMFY0eHRkYnpFWWhSQWhKYTZmRnlEZ3dJS05WQmtHL1FCVHJBSEFJQUZpSEl2S211bmlEeTFkV3UzaVNtekhHeXZmVnM4N2JOTGxDY0VOWEN5U3RRRWNUQjlwN3lIRjh1cFlEZUFWNHUzSFR0NmdnckM1cG9rYk5DOXVCeEFrOERMdmZ5NFQreTZiRnkrdzB6TWpDaXFrRnlxMUxvcWxkek1BVlFEVUtzMXFQeDcvNnZJYmV6R3c5VjlqbnlFQm56QUQrSUNwUXZPU3NRSVVscXhySXNiTjJTd3lCdWdPZEhPTlJ2TFBld0NVMGpQWXlRRmJBWkZxV3k4R3ppQS9reWNlcHUrZXlhdEZJVUhseEM5QnMxSGV4QU1VanROa252RDhUVkhYL3A5eHd6Q0xzRE1HYjFCVHVBUEZqdk5ZY2pLNXJ1ckVRMVpWLzhteDdaMGF0L1JBbW5ncjFUQ0F6MVFCM2JqY3lMak1RQlF4aW05SGlad0NXbDh6ZzN0cVg2YVNBUXNUbnhXcW42R0FCNVFBSENRQnB1QVViMG51a3E4YlJFck9tWndBVUd3cGg0amUzR0FCSTR3TFh1d0NhY2tUZU5idFNCdGlBY0pncEJZb0ZPOWhEK0tUaW1vZ3RuYmZKNlVNZTNBRDRWN2NXd2dCaHV3dng3U0J5RmlwV0pDVFZGY3Z1ZnBwUU42MTJ3Vmh3bFNpUTJpUzExaWM4RkF3ZE5TaFZmb3dDN0tOMy9tQW5hd0JDU0FDaVRBQk42RHA1eEdvOVlrekUrTldlbkp2TzcybW5GSWlmR1pMQ2M2YnhnTkxhSk5QYXV6aFNkMlQvdEp0VUNZenBTTEZLbndBRE1RbWNCMTIrcTVsaUk0VHRqaEc4MnBvRGdMT3JQLzBnNzlJTENtVFU4b1pwdVp5R0t5elUvOWhKak5mWWdDOVFvaFlKWlpTeFdVbVpXWVNVdmtsTm5uNU5zSUVOeCtVaTFBZHR6SWZadFl1b2x0Sko0Mm1zN3FUTmM2OFZXdkFBTlRPZDJPSlZRZHhwWWhLcUw2M2Rzb3R1RndOdUNBNkprSDdtSmJhUnk4K2RCbWFGaGhKUWZncWxBVWJwbHJCWnRJcGQwSVdwdTg4ZUVHL21IckpWWGtxWk5mK1I4QldRcFdjRkRCd29wb2RadzhPazQ2SnB1ZENlSnUrWlpjS1ZkeEdZcE1XVmJsQ0pBb3ZnTmRJTjNNZ1pOdGVOY3YzcGF5MkpZeU5aNjdXWjQ4SG8rWTFZL0RtRlUrWU9VT25nTktvT1Y0TmVHc21aWG45Wm9MaG90eFZZMWU2WkxaeUZmaEdJekRxRlZ1L2xWRVlBTU8veURmQmtqblJmN2tqazdpWm42M3NVV1hFekVCcXdCYUJDQmF3UmhZV1ZYb1h5VUJENjRFSlRubnlwR1RwZzZndlVqcFNXR1ArQWhhQXRCWHJVQmEvMmlPQVFucUlhQ01lRWJrOEJoZXFqNGo5YmhadDVDUG1LNFNwRUJhV1ZXT0FibFRWaEFFQmpEcXBGNlZvOG1UQm5BR01IQU9yL1dUamNucW5uVUQza2dBeEM3cmhFN3J5UzVRcVZBS01BQUVFVTVsMTlqckVaRUxLM0FDWlVBRXBUQlFFU25uLytHVFBwa08rWkR1N003cllHa0VnWUFFclRBQXJWQU1KRG1QK0s1YmduQVR2UTd0dmlsZlJyQUNRVUFFTFlId0NTOFRqckFFL0M2Z0RqL3A4cFVMem43dkY1OFFBVEFDaW03YkhWK1Y3STRVSTM4UUtSbnkyS1hycC85K3pUMis4aVBSOHZUNER6UWdsVHc1V3pOUFhSNXY4eUF4OGsyaEJsOEE4NVM5WDN4NWxLZXVIRUtmRWZnT2xIdFFreDBhWEpYVmw0K2VKbnd1NVRYLzlIVjVrbTd4QVMrdzhWU0psbGZwWDFtLzUxRU9zNkRxOVY1UWtkc0ZBbVc1NVE3UFg1WDVYMXFaOTdrb1YzM3VrVzZ2Vzl2RkNuTS81QzVwbEhkUFZBNTEzMjZWNHdrdXIyemY5cjNPRmxBNStDdGVsTytvbGw1K1htTGVsam11b1RoYTJ3bzVFMjNSRkdNUDBVcC8rWWVQK0YvdVZvU1ozdmt4NGxyZjk0b0prd3JSbVArd0IyVFB6aXh1K0ttditxc2ZtQU5HaThKL29hNnZHTlVjKzdLZmtMK0ZFTGF2QmlwZytteEltYjN2KzRwdlZMdTltVXZ1bWZseC9Jdi9uUHlwVHBvRWNSazYvd1pJbjgzMExmMWMrWmZWYi8xSnpwazg5b2Z1cjJ3WHlpSTZqdnplUC9zbVdacjFoUXIvQUJBYkRIZ2hXTkRnUVlSZUtDMWsyTEJoSm9nUkpYYWd5TW5pUll5d05Hb1UxYkhDUjVBaFJYSWdTVExXeVpPcVZLNWN1Y3psc2dneFpjNmtPZk1sUzVZb1MzSVFHVkxVUm93WUtVb2tHdEhoVWFRT0V5NWx1cFRHdjM4ZlBxRDZSK0JMVTZ3S2t6b3NHckZpVUlzYllYVVUxZE5zaFowbFVhYkVxZkpsVGJnUlJNeWxHN2VteTdZNlM1NnQ4Qk1vV0lvZHVoYmRXampyWVlRcnR2eGc5US9RQ3NSTEN6TWMvRFhvUnJKOFE2WTFpYkp0UzVkMjVkS2Rpd2NCQWp3dVZMdG9nY2MxQXRKMTR5N0xlM0l2LzkrT0dzRmVERHpZNk9TamtZVVRIRGo4SUhCS1hTMWZ4RnhXTStlMXNUNkR0aHViOU9rV2FhTG80ZDZkdTlRa1RoZ3hTckhoeFo4VGVHTGZwWjFUTDBuY2ZtSHR0ampVZHlia0RJM3ZOejVaZVlmTE9IcHVwN1dtY3l1MDZxdzdiY0VGWFZEQU93Z2pqQkFPRjA2ejdxN2FZa2tyUHJIb3MyK3cvUGdUTVN2L2lGcU9FOHpPU3F2QXo5NUtVRUVHR1hRdHRUb2t0RkhDRDFpd2dNRUxhY0lMcC9kNDBreSsrUUFUREVUa1JsVHl1TUtLQWpBakFYc2lrQzJjWElUTE9ycGlsSEZHTG9PQjQwWXdJWFRDbnhsajdOR205dHl6N1RhemN0UE5TQ1FuVzNMT3JaUUwwTG1ST3BPdVNwaml3bElFTFJma2NsQThXakEwR0NUQ1ZQKzB1ejBTR0ZUTDlURE1jS2NoL3hMcVNLS0FtMVBKSmsyRUVrK1FwdVR6U2l3RFBZM1FHUTFWZFZVMkVsMzBWUUNDYVkxUU15UDFNYzJWZ3NUTjB2b3dsVWpPVGZtcmM2SW53eHBMU2c0OFk2bFBtaER3SncwRUtqUVYxVlJYVmRVQ2JMRnQ5VlZ1MjdIRGdsVnByWlUwOWpMVUVMNDJlZVhrdzkrMkNyYS9wRXdzRmtWWWtFMTJUN2Rvb3N1Rk5BN3dycDBSTG1FTlZXdFh6ZmJnYk5sZ2dGdUc5MkFEMjRMRjVkRldtWDVVazAyZjNoU0tNTVBlald4WXJ6SUM5YVBPbHRVWFVCZitRQVhNSlBaZ0lwZ0VyRVY0Wm13VHNGa0lmUmpXV1lwZ0VMWVdWVWdwamdsWGxkWkVOK01pZWVNNEtZOFJBeG1pZVkvTkUxK1ZUbmIvNFJJU2RMN0ZaVFlTb05rQ204TU9XNGc4ZE5hNUNVMjhuamxpaVJjVU9nS2lqZTdKelVzemRiZHByT0tkU09TcHFXWldybWpSNE1Gc0NIa0FCQXNoWUJiYjVtQ0VFTUlQS1g0Z1hPY1JoQWo3YTdZZmxWRzFGa1NRTk5kejU5WjRYVi94WXhwdnB2UU9tYm1SUzI1cEpqeUVLV0J5TU50QklnNUxncW1DZ1I2Mm81M3dBS3JvZW5ITUM3WkFOVHVrQU9TQWRicmJ3SVc1ZkhRUDQ3NUdMOTMwNEZCUFNIV28rZDdzM3RkbEVrRVlmMzgzLy94WG02aWhjY1hGUmppQllJTHBwNFkrVEFqekF6U2c5OXltNllVRXlhK04vZXAwMmlzSTl6SVJ0ZGFCTDEvaUU0RUxab2MrQ0Vid1J1S0lsZVhneHdZMlJBSUFmVEFENGRxUi80Yk83VzlvL1JNSkFKVW13T3dSOEdrSDlGNm9GS2dLWm1VSkQybG9uZ1J0ZU1QdWtHQVBNb2hnRHl3a1FvdXRxWVJKVzVmZFVvaTZGU0t3YitFYkRhQk80NElYNEZDS1U0emdDUFJYTVJKbUxJQVFHYURIU3JTNnNDU1FTakdjaTZBS1ZUNHFwbEdOREVzQ0dLQ0h4VnhSVDJQczZpS2R2dGc5MWszTlpESEowcWxjNDRKUXJHeU5neVRramRyQUJBUlVMRTNuOGwvMWtsWTZwQVFMT1o3SzQvZjh4a0Fub2laVndSaEJJVDM1U1Qzd0FGcEF6TW5SUHZLVExXSlBLVXVhNU40cUdTb3F3UkNUWm5TTm9jQ1dOVkRtTW8xUzBCOHBpeGE2LzgzUmlLc1VGbkNjMUVLU0pZczZmQ3lqSHd0MXJRUlVnUjI2cE9ZTkZTQXQyZi9BTFk2bVJPVUp1UmpKWXQ0UmovUnEzUmhuMGtkTlByTUZCMk5ERGFyNVR2UUJ3QVdtK2VGTVN0bElFeFlSaGNRVVRpdGRTYzd2S1hPQnpNd2tsNjZWclFTdzRZSHdaS2pPd09Bb2VzSW1laVA4SlRlSjZLdTdmVXljTEdTTzFKSnB6bGs2ODZBMVl4d29tdEJRbENvS0UxS0lXWmwrNkV0VjJHYUl2TUZvSFp0aVRFb2FDMVN1a3lWQkMxcXQ5OW1NRGFHUVJVcU5LaUZVaEVKV2huS3BSUGtYVTJDZVVwajc1T2ROTy9WUEZJa1JYMlRNWkRwSFN0S0VzdUNvWS9WT0VxclFNM0RONmpYMXBDaFVMWnJLamxuVmdPUE1xaDZaaUU2RDJoS2hZV01ER01qNlZ6T0lBYTFwVmF2Ykpxck5pczcwSXNNODR2YVNxRVJMYmpYL3BPbFU1OEhFSmdRQU5EUThKT2hEQWZid2d6NlF3QTIzU0trTS9BQ3pnekcxcVlkRmJFd3Qra2pHVnRVZ1Y0VWFaRjBJMGliU3NySUlEUVliaEtBd2Fqb0NFR2QxWFB3V3g3akdKUzRVZ0dnSE5kVmdYSnVsdHJBdmhhTmI4WG5SMkRaRU1uT05XcjBpZTlkbVV0YVd2UTJHR0lKUVAyb0dBQkIrU054eDNmdmV4dkZqQXdINEpEc0VlN2xzcVdxMWgxMmtLYXZuelc5bWRMWUc3TzVPWDhoVlFiWEFCY0hZaFBLYU1BcUc5aUVPRm54dmhTMHNoRGowd1pNWEdGNTA4NnZhaUdhenY0MnN3QndoS1dDQ0VMaFlVVXFtUUh2YXhOVDRBd3c3UEdybDJrZThyMzBOdmtMb0pDRnJRR0hwcXBXZTJXeHRWQjBKWUZVMmxydkkvMFNMaTFWeFRoSHNvYWhrNWZDTlBaeGpMRnQyY2IyOXdDQk5nSVgyQlhtL01CVmlNRk9aWkg0dVdhY0JsU3dmRWNDRXdaRVZEQlRHYjVidHJPWEwrbldOWTBCR21EODhYWW1TR1dQZHJFOTJGekxnbytTVVhrdGM0RnhjZ0FheXNrTjRPQzVld1l5blk3R3hRUXkrVXlNUE5pQzhoLzE1di9hc0tJbW4yaTV3YWlYUi8yUXh5WERyNkM4ZE5SNlRkaC9OTEgxcmc5RnNjWnFlWmlGSDBRT2U5UXpFaGlXemtRbXRUMVFUazhESTVDa1pYYURobythQnptcnpHYTZ0L2RXOWppMnp1bVFFQUN3Z3E3VUd1cnBHTGpGc0RVMkpGQ05GMFI1dDhxdEYwQUpjcHZTNWxBN3l6Nmlsemx3SGxhOFFnS2NhQUtCZzZyYTF6RkkxZC8reXRhdHFybUNWM2MwV0h3SXVNWWlqTW1EYWE4dmN2ZkdOYmJCZGR0c043Y0VKS2pUUkh3MzhJeVkyZExwWERjYTYzcmJOY3BsaFBJNGFpZzVmR1dJVnQvakY5WXBuK0ltQnRFYTFvcUJKZk93VFoyL1pyMnozeWh0WUk2TitnTloxbm5tNGFqNm9TK004R1B6b29GRmY4RWFCRy92VUFWN2wwTU00a2xlbmJLd3dwemRobmY3MFdzcE0zem5mZVVyVFUrelhJdGxkYWw3MGQxOE1PSDcxNFFNb1JjTEVxMjN2cDBjZDU1aVZkUnJVTTI2dEY1enJTa2tpc3cvTXdBWlpRQUdNZ0djVDRGZnJlcC85M3BhZTJlS0UwR1dqSHNCQ2lJLzdZcWw2Y0srbi9MYmcvV2tMYkthQWVJT3k3MlUzdTZYemVtdGQ4MVVLWXlWQkNFbi9mMTNGbzFrL0NFODRHRnZOY0dicWRyekJZTUVGQkVsSVRMQWc1dFRPL0xYVnZuYjRZYUhxUEw5aTFuKytkZUVmbXZnUEljcW5MTWw2NWE4elc0MnJ3Z1k0bmNZUGtCM3pmN2YremJFL2RSNk85US9kUjZ6SS95djNWQnMveWxDNGNqSzY4S29XOVFPcllFQUdRQmdrZmZDN0hNTzFMTnUxVUtpaG8wSUZ3NE03NER1ekxxSXRqZ0lvbFZzSktIT2kyOE96WUFBRkp4Z2tOWWdESzdzekZ6d3VJZGlEdjBLRkFoQUcyQ0M5SVhxa29FdXpGZnBBaldBMEJIT21aOUkzTmhBclFuSVlLNU01RndTcnk4b1pvMnFIUFZBQWYyQU5FUU1kLzdLZWMyT1N1V0l5azBBL2tiSy95NUxCUWlJQnhMRXc2c3UyOTJLRFlOZ0Fodm9BL3lmWUFERHdoMkFZbUlraHRhTHhMNkJibXNZU3dBRkV1WVY3UElLaXBhOEttMkR3Zy93ckpFd29BTVJKUWpNVW04WUJCU1RvdFZ5S2doNWdnQ3BJS0dFYk5zTjZLdGY2dmpNTFAzUnpMSzg3UGllRHN2VERPVFlBdlZ3eWd6MWdBVkFvTGthTUg5L1N0QVpJUVYwQ2hNWlJ3elBVcjNBakYrL0xRUTVFTVVSVE4xYjdRd1A4cWQwaXFXQ2dQSlFDQVJsZ2hBdndyQUxvQXdod0FrbDhKNG1idjdNak5yZ0RSaVFEUmJuaUhzc3d4bU1VeEFRRUcwMDRxYjhhSzJtYnY3VGlFbUxqUkVaQ21rK01xOVI1bWhValJ5LzBLdlZMZ0VnNHhIVk1LUUNnTXpFYk0za2N0SXU2SG5zTXgrSWJweDg4djRFYURYTjBQVEhZdm9CRUtmOHBJRWhSTThpMjZrVEZLclJ6Rzc3RFdDSEhjemRrZEQxcHVraWpjZ1IrOExPbWc4ZUFpd2tyOU1SdjFKUitFc2VTTEVjL3NnQWFVc21qNm9IaEtjaUljcXJmRXdrc0RFbnhHNDVSTkRBWEMwTFVzSUJRY0RtZlBDb2tDTFdYNU1naUk3ZWpQTDA5MUtpVCswRFZLem92ekE0TG5NcVVpaiswNHNVUVk2MUZTcnhnQkJZUklVYmo4NjdWWTcwWlNnS3pKS3NtT0FYQ0dqTU5wRWNBaE11NGxFdXdaTGQyV3liQWFRU0F6RXVqMm9PbHdzb2lROGpnQTBXUlpLV3Y5TUUvYk1xWlFBQmhTQUhHL0t1SGFpcWk5RDVUQzc0a2tTVEN6QVFvWWJTN2U3YzBhSzdQTkNvWnNJUFdxTU9pRENiVEZNeE5TVDNEUkQ1bWNnR2tpMDMvbEhxZWVMeE5nZ3ZNQUd5YVVleE5RRXcrQjRvZ0tPd0I0ZndkS1dnQmNSczN5VVRPcm53WDNtVE9XUHFiMHJpRU5pQWNIcmlBR3NBQ0RGS2Mzd0lEWnB4T2JpRUIwK0N2ZTlwQWtEUzR5dFNleHVzb1pQbk9FWFNRc3BRUVNxd0R3ZW9hbkx1c1lBQUFOWEJQUldrSFJJS3BUaXhON1R3NEFpcWcxQ3hNdW5RaEowTVFnbktCQnVRT1ZHaUNEVkNBUm5BQnJ4RzhBaFVxcXZPa2JpQUJKRGdyU3dDRklIQ0RHNElBZ1JHaDF2Skl3TFNJTEp6UVlXeEl1bnBJTnZPYnZ4a05CWnVuTGJrOWpFTkRuRkdqQzFDQVNIQ2M2V01jSVlpRUJyQ2YzNG1IL1J2TnJNVERyVnk4KytSUlBrd09ZakcvUEhtaGlQU3ByaEpDQkV4Uy83QUpodGk3b2RtenNQZGhnMzRBaERqamxnTklnMTdpUk92eXh2cjAwcVFFVXdwVk1USXQwMWlDb1NGdG92QTYwalcxUDJ3SmhsQ2dMeHlxSE5xek5VT0JIeVp3UHpEQkJFQm9EU0s3VWYvTEoyUUQxRkFVMUI3MVVib0N3VEkxVTBRbEZYUmkxTFRMTnpib01Sc0NCS3ZFc2xzYmxPUHBoeGNBU0Rmd09GK3NyajcxMDFFRlIxUFZ3Z285b0hsUlZVTlZGc1Fjd1VYVnJWalZLelNDSUZ1dHRIQVJNcGlNa1hsaWdrWlFEeHNkR2x5UkcyTGRRZGs2MWpBVjAyTzZFNzVRQzJkOVZreUtWc3FxbGdSZ2dXZUlvR3V0UGMxcm0zRUpWa1VDRXY4YnVTNGwxVkpWa2x3SXB4NVVWckJJRVJWeDEwTnQxWnFJRFMwaGxHRG8wUC96d1VYQUF4cFQrWlBac0poZm1rZlJTVWc5M0U3alNJVWFLQTZsM0NpVTZ5akRYTlYzaFZkRlRWUHhhay9hR1FGd3U3ZU41ZGlPSlJxb1lpUVNPODY2Q2NsZ01ZUlhDQUdVdlVtVnJhM2RFSXVSV2RWN29ab0RpZGpyaUpIc3dFdmFlWUZnNEZkdTlGZjI0Tm1QOWRtekVOVS90VThKWFJKRE1JUlNlSUFaT05pVXhhbktXRmFXell5R2RkZTIwTkI0RFM4WDJEaXpxUU5weWRrejZWcXYvZG9OQ1Z0MVlSZXkvZElST2R1emZZVWdnQXg0OGFlM3BRK21IUkE5cWR0RXRZNForb01YMklBZUdBOXJsQW9ia1FVcDJKR3Q1Vm8wQ2R5ZU5ScnFDVmtpNnBXdXNNbWhWVnhEWUFZVVVJTDl5STgrOUkzQWtGeU9hRm9NZmRyL3V2V1RVdkdxMVpnbjB3QlhMTEdMbXpDUUlGbmROcEdQM1RCY2dpM2JUWkZkeFNXQ0duRGN0c1ZkZGIyUEU0bGIzMjB4NEYyV1JEMlpQMGxlMGZCWWdHM2VuK1VRZFhIZE9Gbkk2clhlczAyRkxGQUJ0dDFlN2wySSsvQUt1RFdXbHYzZGh6MlE4aFdObloyTzZPQU16U2doTnhrZE9QR05FTUViK3BYZFYyZ0E3WDNjL1NVLzcvM2Y1cGpiOFoyT2x3aGhFUjVoQTBsZEJWN2cvMmxnQnphUzYrRktZWXpkQ1Q1YkNTZ0ZBRGphMjgzZ1pNVXE4UFhncHgzZ0V2Nk1CQjdjQlNZTHNXaGRENUhlMStYZUNZMWg2MDJGQjNnSEcwWllITTVkSitIZ3NRamZKcHVTNk5oaUxtYmY5bVZnSXFHUG9BaU1Gb2JnL1FWVENVaGovd2xnNHNWRkFTQXdBdVdjWWlvZTB3QzVZaFRtRER6T1l4UStKU0l4NGpGRzR2NmxUTmpsVVIvd2dWSlE0elZtNGxjb0F5WElYL3pNWU4yMVlqdmVZMHFPanpBV1l6SU81SkdWNDRJRjAxY2dBaUpJQlVOT1l6WW0yaHhvNUdQZFg5M2wzZDZ0NUNGV1lURW1uVEtPWDA0bVdSNGxCVnVBZ2s4VzVVTk9aRVhlZ1RkRzEzUzlURHBlMmlMdVhiSklaaUkrWmorbXFWbDI0Vm8rVjJIMmdtSXdoVllnQlYwT1pSOVE0MUoraFRXQTRtbkczUTMrWDFZdTRsais0MmMrM0dqdTVHbG1pZ0VnQUdrb2htdk81bEgyNVJpdWhsU3dBZ1c0WUZOVjVmN2QzWE1PYUZsTzUrazk0M2FlazBTNGdYZXVCVk00QkZ1Z0JXM3U1VkpHMi85VVlJQW9CbE5JMW1SbEpXT083bWhBcHVVTVBtanRvWUVKV0FXRkpnQ0d4bWFJRm1WU25taWlQUWR3UnRjcDFtaWE3dDlhRm1sQkRRQldJR21GRm9BRmtHZFNvSVZQTHVTV25taEQxZ2NEY0dTTXJ1V2ExdVJveG1sMEhRVlUwR21lSGdBQmtBWnJmbWhRcm1lWFhsd2JBQU4rWHVwMUhtdURobXBobG9wUjBPbGJLT21UWnVoRGdJS1Y1dXF1bG9CWDJJRjNDR3NlSld1OWZtR2NOZ0FINEFaQi9RZE1rSXFwWm9XMVR1aDNydWEzaG1naXFHZDdMdVZTV09TN1B1aTlmbXF6UG9oY01BQUZ5SUpEa0FTbDFoNm9FT3dQa0dxcW5vQWJlSUxFTmdXVjNtcUo3bW9aZm9WekNJTVYrT3h3cm14cHZ1eUNNQUFEUUlNSGVJVXordDBCMnNhYjBCYnQwUzVzbmtadEFxaG1YR1pzb2k3cXVYNkZCd2lDUUxobzNLN3VwakVBSUdpQVRpQ0NKZ1p1UVEwSUFDSDVCQVVGQVA4QUxPc0F4Z0R5QU84QVFBai9BUDhKSEVpd29NR0RDQlAyMkdMQWk4T0hFQ05LbkVpeG9zV0xHRE5xM01qUjRvbzNrMmdNS0dacVFSWWpIVk0rVE1peTVjQjBieHFxbkttU2tzMmJPSFBxM01tenA4K2ZPV2tLSFdyUlpVSk1BZ0d0SUFvUnFOT25PRE5KblVxMXF0UU9XTEZ5MnNxMXE5ZXZXN04yc0VvV0tpV21hRG02eFBUaDN3YzRNbW1hdlVtMjdsU3hIY0RxNVFxcmIxOVJnQ3NJSGt5NHNPSERpQVVEOXZzVmE5Mm5hU05ISk1qMnc2aC9mK0xLQlZvM0sxaS9zQUFIVG95WWcrblRxR09wVnEycXRldlhzSmZKbmsxYk51emJxbGFqUHJ5NHIxZkhaZWZpbEV3YzQwK3JXcnYrRlZYNjlPcFl1RjNUamtDOXVuWHJJckpyM3k0Q2dmZnZDUEQ0LzJPa3A3ejU4NlBZcWJrd0FrMmFSbmhhYUw4ZXdmWnIxYnNOOXdZTDNLN3dzOFVOMVJOeXlvVldtSFBRdlNZYmZkbTFJTXdHVG94d2lRdmdnWWZIaFJobW1HRUxISGJvWVFKaW1IRGVpQ1NXZU40ZXdXQllJWGZYTFhPYmJxWWxKZ3BqalkzMUdGQUJaalFnVlhueFpTQmhwckhXMm9MVkllQUNBTzJZcUtTSkpJVENSZ0lXV0pEQWxGUldtVUF3b0tpeDVKWmNqc0JHbEI2Mm9DRWVLMjVIbjR1dzRYY2FiNzc5Rmx4UE9YTEdZNEhNRGVhY2d0aDE1NTE0VG5EcDU1K0FCc29sR0paWUNXV1VpRm9RNXBqZnhlZUNDL0sxZUY4c2F4WTJvNXRWd1NuVVV3VDZXS2RnQ0VwWDNYYU5Zc2loQlpFa0tlaXFyTGJxNnF1QXVQK1FuWFZvdGtZcEI1YTJHVmFtTzZWMFhLZDhmUW9xQjBLcXNreWVldTU1b1llSlZpbk9xOUJHSysyMGVrVEJCQUxWMWFwbVlicjJsd2xQR3ZrRTdGWS8ya2xzZ3NZaVcrcXlwelpMSlJzOVVDdnZ2UFNXV0lBTEYzNDNIM1hheGpqWWpMQndaYU5VNEY2MDQxM0tqVFpzc2NkUzF4MFRKTVJUNzhSNk9CRUVLRUk4YWVqR1V3YkRoaEQ4TkNBaXhZQTI4Q1dZSEtybzNhelYzZWV2WWdFTFRKV21FKzBFN0Y5QW5pdXF3eUs0VUFESjBUWVJSekNHSm1yMDBVZ2JiU2diWXFnS3RCNU9VcGxvaHlvanNHOTlydDFLR01BeXoxendRenpkRE11QnhPNU1IUUpNclBNMHEreUlRWFNWUjRmcDRaanh5ZDJ1MGxRR2d3VVBUNXYvd0FBb1QwNmRjcjRyczR5MXJTOVh3UFd1WHZjS2R0aHpraXRzQlVHYXJWMnBDZndDeUMxcm00aEpGUnBMTGZqY2RKZGVON040ZDh3UDM1MHYyVU1hK0ZwdHVMWmEveHN6NDFOOTdZVzRkL1hJU1Y4SE1qeHFzaHUyNE82VWxpRHh0RGpCdkQwbDBuWkhIejNTVmdxeFIrdUNxaUdmQ05sbW5YZ0YzUTVNc09OTlFZNHd1V1Buakc3REVWeXViSWZISjJCOTZ6MkE0cnpvU2VjZlA1VkM2SU45cTNXUUZmZjRsYlhhd2V4MjNxS1pSTXgzbFdBRmIzM0RXMWZkb2hTTVB2enZUMDdZQUFDcW9JbGdDT0dESDN4U0pGaUFCQWl3NDRLckdvVWJMdkNDRTlqaFVTMlFIYTI4bDdqRjRXNTg1S3NJQXpQaEtmVkJrR2Q2d29NRi8rS0Z3aUpTYkFOQ2dOdm9NcVN2cTlVcU45K3pJU2U4aFVPZGNNUm1rZnRkdVNpbnN5RU5Edy91TUtJWTZUV0NKQnFOYW9RcjNBQUphQ3NEd2d4VHZQSkpUYkI0UHNtUnJWanAraUlUTUFDdGVEUmhEd3pvMHhqL2g2TEJrYW1KYXp4Y2J0eW91TnROMFNxUUljckI2cWpGeVhHeGkwTmlYL3RJWlNFTmhTbHBWWUxYSUVuMkFnckpMcEcwaTZJanhmZXRuK1RJSWIrcWl1OTZlQmdFb2N0c3czT2ZCTmtGdjJUSW9GNFF1SjhTODhlR1NPeGhGS3RLd2dzdWREVkZ3aWhYWFdHbEFvZWlnem5LaVN5ZThZcGZGRWEySU4zU2k4aktUb1hpWTRkZlF1c0F5VkFVNlV4WHRRcVZpVVgwVVNRTlZlbklSell1aDJneGhENUxVZitOTUdobUkvK3hpVjJ1TWt2MGJURm41L3FtSm5OSnFnczlpa0pNQ01NTE5uQUFPSmlTT3hnMVhEejVOWnZvVE9vNXFNRVZZcVFZRmxhMlVvN0YwYWRLVjJvSUlnUmhLWklKYUdjS1dzbm0yUEtiSHMxcG1wNXpxNUNLbERTazZRMk4rRVBGZTZMMGxhbndnUTlLSVlHbXNwU2xyOGhCSUhMeHlnVmVVNVkwMWVKeWdNclZrUXBWVjNzUkdGNEdTdGFUenFXcUZCa0FBYVJoaWtQWWdoWkVJTUpTbmZwVWx2cWdFMmlBS1ZyblV0YmU0V1V2ZUNscVdRTksySnVnVlNpakNBQUlia0dEQ2R4QXJiVm82MXZqT2xjSjFQV3lxWkFBQStTQWtzTVc5clAvT2V4UXFDcGFvNWpXSlh2b1FtZEZLMG5RdWhaQXJIV0lBUnlBaE5YL1Z2VzBMVUZLT2lqd1Q5YStsbmQ5RFM1WkF4cmI0dUNXTGYvUXhSSjY2NnZmQ25lZ1lnbXJqMEFER3RGWWw3clVCYXhncTNqVTRzNEVJUit3ekQrbVFBZ0JRUVc2MlpTdVZwZGozYTRheHFmZTVLbDhlUXJmbitxSHBGTTBLWGVuNmQySi9JQVZiaGtGS3REQTNPWk9Nb3Qwc21RM1F6cGZuV1p5b1J2ZFpFWXhHbUdPN3JTbjlyVWRXRXZxbjhMMjE4QjBwR1JORjR4SDZVQTRuQmwxcHp2WkdZd1JRR3NFcGp5bFJ1dnp4RVhtNTc0YjV2QkF6ZkpocStwRWJKYjBKcDd5Rko4L3NHNUpTUmpCSm9JaFBlUHBMMHBzVU42OE5zQmtNV25vblltMDhFZDdPdEtoaXZWTi9IMGxjQnZvUUI4T1djSXVJT0xFbk1BQVFEREMvd3dvRE1MSnpyak9kcW94eS9LMDhmY09DTWZjNmE2MVZ5V3pIYzBNVGlDdXF3VjJjTm9vU2RZRUtRakJlUjU3VWhYUXNBRTFuTkJQQmRnZXJWSkp6MmpHTVNqV2pHWHZFbmJISHhwYVdieEVWQUtTNFlaRnU1cFZmNURWRE51b1NrLzcyWW9BSFROQjZmVEFNK3N5UEthNlc1VGVGUW9RdlByWWdJcENHbUtvVVRSdGl6RGQrclJoZGJURDVJellYTUk3OWZzczBMd0U5SU1GZnlqQUFZNk03SEw3aVFkVlNJQWhtemhyS05yWGh1SUw4K04rak9DRENyblEzUkdCT2MxdG5nWThtbVBQMHgvQUU4Q0dZRndQZTR5d1g4QlJadVZEbnJKN2V0NWF0RytONjRqc2tJYytLdlhPc3VPQ0pmQWJFRWtjWnR5YUxMZjhWZS9nSlArN1JSV2N0OFEwT3BHR0VrZWd0SWRUUG5yWEVXZlkvcUYyWE1BRU5TOGFBQ0hISDZMa3hrNVBmakoxVTJJREMxQW9neHBjcWVFT2J6YXQzNzNLbWR2RTRneWM1UmJ2bmNkTlNyQmRCSzlDSHpEUnVqNEVmZUZESjNyUlQ0ZTYvUWxCeXNoZVFxVFkrT3pCVEp6aW9JYmxKSzBOUENCbFc4S29QcDJxK1FlSXRUR2kyMElmT2NrRlhpVWhOSURmOFdBQ0htWTNkVzRoVUpyNDFIdUlNK0c3clZjTzMrSUV0dUJWSFl3UUZkRUVRQS9kd0ZkL0pTR0l3ZWY4TGs4ZkJBaHhkMmNZckppdk9FV3kzbmxoY1oxOTdzdFFNTUR3Z2RnYjN6eTNZSUhITWthMGxydGM2cFgvMTZXNlpsU2FHeWZFV3ZjOUpvRXZBanlrZ2R6SE43Zi9ETEJ3UHpvM0hEek41TFRsKzd6ZnZJZHI4NTIzZDlrczF4MS9IQ0Q4c2QvQXlkRDRmRlFXc05NNlZuMS9ka1hWeG1zYWgwc05jZ0pKWUI0OGNBQUY4QWRTMEE5WDBuelVZeVVlSkFZV2hIK3VRbVg5MTI1MTkwWmZKb0NaWjE0WFYxQmIxVTJyb1NBUXhoM2paSFR3NHk1YVFqRkpBQWdiaERITWx6ZENFQXJrUVM5dDBBaFc0NEdNQkc5V04yMnhGV2dpaGo3Y2hGQUpGUnNMeFlLZGxDRVdrR2p5VWdOenBuaE5waUVXNEFKZ0VJUG5nUW9iNEEvYk0yUDJnVGdBZUVObTVYNU0wVklBVUdBR2MxNWtaVzBKWmxNcGVHWkFkRGw0UUFLdWdnYjR3a1FxaGtnVGhtZG5Nb1piVmltNVVrLzYxVjFwOFZRUzBFOXMrSDZFLzJVWGNJaUVDbVpMdHpFYkZYYUpFVVliRGpaZjlaVmhNdUpsSVFoSnJwUWpsblZaS3NVTVdUQUR0aVZtVGpGVDJuU0NpZEdKc2doZjdyVTFYd1VhNmhWTjJ6V0VBNWdqclVBS1VQQUtSSkJVVEdXS0t2VUtrZ0FFalJoVG5ESlRXZldLMkJXTjlSUldZdkZjb3ZoYmFOaGZqWlVJVHlBQUMxQU12eGlNY3NWVXBXaU0ra1FFRDZBQWVzV0toV1dOZllXTlJOaGpwVlVacUJBQXJMQ05Ud0JaYlFVRmNEV09kR1dPSy9VS1ZxQVBnYkNNY1FLUDhpYVBHV0VBUUFBRFBwQUtxYkFEcElWV3VGV1I0RlVBS21DUUNubDk4TGlSc3VVQTU3QUEwckFHcTVnakZtbVJQVUFHR3VtUkNObVNIbWxjSjlrU0crQUpMNGwxQ09tT3ZQOTRWalZKRXpFNUVFanhEeGZRQmV6WWtnZldWNEYxbEx0NEl6eTJrMnBSa2NpRkNuQ3dqcHRCbEhTQms5R1ZpMWdwWFVsNWhnbkpsQkJoV3NpbEMvbXdranIwaURqcFY1RzRGOWdsR3JVSVZGK2xGOXNWU1Y0cEVTeFJHZitnRkNUWWpHK1lYbGdaald6WmxzTXlpejdWVlVMMUcvckZsYjM0a2diQkZwZXhBRjh3a1RPaGw5ajBqQWExVFVuWWx2VWxYdzYyaVNCRmlQcVJZM0VwSFBJb0VQVDRENU5RWG9CV2xMdjJGWlpaaTdMWVlEazFIWmlJaVIzMUltcmlpWHhtbUIxR1dJZTFBaFFBQ0VMSkZLSTJhZ1Z5VUFzV1h5VVdIYkpaWVgrNGMyaHdBSHZ3QW1DUUJzTHdVSWNFVHkxU1l6Q0NtNDBFbW9mWmZsQXhselgvdDNtY0I0MlRTSW00WVltWTJKeWgxNGQ3NGdKU2dBcXRjZ0IzbG1YYWVadGVsV1A1TlZoTHVaTUhCb2M0aDFCemlFc294a251dVV1bEF6OFFFQzA4d0FReGhINW0wbTcvNTVtMnFKOVpzWnM0c3BIL3FVMUJoa21GQmtSaU1nSnFNeUpOQUFBdVlBRUpTbkpPbGlqRFYzelRrZ1JNZ0tKODZJZjJlWjhZbHAvVHVKOWcxcFZEbVJPeVpJQTVSNGZaZ1FjZEIyZXIwZ2RpVUlWUEZrb1pPQzlSSUlGMWxrYjFlU2EyeVdWc01vMkNOWXErVllCbEZxVDBod0I0U0M5TndBTC8xakVmazBSaW9BQWpFQVVrSXdOK2NDZ01aMGgyaHAzWmNwOFVtcHVoaUhmWlNCeTZWcDVkdWpDbUJuZ3VnQVlheUNwcXdITFFFNlVPTjZVUy80cWZoY2graUhsMWtTR1pmb3FFaEFaNnlSSWVDZkFDaGRvcVBWQUZaWnA0UnRNOExtQUhKd0FIZS9CbTVvRUtZRUI3dFJkeDBHUnJlaHFQa1VtcGxScWdnSXFBN2JraExkYXAwZUlJU0xBQjRqQ2lycUpzbWxaN0h3aUNacGlZanRpbmxmbzczTVIxWGZkcndlWmtiTUNwdnZwcU1pQjUvaGQ5dGlPcjRCbHFGL2VzdU1wRmZ3ZDRnZmVDaU5JLzJZcHNCeUFNMk5JeTh5Ung0SXFZSFRHY2duWnRDeU9rdTFxdHFSTU1jZkFzN2VwcUh5QUZ4K3BNYmlTRUFwaHJKY2loQjloMTZJcHE2anBzL0FOM0F6dEtCL0FMVWJkRzZ2ZXQxQmVwMUVhZUpqZzV2NWRMVHpoNlVySjhCVmNGSTNPeG8xUUhLVkkxbEVkcnNib1ZRLy9ZaHZDWGZRL0xmZUh4S01Kd0FuL1FCMDRnQzhjWEQ0d3dBaXlBQlFRSFFoOFVESm9nQmdDd0FVM2dvcTlHQW9mQ2YycUVySjQ1ZmZZMHE3QlZNemxMUzRFWnFEMnpBUnFvQnFBcVRLekhNUjRrQmZ2MlAvRVFOUzJIU0ZwN2V6SW5nbDg3bmxGUmJ5UTdmeERiTXdwd2ZHWEVNVS9HZUJiSUJqL1RPVDJnZW1rSGRWbkxSamEyZnNzNmdBMkxQanM3S2dqUUNFWmFibnR3ZG1pWHFIYXpwRmJDQmsxS01qOXdkb0l6b3pQcmJqV2JlN3EzTytSWklBZW9TVDBEZTY2MnVGYVNOQ3JhWkJYNExyWkxMNEJRS0VLSHRROEh1VmFxcks2TGhseXFSYk5ySFMyZ0FGVDdha2lVdSthbnFIUVR1a2duUDRYWE9oY0FPbEJDdk1YLzYweGJlN2RlKzdYTEM2Mlh5clBld1hPbGEwUWY0TDBpcDA3V3kwNGxoM1I2YzJrb0ZBOGJZQWN4UzdmR1N5bVMyN1ZlTzI4MkoyaTR5blVtSzdFdGNDVUFJRWovQTNUVU96cjh0M2IxaTNSc0VBclJPMGdrQURzdkI2dDRtcnpXdDZHV2ltMzBSenlwcG1wc0FBb00wTElVOHdGUkU3L3l1eWdwV3NIeEV3eCs4TGF1OWd3bk1Ia1FsNnpoYzdNRTdLTlpkTUJkeEgwbWpMSlNvanFLTmpHNEM4Tnh1cnZDNW5ZTXdHK2xOTE0rWEhVaWFKUFlSMnBlYXNTSEpteDVJd2Jkc0RaSjhNS2lXcmlpbXpmQnNLRDhCZ0d1aXJBMTlNTlpyTVVGckxNay9LSDlpc1R2MHI1UGN3RnhvSHBuYkxoVjRrRjVJSi9HRndXWElFTncvNXhoQ2x1K3U1ZDFYTHl2bVByRks4b0dOVEJLUEFBSVluQ0RhOXN4andZQUFvdC9ScHNHUFB5L3RmYXg0VnFXV3p6Q2tqeXRlY3doQ1lBRnJlYXl4M1lMVHRBSFNCQ0JFNmh1TWd0OXJCdHo5Y3FqbWlmRUJwdytkK3pLSnR5cnREeElhcUJ3d3d1KzRmdEVRWWg3MXppQ1lFdk14WHhISlJ3ZWpUREx5eXhHWUlDNnpyZXgzZXJCZUNyQTVadTNGckZEa2R6SzB5b01EdnpOUmVTbWIyTitxdXZMdGdmTWVRcWUxdGVzZTV1djh2ZDNIQWNBWkNmUEtHUUdTdXQ4RUZyT3ljcTE2TXpQL2N5dzJFeXV4cHlydXVvQzJHclEyTk0yNmlhbi9tdktqSXpGT1JuUjl4cTJyRHkyL0ZxMmY1SUUwRmtEVldBQmJGQndPS2lER3YrdEpEQXFvNHZhd2Q3YW5mc2Nuc0o1dnVWNlNkOTBIUTBDUTRjMEprZVh2Y2hUQlJsczBHYlFEdzhhdm90Y3MranNGTVhScHlab25PajVvWFc0WWk0WXhjUEdCbUNBUWp5Z0JvREVoZlZ5QUdUaXl3MHR4K25zV1ZpZDFlY3ByVnd0WWUwWmVMeDBOMndRQkJUakJ2eWd0aHdqQkZYd3U2c1NCWEFnSnVWc3pvMFV6TXphb3dXTVlBYWxZSmZrb1psRTFBYUsxNmNUREJsTkxZQ2dwSVVyTjhGd0NpL0FwbHNTRHlPQUFHRW9LUk5xR05TTXR3clppcFA1R1VFZG1Fc1lHNWI5YTZLSEI4b2NMZXl3Y2pFY1BXc25wVWJTQ0gvUUJudlFDQUlFaU5KOHZCckcyTllzRkE4d0E1RHB6ODVLbkt3WkdwS2RHZ3JWaEpmdEFuLy9BQzBvRXR3SFdwOFV0bEdDMkVhTWRNNUZKY3dxb1UrdkVBSmtxYmUyaWxYWGpkMjFGQ29xZU50RGlnZU5rQVpvOEFJWHdBanNZTWdtNGdSUWZhRHNPWnMwVm1PRGVHTXhaNGpWL054REFWVXdJSlVFYUpheGJaNzNUZGNRcTkvc09XR3pxWW1jMlprT3podjRsYVZhU2h5WEZWVnk4TlB0bU9IVGRabENuWndtcHA0VlZoc01YcVhiU1l0dEtScWdpTXA0UzlLU1lZNmxZQVgrdEZkdVNOK3ZLT08walp3RGlodnpoV0YzNmw3V0JUQzRxSlZKMlordjFGVC91T0k3MEFYVFhWV3dqUncwMVpxQWVlYjNaZVUvcmw1akpWeWlHVnUwSUl4SjVRTmRYbGRScFFSaDd0amp5bm1VdVpaVmJ1TFhoVjI1V0kxbk9kSSszVi9TL3dDT3dDaU1TbFhuZFVVRU51QUE4WjJYUm9oVmxKbVZOYktWRVU2VlFpNlBxL0JZQkJCWndBaFhTZVhvZFNVQnJ3QURTbENTVi8wZmhmN3FrVXFVNHBrUjl0aFlqeVVBYk5VS2srV1A1V2lPcUI0Q3lnalhuRDdzblQ3cmtSRmU5YmhZRTVBSW9FNFNwREJaeEdqcXBrZ0VWaEFFQnNEcUFVTHNvV1hzRDJFQVp3QUQ1OEJhcE1tWTlYaVBqdFdOQk9Ec3U5N292UTZRK3BRS3BRQURRR0RoTDVuaTNKNFJ1YkFDSjFBR1JGQUtLaFdSZVE2VFBSbVQ2WkFQOUg3dkhObllIbWtFZ1lBRXJUQUFyVkFNSkZsYUExK1JnaEFUQ0gvTjJpNnAvV1VFS3hBRVJIQVNGRi94THVFSVMzRHc0cm54T2hsYnVZRHRBay95QnhFQUkvOHc2UittOHIrVjhVMEo4d1dSa2k3LzJsVDVqdGlJOHhpaDgvK0FGRFFRbFRWSmxMQ09vZHN1OUhSSjhraWhCbC9RODJoaDg1U3c5SzlPWEU2L0VqMzVrM3RBazh4bzlWZHZqVWVwWFcwTzlJZnU5REhaRmgvd0FpaGYwaXJ2amxlSjZWaDVvVHVXOWhudmxHMEJBbU9abWpkWjZIT3ZYdElvallQK25YaC83NmVGWEt6UTk1c0NXbGovVjRKUFhYL09WVldlWFVURjlPeXRtTG4xbEl4ZnE2NXVsWDkxNmNYSlhwS041cmFvNWpXaWxQWXVucm4xQVVqaDlvMXZGczhGK1pqdTU2VnYrclZZbUxxNW93cS9rVWNoWG52dzlpRTc1cENZbG1ycGwzK0ptYk5JWDdNWVZDZCttSEs1a3dmQm1QK2dCaXJnOTZySkk2Sy9YcGIvZWZ1a2tabFJubE5STHVXZkNKcXFuNkVlV1JCMlNRTnZRUFVKWDkxOGZ2emRiL3JnL3h5YmVmOFhkcU1tYnY3bkR4Q1VCQTRrV05ETFFZUUpGUzVrMkpEaFA0aVlQbnhBOVcrREFZY1pGUmJrS0REVFI1QWdPM0FpV1pJa0xKU3dSSW1xME5MbFM1Z3RPY3lrV1RQV1RaeXFkTzdrcVhQWlQ2QVJoQTRsS2hUb3o1NDhjZGFNV1VGVVNwT2NPblFJV2JYajFhc2F0VzcxQW5GaVJRSmZ1R3JFT3JDcXlKRlJVNjVzR3JPbVRaeHhreVk5V3RUdVhieDJnU2E5eVRUbVU1UlJwWjRGV2Rid3dMR0pENjdZOG9QVlAwQXJGRGM4VEhpcVlKUnMyOHA4R3pmVzNMbDE4dzRWVWRwMGFUeDRYTGhJZmRwMTNtVjgrODVzdWpKdy85U3BoRDhlTmp3NU1VYmZEQTJmdld4eTdlYk9PVUh2RkQwNmdtdm9JaEJNZDVFbWloN3NlbVExSVFFSXpvbExDRmF6Um1CYWIyeWxzem5VQml4WUtsWGRtWGhuRFY0L2NWbkxhbFcyaFh0emVWRG5ubnN1T3VtbU0vQkE2Z0RKYmtFR0dWekhoQ0hRYU9FMHZYcGFpcmEvQUlQRnZkemlrMjgreE93VDBhSGhxa3FycE15YW9rbTVuZ0RNaThEVEVKUVJnZFJxYkdHVEF4clVjVWM5cEdpaFBBcUpRaXE5V0docVMwTU80WXNQUklGR2RESWhySWpUanlXWVZ2U1BKeGVMZ3JHMEdSR3M4VXN3VlFzbENSN0xYSkNSSHc4TVVrZ0xpL1RyTDZnRW0wcEp3a0I4Y2tUOFFqcnhKRmpjbW9sRm4vQ2lVVHdndXp3d1RFVHhhUDloVVVhRDBjZE1TTE5EZ3p3MTF6UUt2WjB1WE8vSU9IR2o4Nno1N3JRdlNqMk4yNjlLRHE1a3ppNHVYVGdoUit6YStjTWZGNlpMRkV4R2M5VzFCUXNzQ0thQVNJTTlZTkV2S3pWUFNFd3pkUlBEMmpvdHFjTTZEeFBWTjFKRk1wVktsNnpFVWt2cHFpT2h6QjdTQ0tZRkczZk50VmQwMDdVZ0FVMWdEVFpTQUlJSkU4SFhrRzFUdlNPUnhFMDMzcWE5N3lvVGpjT1dzMVEvVzVXMDBseGdvb2QzOVhCQ2dXQVNZRlJkaWlrT1Jnd3pHZzZXa1FRc1lCUk1laTI5OU40M1g3SnRRMCtqTGN2ZnJhcjlhTTlUcy8xelc0UmR1S1FQalJrMEE0NEVncWw0M1FTQ0Zqb0JOc0RJK1Ywd2ZOWVY1SkJMcTFDMmtsMXFMMldyVm1iL09TT1hNemt4eFpmK05EalFvUkM0WkkramVWeG5CRTNZR0hydG5vVkFCb215ZyszQlozU1hMclpwcCswbDBrZzRVWDcyMDkyd3VsbzRnRXRGTWVZS1ZxUlpxQUxkalh2SER6Ymd4eEloZ29tRUJRWithT0tXeDkvOUlCUzYwN1g3YmdQclpUTTl2bUdhK2xtVk9Sb2N5cXhoN3JQcm1ROW1QR0VGTzlkOWR4NzNVTHRqaWtldkVXOFJpaHBTSjN4VmR4WndxMW11elBDVEJrNjg0TVZObTY2Rk5OYmhmWHZ1bzhBaVlxRXJGbjU0WTRzL0hmbloramFKZWZxbTVTMWdGS1gzMnZZQkM2VFJoUXU0MTMvM2RtcGc0L2Z3aWU5anFlSFZhbHB3aVJNc1lRUm93SVA1aHBLczVFbnROaVNCVnVBNmNxZjVTSWxQQTFNYy9heG4veXZWU0dGL0k5UmRFa1lBQ2lHd0RWMDlVNXNZQUFBSUNMUURFenR5UW5nY2FCU2xwSzRscXh0TVNBU0hwd3pDanhOY0k5alhWTEVNb25ESlFEWktBTU5JK01TNGZhQUFXS0JjQXFwUWd6MGNRSHM1ZzRNTDhvYkRUT25RS1JQc1lXRXVLS0lnUW0rSXM1TlpxcXFuUkJxVkt3RWloR0lkN1FncFJ2aWpQTVpURnJOMk9NRlAvWkJhYVh3WnpPUkhQYkRkem41Zm1sZ3duSGhIU0VZU094OVFnQmR2aUxwTlNYQjlWWFBkSUVza3hEVnlzSGFKck44U3k4VXJYN0ZBa3F1TVpCOG01RUFJaWhHUW5EVElaTjRIeWlFZVVsVS9RWmo5NHFpb2lhR0xEVGhqWlRHaHlJNFR0T0I4cW5DVDhqWnB4azcrSzArZ0pDSm5kcGxFT1A4eWNsSHE2bGtWVUdGTWNKSndBdzE4WUI4ejJaSlordkNNWEhrZU5kbFl4RGRtODVUcEdwb2x5QlpPZkc3dkFnMkVaUitkeVRwbzFwS2QwMFNMd0ZCMXpWNGVpb0RCN05YUWhKQzdmRWIwY1FXbzFSY3hsVDRKK2kyUTBkVEtKNjExT0YxK0RZbUtYT1E4NlJtMFlBU0RFUkpsYWRsR1VDc2c5Uk45NXh6ajM5VEpVYXdWenAyNmpHZEpGNHJLRlFhTkRWWGdRVXVOK2k1TVZMSjBYNHlBT1UyV1Rnc0tOS2M2TGFTcFVPVkdVbjd3bDhEY1psQjdab2s4SEZXc2tHcEhQeXlRbXFYS2xKbCtyQ2tGYVVtUWpsSlZhN0s3cWtpeDZWTmdyaXNZLzB1QUdLU0FoRDVzYnF5RDNWRVBKRVl1dEU2SHFVN1ZKRUNqQ2xleWRFVC9neHVzRWtMclZ5RFZ1Q0FCbTBoRERUYkFDQk1RRmp2c2FBSUUrckNIUFJTZ0R5U1F3UllIaXdRMkRCQVBhUzBuOHZ5NE9qb0prbkNTVldNMXAyZFgwaUFBZTNEb2d3dytJTnJzdUtFQlZXQ0RFTmlRVXJheFVBaVZDOFVHUWl2UkpJQ3VWN0tsYlFRdTJzekdrdVN0a04wdFI2Z1pVdHVKd0FWd1FPNkNrdEFBRklJdnV2TWRXakNFZ0lVOWpDS2NqQUFGOER4R3JNVEd0TFpycFNsVVA3VE9oY2lWcnJTekxHb2cwRjQ5N0FFVUFLUnZoYU1yQkg0OFVwSWpTS0YvLzR2WTJTcFdyUmo5bzJNZlM5Nk44UGFqMFRzb2NKK0RoelNRU2JSSXFOeDhmM2JqK2U1MUE1SnNnQ1VDdUYwQWgxakFZQ1R3VTU5NVloUWpSTVVyLzY1bUI0OVlzeGVJOWdmUFZlR05yY3pOdFFVREZBKytvd3o4SUYvUkJWbkVsNXpwT1o5aTA0RGkxQXRMZmhsSUdleGk2ZUJocFdQOUFBczZQTFFyNTVsaWJCTUNBQ0Nwanp0N1dNeGpIakI0LzZqUjhZWkl5V3pXMnVGYWZERFVuRUFXWTQyQ0dDanM0ZUNaYTFjNEh0cFFYZnZFSnZUc3h4OG1INUNJd3RnU203aDVhMmEwVmQrY1ZSZU1ZS3pyWU83YUJLaHBYQU1WeTBJYmFqenNDSUE3aHhuRTNmVnVHTTFzNEFOelZLNk41dE5CNlRjZHg3VzBCb0hHTkpCemZlMktyVTBJTmJCakU3QlFZMEdEV01nV1JYVmIzWHBUWlp0WGlDaDU5Sk9IZ29jd2pKVVI4ZzNhcmNlbnpVM3Z1ZE9UZ0dRVEZQRGN1ZzE2eU1XMmJmK0JFWTF1cVNyWXpUSnJNQjRBY04yV01vRGFtYjQzb3N5bGI2RnRlNVczQUVRazJFRHFBSk83ekVZMmNiSlJyUEQ0dlJwc3ArRVZIREltMFZCY1dsM211bFdZTHI1cm9vbmgwNUlrZ1haTGZTeUNGL2tseUJha3l3eEpPNnk2dTVUVHNZQUxBT0FFZkg2ZzFuZ1d0bXhyam0rR2VyVm4vTGhPT0dVd0tRc1ErN3MwUGZPNUVhN28yRG1hd2VtVkp4NThsUVlOcjVJRk1xKzYxYS9PMWF3M1ZHZ1g0MXhFZWZDQ1JRRjk3TWMrZUpvVnpXcDFyemlYS2xkNjIvUEtobVNNZ0IycmJNREVaNzZydS84MDczb1BXcCtQeW9NNjhITmt6RFQwR0F1UDVDWWRKTzBzWG5zaXRXcFNYeFZOSEpCMEFpam9UZkdLNHlyZko4MTQvc1QvS2lHWmtoaWRHczF0KzFiUGVtdCtEWnVtNU9wSjdjdVBPVU94OHJhK1BLNnh2bnZlRTAyVlluVkRJL1pJNU5KWEFKQWJUVGVidC9iTzM3TGRwMTNsdlBidkNBYkxWLy9hTjhmNDF0c3gxajFZc3JiQ0Y3L2Z5b2g2MkRFL2cySTRneG1wMjJHK3JPczBMcXNqTzZNKzNKcy9YY3Urbm9rRHFCc3JNSGlsMGVNL01pSS9xVUs4eEd1elptdTl4bXU3Qk93OFA3c2pHblBBbjhHMUsxdWJvU3Fxc1hJQ1lmaStvTk5BNGtzMFNrZ3h1UnJBNUlNMEVtUS9vRUdwMmJ1akp1QUh1dE96UE9NemlCb3JEOUEvOE5NaDNPTEFKUFBBZ2xnMzlCc2xBM3k5bitJOUlRaXJWb0l1RlVSQ3JjdTRHdEF2d3ZxQVpMcWhpMklyM01MQi94eE1zQjFNT1FKa093UUV3czd6d2xWaUJER2d0aXJEdWVqNkgxbHJyd05RckVJTHZ3MTBROG9RUU1waU9QV3JRM29hSm56cWd6MmtOd3U3TUVkNU9RaDdLVFUwTnVVNVBRQk14Q1U3dWpuVWllVURvZVpiRnpHNFA0bmlnVDFnQVJSeUxrcEVxYjF5TGpGZ2dDRkVyZzlvaHd2NGd6Um9qUkV6UlA5akh6VUx3Q3FFSG5ZVHdTejh3UlpnZ3hNY3JIaVFBVWJvZ3dKQXJSL29BWEdJZ2hraXJDaFFnejJvZ3pUd2g2Q2hsSUVidkg4eU84TTdQRGdNUlI1TXY2eGF2eFlJaG51Q3NNRUtBQ2U0Z0JGUUFER3dnUCtKR0pBVHNuSE1JYkk3eExORHgvSXFSaEJjbzhxQ00zbHFnV1NJTm5rMHFoR3dCREFUTnRJeHRVSmtRLytCSE1qVWk2d1BQRDlSdXBKa1hDUUxHSk9ISEt0UmFNQlI2OGR4WXlweUpEa0tFa1lFSXhGRlhMeFJITUVDY1lFNktNa1lqSVBiQ3ppQkc3Z2FMRDNiV0IrWUhFWlFORWhtUTBqR0Mwa1hXRUtkWktrOWlEK1ZUS3RmeE1oZ2JKMlluQ3FrRkVWNHlxb1dpTWVuWktrK0NMVHFJeDJnQzBxclBES05KRWl0SkFncmJMZkdhNEVvQzB1am1ydDY4OGxoR3pPMUlqMjIyc0Npek1xNFFzcWtwTW11SkVYU3dBTW13QUM2WkNrSTRFZWZORXZCQThoT1ZNdHo3TUNCK3NCTXVKYWx4Q1lYMkxIRmpLaDRlY3lmWThseU16M0tOTG4yVVF5VVE3NGViTWNXT0lISis4eHdVZ1BnNFM2eHc2UnkvTC9LdE15eE1Eck4zRXlFRVM3LzM1Tk5ZMEtEY1JHNE5Za2xtdW8veXJTVFVabkpVSUpMcFJzUUYwQ0RvNG1ISnRpRElLZ0NGTElFUDlpQVNTUE9TRkVEajRITVRSdzVsOVJOMUV6TitsaTJCV084NmVRU08zREk3RENEN2dBQUp0QkhLZ3ZDVGdzR0J1ZzY4ZVFSQUVpQTBTUXo5QXd2OVF5VkozSFBkU3dpSXpMQUFXbUJGNElES1dDQ3pISUJUY3MyRit3ek53aFFIV0dFczZMS0FTTXdnMnRPYVhHZjFZeWVRMElrVXJvc1g3SzRjNm0vQ2F4QUQxMFFLUWk3bU5yTDhPTWhVT2tONXptK1JVUTZWV2xSMS9BUzNkdThJQlNDQnFoUkJxRW9vR3pKakNvNUgzMmRySm1yMzZ3ckk1cE9rdktscmRLOENPeVZpNG5OT3FMSFBrQUNGdmdlSWJBRVVBQUUvMThib1hhd0lWaUMwbFF6eC9Wa3l4OWR0c0dNVGo4cG1DemxwYnVDSTFNOEpTRFVSN0RjSDBCQUJsaWtyK2RDQWhqa25RdGdBaG9NT3FHVG1yS2pVOTE2blVYRDB6MEpVaXlsQ3dnbEtSazUwcTRLaGxENHBoR2FOZ3RUbDVTcUFVZDRIQkpJQTBzNlQ3NGt1MHJWelV2RlZOWHpLTVhiSU9raEdENXRrVTkxVVNNVlZGOFp6dTFaaDVoTHlTUU1CaFpRZzRaaEJGaDlVdHg4cWh2VVNGeVZTWUpTSXo1UmlWNTEwQ3pWVW1GVktFYWFJLzF4ZzBpb3RoWFVORVVKQmlib2crUGFrUU00Z1lwaUtrbU5vRGw5RHh5ODFyWmt0SUxTRDhUQjBtLzEwMTRDMURCcG91Mlptd2VrdWF0akRUaVFnZXh3QWpDWTF4c2lNdExiMGY5YS9jdU4xTmVqekZZOTJWUmU1UThyNmROUExWS0ZzZ0E2MHAwUmlDM3J1enRETVpCYW1TMTZIYjB5VzA0ZXd0aU1mWklhQUE1cGFpZmlLQTUvN2RicDhabytaUld0Y2xsalBab1BTQnE3UzVTV3BVclRNWjVrcVZneE1zMlNxOU0zbkpaWENBR2Q3VTBtOFpBNXdZek1BTnFRQlZadStTRHMyYm1Ha1FHell0cW0zWktZUlphb2xWcTJPclI5Y2NPckZSVkRLSVVIbUlGY3NDVW1vUVFQc1ZLdy9kYzJBaFJ3ZFkwV0FBUFFRbHN6b2FnQU01UXRFWkFBMll1NTBKVGxORDMvUzlCYmZSSkQ2TnhYQ0FMSjhOdS9CVnl2OWRoUTZ0YXhYWnlCdFpYeHdBTUVnb01SSUlFMmFGUHNDSUNJblJHM0RSRHZvdHpsaUl1MzRKVC96RlZQcTczWk8rbmN6bVVHRkZDQzloeGRzOUNOcjUwUzFCVmFzcjJMTGFHUkZsZ05YNFFSM1QySzViZ1g5WmhhU2lXamw4UktvM1FTNHpWZUlxaUIwUFVrNXZVSTUvWFk0OWhUd3oyaVlLVmVBdEhkU3ptZTd2V003NDJhREhHVzhlM1JWZk9YOHpYZVZNZ0NGZWhiTkdwZjk3V01UWTNmcS9yVjBCQlkvSVhidUpVTnozZ0wvOTBNcDlDUTRNVlg4aTFmemkxZzQzMkZCbGhmSUdyZitJQmYzL0pWdWVoZW56Z0s3b1ZoWmZGZERiNWNEcVpVRDNZUEVBNWhFUjVoRXU1Y0NTZ0ZBTmhhRk8xYUIvNVprQTNaK2FWaDlNbmdHODdoelZpSmswbUpELzRid0ZsTDNpVGdJRDdmVkhpQWR6RGlxd0dSSklaZTVMaGgvazFqL3lqV1lDbFduUTZ1WWl1K1lrL0pZaTMrNFR1UkFEenU0aEpHQVNBd0FvMGxwSDQxRlc1dDQ2Qzk0ZDhsWkpPQll3RG00VG1tWXdGV1VIMzFnVkxBNHp6VzQxY29BeVZRWUgyOXBaNGRYQ3BHWkZCV0hTcU9ZMFptNURtcG9NRGR6U25WVnlJZ2dsU1E1RXEyNUJ6SVpJMmxRanl0cXNFTlc2QWw1RkVtNVZMR1lsUk9aUjkyemxvK0NGdUFnbGR3WlZpV0FEMzIzQjNvNDFvRzVJNzk1VGl1Wm12MjVWOCtaVWNXWnRSajRMc3Q1b013aFZZZ0JXUldaa3B1WmtONGhUVUk0eitXWmhNeDNWK081eVFKWm1IMjVyOEY1NFlnQUdrb2huRXU1MlZHNTJwSUJTdFFBQlNtVWlRTzNGT1daeDQrWlc2dVkzdmVYSHhlaUJzWUFQOENxQVZUT0FSYm9BVmxubVJtUnVkU1NBVUdFT014L3R1R2ZtZHQzdVpVZm1qbWpXamZtSUJWbU9pS05nVnkxdWhYam1WMGZvVnpZR2RjWmVDUzdtbTdWV21XSGh4V29JRUptR2dCV0FCK0pnVmFTR1lmOEFHYmJtWkoxZ2NEMEdTRHRtZWYvbWtHRG1wOFJvVUFHT3FpSGdBQmtBWnh6dWhXL21kMExtRWJBSU9DSGh5VmJ1dlIxV3E0UG9nUEdJV3V2Z1dYaG1tTFBnUW9vR216UG10RGtJQlgySUYzV091UmRtdkRuc0s0WGdnRGNBQnUwRmVKb0lpNm5vQkVnT2xpdU9pOUxtdU83bWkvTG9WTEhteHdQdXlWVG15dHlBVURVSUFzT0FSSm9PclhpWWk1NW1xdnZvRW5vT2pLbm1uTWZ1cXpCdXh6Q0lNVlVPMklCbW9VMFE0T0F6QUFOSGlBVitqY1ZOZ0IzcjZhZ0FBQUlma0VCUVVBL3dBczZ3REhBUEVBN2dCQUNQOEEvd2tjU0xDZ3dZTUlFeXBjeUxDaHc0Y0Z2VWljU05FTHhJc1lNMnJjeUxHalI0R1VRb29jT2ZKalFwSW9RNW9jV0hLbHk1Y3dDMUphbWFtbXpaczNNZUxNMUtHblQ0K2NPUDM3ZVREbndwWXhreW9WT05Ha3o2QlFneUtFUmJXcTFZR2lzbUpkbXJDQzE2eFZCMGJ0VU5DbVFwVmMwMkpzZW5LbVFaNWtEMmIxdXBDRDNic0VZK25kaTFHVjM3OStsd2tlVEppZ3FvU0gvK2tWYUxmZzEzOVV4WEtLSzVOaHhjdHFZVkkwS0pKZ3paNENnMUlWWmJDQ3djUURCMGRZSFFHaGlIOGlZc05PR1BzMVFnUzRjeU53VVNjaEtoa0Y2cVRaN1FJQmJOc0NWeThiNkZjeDQ5SmlDM1l3U3hEbFE3YVpHMW84aVBiZjU5Q2NSaFAvTkcxM2NlcUVhUzVnRXFpbnZmdjNlbnFJQ2RhaWZ2Mkc5aTNvMTg4RzBFYjRldnpoQWg0QzRUWVFjdiswdHR4QXNmekR3VUNtRlNRS1ZWRUoxSk5SMVhXWFhWdWRPUlNYVUxDUUJxR0RIRFFva0NvTEpsZ2JBaTFJNFJHQTdRV0FCQnZCL0JNTUcyd0lvU01ibXZpaHowdnc5VkVqUWdRZVNGQnJxVFVuMEdKMmVSVWhWaFFLTlJCWm1YQjJsbHNja2FRUWRSWktDZGxDSnFJNEVKSzI0WWJIbVMxWVVFVVNHNmIxWGc5c0pIU2ZRRVgrZzRkdUNOUW13bXBKb3RiZ2czUXQ1T1ZBVlhLSHBVTWFGc1ZsVDFKQk50ZEFqVFdJR3BLek1aVG1mZ213UVVLYm5CSjBBUloraEFKQUF3VXcwczQ2RU9rQngwRXBFdlFnaEJPSy93V2FRRFZ4ZHFoR3RVNEpsVUNqUGVtZ1lyRWt0Z3lmbFJwbzUwQXRDR1FCUW14Z0lVT24wQ3ExemduSmpybmdZYkUwSmxBRkU4SUNYbHk1Wm9nclFXUkoyYXVyU3dwTDZXdC9rTkRPS0RERysxNjA5TUlFWXc5M1ZockJ0WHBwK3crMzN2NFRGR1dGVm9iUWRpWk5TaEFDVEpoUUwwUlJNTEJTQVIvUUN5QWp5VmhRYlpIR1ZmcFBpbjhTSkdKUkVDSE0wcUU4aGVib2lLOGVoTWNKcUR5Y2tDeWhwTFZzUVhsa3BnY2dRaXdsSldVZ0hTUlJSTFo2OW1GNEk1UG5uSklxaXBEYm1jR3c0SVRNTWdlakJsY1FzSkhBMWduY2JGREh0aUc1VEdMWi9ndWx3QllXbkNoVENBOWROSzJnaVphMGc0c3BTV2FCZE9hSGFRSkNpUDhCUVZvdVVzMHBKaHRvUXA5OVo5NXByTmhrTnhsaHQxSk5wL2F0LzdqTk5uZEdxeHp3dGt1ZXVDQ2xCMVg3ajlmL1ZJRXFWd0FzSmJyZ0RhMERSM0d2TVE2cDJRTjUrM080YTF0K3VaVXZGVm50eld4c0FOK0dQWUFTNTFJQW5NNjZ5NVdPM2ZsQnRxZHRtY2tRZFdEdVB5UC9HcXhBd3dwVUpwMFc5QURnOGdhQjhNK21lMnl3UVFFWHFHRkN4ZVFUSks5N2d6RFJjWExYemo3aTVwTnAxOVpiQmJNZWlFTDBwQWRKaW50a2NnRWNoaGUvQmlZRUJDelEwWTVvbElEUjNXeGpIRE9PYkJLVXY1QnRDMkFCR3hqUUNvYVJEbmxHVithQ1JhQitwUmpVcE9nMUluQkJIeHhJdzMrRVFnaGM2MXJvdm1Za0R2SXJXeTM3U21UL0JEWXd6NFNMZHcweElhRklhTDNhWWM5WEVNR1RtUktIQi90Y2FqLzZ5V0VDZ2lFRUJ0eWloaDNaQUJ2MGc3aUIzTzhoTGZ0WHJMNWx4Q1BhaW5LSWdpT3REQUkwRUdYdlgrUXBrWW4rRVpneHJRczVaMXhJTU1RQWdubUI4U0dNYU1HWmNyTkJTam5QT1lBcVNQUVFRc0kzS3ZFamNseklaeWdEbGFwa3owa2tBaFp6UHBhUU05WnBkSFl3QVFNN3dqTXRWbkIwQ1dFREM5d2dyMVFkNEFSRmNpVFpnRWc3Z1V5b1VWU3FEa0xXbGgzcWNlaFdPSmtWRVNFVEl1Z1loaURkTzFDWmRpTzhWVHBrRDRkREhCVWJRc1ZUMHNrRko0REFCM3FRaHVKNGI0TUpNUkdnZkFXNTIwMk9jdGlKSDJZZWNrbnZWSElyVU5TV3BGekkvNW9vNWtsUDZQUmpQeG5TejMwVjVpQ0FBZFllMDdpVlNWcEljaG1DNDJZT2VaR0tNT1NlQXZSU3IxWUlxVFR1a1VIbXljdGVSc29YRXVIbElBeDFpSk5XcXBXd0dHUlFiMHRJUENtNkVpMVJra3NQclJCQmh1akxyU2drSzBEdGxsVkN1S3VHUk9Xb2svR0pNcmVFVTRjWWs2YVpRY3BGM2ZpUW5WQTFpY1JNaTNXZ3l0V1ROZENpWFEycldBZHltYWUyS2F0akJXTkswSm9VbTJhbnFReVJhbHFYWWxaTlltZ2hTbFVxVWhzbHFLTU85YTlCQldydE5zY3J3b0pIaEdXQmEwUXpPZGZyMU5XckJ5a1g5S3d5bDVXQ01pTWNaY3hkVGtwU2tqckVYK01SSWs4UmE4VHBOVlloRTMyakVaY0tJdXloVko5N0FReHFERUtZRlArQkxpR3NhUTJmQVBxOUkrSFdvTXpCMXA4WWFoclNHUFovSlFPckEyZjZEeFBhNUdqaWdaRFNuRFBLMjY3SUJXazRBaW9ZRVlZQkdjdGxaK0ptTi9FUURQK2tLa2ptUE02UkJEUEtQVUlSZTVIaDY0WHV1dFdGNkk1VG1VUVpKNk9MUisweHg3Yi9ZSmo0emdzakV5aEFhd3ZaRzkrUThCSDRySU1KWGdzdjNoQ3lIRDhORjQvc2JLZVg1bnRQeGlxbHZtK2hZM1EreVpnOWlpazUzdE1OSGx4d2dkTU9CRDZoR05KQ3ZvdE9ZbjNzTDBzS1dXYlhDTk1RRDlQREhMTHJFUVhJcXlkbUJKQjV5dzhiR096aWc2Q2lBUlQ4eDlhd3VCOHJqbGVLeHRFbGc3cGlYRm1kTUtaSlpDb1QrVXBBWHhsUVNjTzZXNEFINGsyRDVKRC9EV0lJUUpNM1JJSTdJV2RmZVdIaHRyb1ZtbGsxdFo1VkhYTUtSYkhDOGdUck1HbjJYb0U2VnFmZlNYbUxPWkpnRmN3dzUyakJ4d011Q0ZzSC9RVkNJaEtzdzBCbWlFYU5yRC9mbXJFUk1waGZlMnFJaVNpSW93Yy9FTWdlQk9JR01BTG9BSGFvRnRqd2R5SVA5amVFQktzbzVnZ0Z0T00yaEIxZzFJY2xYdGtSMGhXa0FCc0tVakFxZUVFNllmWkxqbzJJTVRXVU1yUVJkcnA4YkpYVFhJQUdIaXp2Rm1Lb1Z5amd0eFFXSEE4aXNxUHVlMjhuVElQbzdyN054ZEozQk5aTXpwWEhjd2xDMHRNU1o1OWdnQUlRN000TUN3UlhCVGt2aFJGVndHSFhxbHdmamltYVdNM3BWeTkvU1crUVNMUnRUOVZ2YVBoTG5qQjlUdEVFLy9HbUJYSW9oRmd2UlFaeG9Ob002U1VETU5CSGNmOGtsdk4wRENWZzVvcVk5dzU1NXRCMngrZHhSQWo2MEVObUd0QXBNVkM2Z1hwUXdPb0tFa2tudWhPeUJNRzNRd1pGNk5sOWxJZkgra2VhRXRDSDhkSHJBbFg0eDdzemdxTWFPSUttNjBoRG13MlMwaDZ6UkdnblVWU1h6TlYxU0Izd1kzZmJ6UjVnVkdsb3FUcGVIMmdIQ1Y0Z2pFWmVTeFcrVmlPMkJRYTBqYXd0VjR3cWJLR0JwYTV6NHFGaGhlZFVGS3F3ZG9TSXp1THFEWGlGSWMvTEQvTFoweU84NTBVdUg4QkduY3ZyZkZRSXVaWCtrSGkwZ3hFRkdBRUFRc0VQUDdnODlBWnB3cFQzSTNackV6UkYyTkt6R29jSWxkakxIdXR4aEdNbG03alRPL3JLeExhTmdQK2U4TlJOZ2t5OUlFSVl2SHNxellJRUtESnh1MGF4UWI0dU1oRXY4U2lBTHVGRnVnMmUwWHpTSzNjUlVvRVJmajAwWVFkaEFjRmpUUi9SQUg1Z09CSTBFTUhBUlRYQUR2SGlFV2hRSFArMEowbVNZMVczVXh0MmZaYkVWbEZGZTV0MFdPSFJiK09oV2RSbGFpZ1hZUGV6WW1oZ2RobUJUVlJHT25PaUVQVVJESFpRZHZNekVDUndBbUhuTVRlMlpZNGpNaFF5SlNRRWRLekRYTWVVS005VlJ6NkZMa3ZEVDM5VUppNHdJR2xRQndYZ0JqR0RFQytBZ1ZqR0VUQlVHMElvVUlPeEVPOFZKZTcwVGtLamRUVlVWcW1WZHlJMktONUNhUG4wS25VelcrZkJQYTFDVzdVMU5yTEZFRGdHVXA1bFVpZUZFTVdGRVBNbEUyakZoTWovNTNGQ1JpNFpOVmdoWW9mdmhZaVdsWW1YZFJGT0VsaGc4VmN1OVZKanNWUWI0WWFQZUNYNXQwUlhOUlNNWW5jZWtWZVNzNHBDWmxWM2RZb09KRmNhc1ZhNkNHSXVzWXNwWVl2QVdEbHdPSXhsRll6RytJYkUrQkttZUl6TXVEc1VsWXJOZUZhK3lJczFwWXNjQVlKWUpZTFJtQkc0cUJiWWVGTzArSVRXRjJqZmVETFF1STB4RVk2eTJCQUJSQlFKc1ZmdzZJb0ZJVUtWWjArS1pZN2F5SXpMcUhjS29WZnhLQlR5dUZPUzVFbWU2QkdQSXlLaE9JcHRoSTNkZUl5T2FEQ1JOWWtHQVlwQnBZbVoxUkNaU0hlYnhSR2RtSkNrZFgvb2VERDdtSStEaFQyV2VKR3Z0VmtwOVJ3aVZWSWZZV0dhUlZ5aVJSQkZ0QmJGNkdKeC94aFJpVlY1MTVNUUc2bFFmQ0ZiVElNWXduS0dLeUUyQmVFWGZBRmFlTlJsMGpGczJnR0hVT1dJenJWdnk0U0NVaWhLZ3doTnFwRmJ0NFVRTm5ZUXZEVitMckFCOGNBSWdLQUFseUFRTFpBbjBuUWt5aEZjMU1XVWw4aUtidVJXVHZXUTlaS1RrTGhFbkhTQzNzZVNCY0ZlWVpsaVpIZ1F1c0VRaVRsZWVHQUIvVkJyRHVFZVBNQUlJM0FKR1pnY2NYa2l6NU5TUENhSmY0YVg5dlZZYmNLRTNmRmMvYWNWSHhSSzlGY1F0ZUVDL3dBSHFYWnJKekFnaWVNUTNtUkY5WkVBVE5BT0dRRWZTY0FFT0hkT2Z0U0gwbWNRR2pZbHNRaHErU2lhYVdGV0tOTnRvdkZ0U2dOK3Z1VUMvdkFIRHBNUTh2SUJnTEJ5RmdSTENWR0RnLy8wTEJ3Qkh5U3dMQksyWmdWNEVPcTBUaEpTRlRyRllWQkpOZWRJYkdLQmxSR2lSeWVpTUxIQkcvOFJMejJBQmFVM0VGb1VESDdRQkNzQkgzVlFJNnN6ZDZ3eVczdlJHSnRva3JCUVZBKzFqdlBaaTZDWkVQd25KVWxUY2liM09TdGlKbmJBbXcwR0kyN1FCRkhRaFZ3Qkh6S1FETlJXU2dSeFo0NEVpQ0Fsb1ZERVo0TlNqL2lIU1J0YVdncGhXTk41RUdUaU5GT0VCd213S2swR0h3MkFRd3B4U3JseFRtR2pTMzRTU2ptcWlHWHhZMWtpZ2ppVmVWaFJsNnM1bzNoRGNHTzNLWVduQjFHUWJnWGhOV1JrWlZTRUozb0NPbyswZ3M3RVA3Rm5LQ1hFVm5kRlpNelVkeXo1VWRHRW1Hd21kbGVVQUZVUUQ4QW9BeEUwYlZ6L3N6Y1JHSUV0WUFkcEFBWjFNQUo3MEFPTTRBUXk0QVpTTUhWenltWFlWcFAyaEtmMEpHYmtVbFFicFQvYmcwQTlGRWdIbUVWODh5TWh1UkY3NEpycmxXZlNaeHBFOVdtcTFSRkR4cWVwcWxsNmdXYnJZb0FOd1RWQ3dHU3p5aEV5WUpuNjBrRzV5bVA5UXl1Z0ZsY2NLbWg4eDFFR2xIdUFKNXpxS1dHaTQyekxHaFB1c1FTWnhtdDhCSGw2SmtSc05FZU02QlJrWm9jZE5hd0lwR1lzY29VdVlBSCt3QVFzZ0FZdnNBRVhjQUR0d0E2WUlJUGorcC93MFE3Mk15Yjc2V3ZzU25rZ0tTNUE0VVJteG5tc2Vod3U4QWVIMTRNSDJ4RXdVZ091cVVGN0dIMUJ0RVlRNjY0UWFXOFo0YWYrSlpiLzRBSWpvSUFPMUFSSW9LYUMveVFRRmJRSFR5Y3pNTEtnemxjUWVNYXQ2MnF5STRSM1JwdXkvTmRURUZHV0ZBVUlNdVlTV0dDbWJRSWZId0FBQTNwS21xYVpVOUZubG5HMDJBZWRrOWRMWWNLdy93QnROTFFIUFpNWmNjQUlPdE1lUEJBS0F3cDJEMkZZYWlPU1diZHRJdWR0YzdPU3JkRUNHdHRBSm9BRlQ3c2hvY0NpU2lFRG9QQ2tDOUVxSFdpeVExRzNiVWhXZUR0MHJjVXlKaWROUnVvQ085aXhBeUdyUzlHa1cxTVFVeGQvb3dSSkcxZWhFUXQwYlVPcTNnRmRIN3F0NFpZY3NURndaMklCd1ZBSDVyYXNPYk1VN0NDNGpWcGx6cmRyOGNaTFQvSkxhVE01OWdaeVVMbHZnSm1hSlFKd0NZSnlDRUNtV01RR2tUQnp6UmdKeUtZV2ZTQ2dGUGQrK2YraUw5elRPQnpnSzBmNHVPYVl2SkliVTh6TFV3QklYU2ZXR3JJUlNGZTBjbHNUREpwQW5rb3hBdU42QzM4UURCYndwcmdoR3dxU2NiOVN2QlVxSmJnRFQyN0RYS1U1SzBqRE10VFZoNzNsT3dXeE5VSVFCR2xoWHB6YkEvMkFnYlV4dkIzNEpWZlhsM2U3dnV5N1gzdjdYNng1RVd5YkZxa1RMUWphUVB3YnZWcDd3QUpad3ZtbXZpaU1WeG54bGJIa0xPdW5GbTZBQlJ2Q2REVFVBL0tIaURsOHZQVjJ3a1RqdzRKNHNRaHlFTUVRQ2p3Z3Myb2hEbW4zRWpXQ0JLTndTSDF3cmhzeEhVOE14ZXc0Rlg2NnJjSmlKSXdtRU1FZ0JiSmdzUFhDRG1ZTHh3d2hCRmdRQkM5c2ErOVJxeGhSZENsTFZ2dW5LNFcxeG5SYXJNYi80UUpTRUE5MHpMa1hzYkh5TWdLdW1iVkVPQjZDM0JHMEp4bThJcS9QY1dqZENoc0lJQXdIUUhpUTNKc0FjZ3NtMEFROXNBY2pVQU1zd0FUK1lBSDRxa2dhWk1ra2k4blVONjJFY2pBOTJrWjcxOGtWZTBDSkJoc3RBaSs4ZDhvWVVRQnhxeXhzT2FndWlISnhxWlN0MTVTN3ZGVGxlQ1VBaEVKOU9zemNHcWdCNWc4SG9Nd1EwVXFoeXhBWkpNMUJtOHZTdGN1OGJJOXlHRmVVRXk3YzV5aWJkOE5pS2hBMVRNNEtNUUlTTjNIUHpCQjM5bmlSOTdDd3A0b2dTSkk3dk0xZDRrUXN1NUtoY3dKdTBBNXVjQUFRRUh4MW9BQnBrR3MzRW9HTldxQkNFQW96Yklzc0FNQnRHcnlMbTJlZ3BhdVM4V2tZcXREWTE4dklPV3FaL3d5N3NZdGlJMHE3YUdKRldBU2VCQ0VFL0VCTG9kY0VwNkF4RllkNlliT0hEV0duNDRpS2xxZDk1WGhjZEdGQVlZSWluL05IaTJaS0NsRkJRbEFEV2p4V0l4QU1BdXd4OFVhblVoeXhobEtmV0ZWVjg5aThvVVVpQW1qVmZyU2Vyam9RTjFOQmF2RFZML0VCN09BR1RsQ0JIL0diYlRuQUJEeStaSVBEWjdNbFRSaHFzOGZZeEZaSEo0aVYvUldBSm5aaUxndk5BUjBNQ3ZESUdpRURBcXBGek9JSFBHaktHVUhKQk13NGh6M0NrSU9FWjh5SU1HMTU4Z3hBY0dHQ251UVllU1JLRHZHQ1JVSjJldTBRbzJmU1BkMFE5dnNDamx4TENNRURJOUFJNWlTbnUzVEFDSXk2VG16Q1hWVlBONkZNblNUWi9WV2NwSVRWaTJZbmpmL1FEcjJkRUcrYlRmYlJFZVNWQm94UVlDL2dEN1phaGpmc1Fld1VKZEV0M1QyOGw4eUpqOXoyaEpMaDFncmhRc1ZNaGdqUUNDOUFBbEZnU0F4aEF1WEVtRjlUMXdXQkp3dCttSEJKU25USE9VYVl3TWZMaHRxMmo5RENsNmg0U1NWNEVPK0ZoK21hR29XSklMTmJMWTBBQmlQQUNPdlFCNHNrUmNlaEp3dFJ4VVRxbFVacEdJZWRFR0NCTmhlYWhLcXI0VEl6alBURTJIV1lXWkd5VDF4cHd3dmhsYm5WRU95bDFFU1pVSVVZU3FMbW1aWFVpRUNPakZLSkVWNTZ5Qk5LNWVZeGxGRXVsR0Rpa2lDbGtTb0owYUhGTFFoSlNhemJodmQ5akUwbGtjeFVablVKMFdtZTV5cTU1blhaRlJpV2lVRTFWQWNST2ZHTVdsa2VlZzMvYVk5TWxGRWFGUmxhZ1pJZUVWaUZOWkJYMFZkNzVZNDM1Vmh4SG93L2l0QjBST2NJRVpBbWlGUU1VWG1Zdm4rMHFCR2JIcEtKdnBBWEFZdXc3aFBocUJNN29WV3ZmY3F0cnRndnNWWmNNWTFxemM5NTZ0amtjK3ZBM2tEQ3poSEpXT3pLTGxQRTJPeEN2dXpiK093YmN1elFUa1BLdFR6RVh1M1prZXRxbGUzYUxzKys3dTM0Ris2LzZLUGlydXpoYnV1ZC9oRVltdGJVenMvVXFCYS9ydWpxbU0zQW5IM25qbzc1ZnEycERoRzBHT3Y5Q0RROG1salp2TzZRL080THFZNjRVaXQ1NVROSlJZclV1bzd4L3UyeWpSTVpBWXNYRVk5MVh1a1pYMzMxV0l1dXZlOXp0dW9SWCtyK3FQRkdoYXFBRlZRcmk1QThaWUxZZkk4ZS95ZnlqWFhvM29GWHJiaFhTODN4aFZXSnFKa1VYMkZjbytYeHJoNWtzMnJ6Q1pIemZMVlRvT2p6RmZubEttV1JtUVgxSUI3MExqVVdCSDhVNktpWGR4ZFo0REZaL2dkVVVvOVpFNnJuWm8vbm1Nam1RNTlVaVhYS1hQL2FZVkZaSzRVUmgwaDFuTlZaWWNxZUJiRlFUTm1VcjNmUVdScWFISDVhZW5sNVc5dFRWTjlSYVk0UUlaVmpEU0dVWkw0UUdkZWVhZFNKZnkrcXliWGxjL1dRdERmd0ZJNFFldzZVSTdXZlc0a1FzdldIeEtrUUtVS2NrMC9sb2ZYM1BKNmhJcW41VSttR0hwNjAzcVlRL2tKU2tMKzRxNS82UU12a3dnL0VjUG5rNmNwNkt2ajZZWXV5Nlp1WDh3UkdISzVFSDM2Vk5VMkl4NitIZk5pVkE2VVFYdjhwbHJ5RkFMOEFuQzV3ZmpUT0d0QW5YSzRQSzVGRlZkeCt0NE5QTmRGZm1sWVpuWmxzZE5pdi9ZVnBFQkR1R2pJT0VQOFFEQ1E0ME1XSWZ3bjFZRExSNDhVSllTNWM0RUdRVUlTSWhBa2piRnlXVVpXcVdMRVNjc2lZc1VMSmtoMDZaTXFFa3RKTG1DaGxsdlJTMDh0TW5EbDE3dHhwYzJiTWhDd3pkVWpJeVNnc1dLSlFudHk1Yk5uR0NETXZUc1hJYzJmQmdpNVlKTEc2N3NBR0FFeGF1RUJ3TVNQSGp2OCsvaFA1aitSTVdQODRwVnpKMGlWTW9EeDlXdVhiVjZmTm0zY3BaV1Nwc2lnbnBFcE5NaVhaTnVQVHFDZ3Y0c0dUeGwrTGpGaDVEc1JKMlRPZUZoWjYrTlZUMmpRY0Z4YXIvdU5ZVWhWYm5hS1FHazBwdEdYL1Nid3YrZGIwMjl2M1h0eTYvd2tsS3ZlbzRvUVZUbko0eXhNakFoZU5BUEV3aldxRG5kUWxQK094U3ZsZkM5QXR4QWNEZ0ttM2FkTk8vQkcwV0xJMVNzY3lSY21HUlR1aHlycDJnd3ZYNjl1LzNzQUVJMnlvdzVBcVNUbTNPQWpKSTVtcXdzTUZCWVpBYjBJOTRubkJBZ3R5RWs4bjhUb016UUlTL3FOUWdldzRhKytzdEJKcTZ5Mm1TcUt2UHZ2K3lVKy8vZjZ6MGI4QTd4clFNT09TT2pEQkJSTlNKY1hNWExoa2c1a29SSzhkQllMSjBDOE1vN1NBRFFVK3NKSENQU2JpTGlFVC8xbU5OZmdTVEs3RmhGNDBhcTc3WmhUd1JqYi80Mis0NG83eTBTUzNZQk9TeUFnUWFBR0FOdlRnU1VuVFNCQ0RqU2Qza3RLQ0JJSVovNDNOQ2QyNExLRXR1Y3pvU3lGTEVvazVraEIwY2JZek0xSkpLSmtHMjBuVU52c2lOZFNTQ2lzUXVYK1dVOUNqRktQQ0NBNC9mUVAwQTBBU0xTbUJCSGJsbFZjMldGaW5WQXFsU0FDempDSnQ2cldNUXNKVU9UTC9NUlBOTkduTTZOU2ZTaDAxTDFRSkswNnVmK1pNcnM2MlBvcDFLaGNBWUZSSkdWZ1FRcVpmRXcxR2lEMjBWUWk5RVlKSkNGbWVJa3ZJS1diWmNqWlRUY3RFQ2thNmJ2TUxXM3R6WXhnbkFvc1N0MVVneTAxcm82a0dhaUVOcnRvRTlBYy9Fb2drRkRDQ0FPUUhFcHlJd2twNy81bVFrUVF3eklqZkJ0MHJhWm1QbUEwcEZ1WmFqWlkrY0QwZGJ1R0hiM1RZeG9tWHMxT3RpMVVqaUxJRFdwNnc1YjdRdS85RmpGNy9LVlNtaWlhdGFxT2IxMUtSWjRKUm9pOUdHWWx1T0xlY0ZMNlByOGJ1UE11aWdpZ0xCa21xOHlZTnZSclkwRW5aTHMxaURleC9BQTc0MG5FMzVjdnQ0TnBrV3lmR2VXTE1zU0huTm11Z3p4S1FRbS9PK1VKdkQ3OW5vaG53cnIyY2l2REN4WWFOUmJQamt1bmJvSEI2c3plOGRnTFZVMnJMakxaT25DSmJEWUhQUXZOSGhzNkwzNmswY1VMWHNNUHRLQ0tJS2hFSXgvbHczbkZ5WGVnQmZ5cWFKMjVudWoxTmF1UGFmU1lpVCt5YXNnNHRDS1plNDl2UGlYaVVZajdVQWcrYkwyZ3FNRjJiYVh5VU9JRTk4bi9Namk4Q1JJbHRVbUtmdUlpQ1RIRUwyRldTbFQ3MWdjRjlFOHhKRDdBZ2hIakpUMG9lRW84RkpQTC9RVHdJb3hIQ3FJaS9jRGFUNXBUa2V2NUxWZVM2eDczdERlZDdNb3BSVWdyV0xMRTl4Uzhmd2xBQ2t1RUdDZ1pSSnFob0FCdllFQXdqQ29FTlBxeUNGUFN4Z1FzY29CM3h5QWtqdW9RVHhDMG1YQmxoWWZaMFpLb1l6ckFEblFxWERWdkV3TWY0NjIvNzBscVVFc0FHdkFsUmpoa3hRVHRHd2FaMlhLSjBNbmxORnBNRE5PTjh5MW9KZWFIc0lQYzlsWFFxTVFWanpvS1lwVVB6Y1NnaFBRUVdDK1o0eVpiRkl3eVlvVlNsL05ncVFQcXZPRE1NSUFHekJURnJqUkdCWnN4SUkyT3hGcWY0cmlwNzNFbTgyUEFEVE9aU1czVndnZUFLNTVFRk5VYzVCZ3FrRjY5bFNwZTB6VzJKUk5NaXo5aVlIUHBybHNtU3lkWktJZ1FXL3dSQWw5dHMwd1o2K2JXMDlMRjZvRFNRVVFUcHdoanlKSlZrZEdZckZmVEtmeEh1Y3VlYkdVOFV4VTE4WGtrUFBlQU9PRDFaUGVYSTVqQ0NERlU2YlVlWFZVTExuU0o1cER3bEJhbDZhbTFYR1JGQ2VmSjUwZk9ZeGcxNlJKRmFRRExPQ2dETm5NWWtwRUhiaHRDTUlJV1IwR3lvYWg2S1BnOEdBNG5CWUdJb0FNQ0FrMEdnSFJqbHFlY21sSVEwZEMwQzRWeWRTVUo1em9MK0JXSW9HV05LYlZnU05CWk9saEpwUkJvQThJSUNNTUlOMUFIVTFIcjYxWndvNlErcDhhZGFMc1dpa0xvdVJvTXNaWnVhbXBCRlFoVTJMZlZTWldUUlZieWFCcXg3bFFtRlRKQUdaSlcxanozNzR3b0oyaTAyNVU2QmNtVm9QTnZqZ2d2a2xmOUNmS1ZzWDdGVUlpL05UVWgrUkpCYUQ5dVhIT2trZkRxaEswWmFFSWF1VXJZYkVFRENQeUpoRmZOZ2xFSThDRVYyQkhLaW9XNVdKaWZ4YktyOEV0cSs4QThuSXNCTXJTcjdEM0dveTBaWUdJRVp1SW1sWUNCclN4VlpEWkU0SzFEdi9mYVVzYk9SYVJWdzNIOUFRQXhVQThCTzUralhLdWlMbXJmTkxHdFM5RW1scU5VcXdQMEhmVThWTWJqMlJnUjRpQnBmUDhDQTRvRUNsMEdrMEFqOFprMWx6YVNCL2RPdVRPeWJLdGhkTDB4TVE4a1NLTnRhOXdXakR4UkVUeFA0b2Q0bjBZeHFSUU11Y044VXNibElXR2tNMGdnQ2hPR0V2YW9CRkVLc2duUGRWNW9hdkN0ckV2VkxmQmdzSTdjOWpEY1pHWExqdkZXVWNDRm54VFAvY2NFTGpNdlRPQVpSWDRzeW5oTkFvVjZkZEsyVHNhbVBJUjJjb3lJZkU4SklWdkU0TGRlQ0Y4UVd2QlBjc1BIWU1WN2ZST2FFYk1sVVJnU0twcFhnWmlaRkRuTkp4d3l1TWplbmNsNkRUaWhnbk04THZFdVhJVEplampOU0tPaytWQ1AvMHRtWTdOeGxJT3Y1eTBRMjhYM2psR1E2dmRPalhoTUJRY2J5Z21HdHVYTnNFRU9xTzFjQURQSnFKdFBGTGFWVlZHZUQwZVpUWXQ1MFF1eExLaFFqUnNuazh1akZMdkkweWlUQURnWElKZnU0R1dXOU9VRVROT1ZWbE5ZckV6bnJyR3pTbXMxOWdyem5BUFc1clVHNXpYRkNiYWZLZ2EzVW1QTk1hTmhRQlVhb1d0NGZDRVdzTlVnL21tazVmOU1yYW90a2cyY2FFVERjbmQ2Ui84VG1wSnhHeWcxTWx3dmVoOTRJQmlCT1VNMzQ3RWI3ZUtDUEkyNVFQTjdSOTc2MXpRRi9JeXpUSldYWWtNVTliaml0S3RRV20zUjdLNEsrRGtZSmlUV3djZkgwRUlwOFlvRWRGSFFFQUphSUllWTVyeXd0bnpQWkN0WnRJQ3RNZ0NiL2RjSGx0Smk0VVZqZEwvME9EeEhGS3lHSW9XT2RxNEc4cVhhQVVCQnE0NVI1M3VCU04xaGNjMXZYQVM4NTA3ZXJLcmtrWmt3SnAvRENuNE1TekxqeFY4R0lkL0V1b0R5djIrc0MvUWlHWjU1M2thandHM0VodDArZS9kenJrL01IeGFBZWw2Z0g3VHVxd3d2cmdEQ2VIaXk1elRod0V4VWp3TkRocFNmT3RQOGI0RXB2dTY4algzQkFveVRxQVpPVnBOazR5WXdFcTMxVzNpYTBkZjhwQXltUXhTelp2alhGVWhxMHV2Q2FKZ1BYM3BGalR5ZlhOSzI5ZlBFRC9JbzNDVjNxNDZzZXdBTkdpRDhTNCtkMzljcm5OS2NmVEc0dVNrdjJTK09MTlRNQ0FmZUpZOFp6eEhCUDlRQ0kxSHkvVG1TS3kvZ2Z2M3dBdEIzWTJZbEI2dzFzV29mU2NKOTRjSmNnWWdNcTZ5a1QwQ00xa2l2K1F6NXJhVDJhOExKU29hZVpTQUJRZ0FEMG9DQVNpQVBBS3hYMys0Y2FZQm13ZWdHVUtMcjlVeUVMQktBQUxMKytFQisrMkRKa3lSQTJDSUxKQ2lJSThJUGlBWUJib0N3M0VJYVdzNHIrOHpZQWNUQ2VlS3VjaUk4SnBLV0VFSmttNkVFNWlvSWdLRUViNlpWSWFMUEtxZ1BmWUpXUkk2UTk4d3NaZkNydzh6R1U0TUFXQ0FiL0ovTXFYV0lIMytzTktlaTc0OUtEQTdnaS9mRVBJVFBEQTRLcnhXcWxTcEdxRXlrSkN4QURON0JDakhLMm1RZ0dQd2dGZmJpQUtLQ3NyZ0lBVHNLaTNSTEQzZWdOaFhtckJEb2p0cUNyekVpSWcxQ1N3QU1yeVpvUUV1Z25CZnVra05xaWhzbXUrMENnUUNTMjBvS1VmbkFDVXp4RmZFcEZ2SktDRmxpTjNGS0wvZUUyTGhwQVBtUVkvVkFsUUZ5Z1VIU3N6SUlRVEZCRVh0UWxYMlFIR1dDRUFuZ0JORWlEUmhpTG9SdWNjQnFZeGNBdXVlQVI3bUxDbkJBZ0d2RkVCUUxGVjJJV3drR0FTNUFCYXF4R1RJb0NFdWlERFVBQ0FHQ0JLb2dFWURtaW1NRU1qdE15N3h0R2tDQ2JjaVNta1NxVjJXbEgyb2lya1hpblcwUUEveElJUVh6Y0pnYXdoSWw2dE52N2grbWlycStKakk4NHE0YmtvaTRpREJ0aHg5dElwR2FFUjJJa3hHZ3NnQVRjeUZ4U2c5RGpDZW1pTmRQUmlIRDZxQlFLcUJWYVNSbGFSeGlTQ1ltRUt6U3NtSUNCSkl4b01wek1KUUNJTlVtQ0tJRWdTWTFReUdCcVNMVjZTUFF6bW9qc1JGcGtwTG1DeG95QWtLbVVveDZRcVYvaENlOWdMMkVNU25JY2sxQVNwUmJTQ1pOQ09XUHl4S2EwUmJTRWxEVGdnYldrSUorTEYwaVRpUVNiUG9Vc3FzVndTSE02Snhra3d3RlNSckpzSnA5aHJKdVp3SCt3ZzBPemtROW9CL01xekp6b2d5WFNvTy9Jc2tKc1RKUzB5M0tLekFGaEswMnJUS1ZjcHZDcHhad29uMzE1UUpTUUJSTTRnQjdZQVA4NEFJTXFTSVkzVXFJam1oZDlHRUxTbEFrendBSW5pUklSOHd2VU81QzdORW9EV3NlOUpMbmF4SjNSR3A4VXdna0VhSVJMSUtFUGtnaWdneUFweWFBRUVJSTRHTERteklnc2xFNkRyQm00c2M2aS9COVNXaE8xVWNvRHdzendrd25LaVJXblFiYUdpemxydTdxTXlKb21pTTkvdUFBbnFSOUorNXFjQ0U5UWdrV3dsQ0hackJIZklLQjE2b3VvcTd2Qm9RcXMyQTRQcVNhVUVJSWV1TW0xNUlGK09CYnc0TGhDZkl3Rks4WVZTaHVTa2gxa2dxR0hTU1djRU1QSmliNnppQUFTNVpJdVVaYnBwS2dHZ01PTnJJSG9NcnlPTTZFR3NsQ2MwTTl0S2FUKzlFL1Jvand0Y2lVaEdaS0xrYWZmMlNNa2xZbGdZVko4N0lQQ0k3di9nUkNjYkt1MHRETkd5TG5TSFFXamszcWRra2d4SUhXVnBURVg5NUNsa3BCQ2tKekNTR2dIalJRaU5HVVRHYkNERnJnZjc2TlJGVEd6UEhXVHg5RVdaSW9jL09xUmljbk1uZ21Tbk1HVGt0aXlrSlFvTm9pc1E5VVdUR0FITjJDRVBnQUU3UXNGTEFBRlVOZ0FRQ2tWVEFnREMyalQwNEhVZmtPSkpPelFTbTJaN1NRMzJKR1RwRUVRVnhwUVVKMFVEY21JWUtDVlUyMlR2eVBJdDB6UlVLakNYYlNSc1NvTHhPTlZjaVNUZi9PVXlSU01PbldjVVZGS2REUU94TmhVYU1HVUlMa1QzWnkxa2hDUEJFaURlRWhVLy9pQXFzd2duT0FWSkVLQ2U2M1Y4eGlCWGlJNnNUbXJHMEs2TWJ4U0NrcW5IaDJLYnptVGRkM1RpbnhYLzJLTVY4V2NtUlpRQTN6dERVWUFoWHM3d1ViRUFsTVZXSjNRQXhtQUE4cFFJNEJwbHA0QlY1Rkx2bXZCS0lOeVNZaFZ5WFZsVjhhSTFKejRrdEx4am1BQWhIdjBpL2s4bEp5d05rTU1CaFpJeE5TU2lRSmdBcklnbjROOVdaaHR2QXZFQ2ZxaVdjc3NqSWcxVm9ybG5maUFwRUxzRWdzSWhRL29XSjQ0QU9Pa3p3M1ppUk45TkJlQUEzYkFLeWRBZzdhZFBsdUxWTmE1TkRLU1diNmt3Y3FxblJiaTJqaVJrL25ZTFowUVc1ZmpqQlpnaEtIZGlUcUlMZzZLdEw3WWpuOXdnVTBZQVFRc2pYWFlnRXVJMnAvVWlYY3RtUG1JMmU4UnVKT2JvNnd0S01FbE4rTEkwNGtWWFptQURLOTVOQUI0WEp4UWcxK3dnT2JwanFzb2lQOFcySVEwMkFSTzhxVzVzUzR4K1JsTzhUYTJhN3ZWdmFUVVpkM1dkZDEwVFRHY2VBdUdla3JVdVJ3WGFJRkxVSUFOT0lDdDB3bDkxWkxQd0FwQkRWUTlERlhvd1RhMHVON0V1YlNZOWR2cGRiM294U1Rnc0lxakdkeGl6Uytad043R2lxZnQ5ZG5MZFFGL09JRS82QUVUbU1hTXlCTDBYVi9URVZWU00xNlVnSXIzZFkxS2k5OUxNNDVxQ1RJaHkxK01Bb3pubFY3TFJFWU5ya2lCR2JYQ29WM0p3SW14YUFFbThJY0loaDRKSGh6T2RGOExkZ3FuNEtPY0dSc3UrMVhtWlQwU0ErR2VFdUVSWmwzL05HSGNGQk9CVVIwZHZ1RWo3QmNMUmgyZE1DRWR6b21jV1l1ZFdSSENnb3VnNldBTy9iTDdMV0lqSnVMdGtvbmNjYWIvYU9uVTdHM0JLTFlSSFRZYzFjSGlMTzZqTFhZTVRLSFNKdlJiN3NUYU1kNnJNZ2FNLzJCR3BwUVdoWEtueGlnWExMNlpPRzdrT3U3aDNyamorTWhqVE5FSkJORkVjVzIrbkRCalhpeGpkWG9kUWk0alZwSzk1bmpYR3ZXTk80WXFQYVprUGNZSmFBbXArQ0ltTGYyaVRmNWpuUHpqVkZLbDhFbUtkd1RQVnJZVVNkNFpWdTVpbnhHdW5YaGxaSjZQRjVHdzlNTlJ4UG9MV3k3TWRDSWxYZDdsK1Rqa2xrSG1HK0lMYlE0b1pWN21nNW1KTTBuWFo0Wm1COVhmU3hXamFuWXFYc1ptOXpsYzZ6a1llUll0aVkxTUUvNlBhRDduVWtyblhKWllGU0ttd3pWbW5sQ0tid2JuU2VXTGVrNW9VU0puN3huWE10Um5vc0ZTRFIwa3FHYktIUmowVlhuT2FJMCtHSVcyaW5yR0Q1REdqNzZ3RFlmZVpJaE9Sb21lNk1qQkR6S2laNFh1YUowQWFaYTBFWkt1NlpQT3BXQkZwUTJWa1U4YjVKQ3U2Wkl1SUtDMjZiVzVhVXV0WDJVS2F0ZWxpMDhaNnYzOFpEbENhcU9HeUpSdWFLVjJuSncySG9lUjZxbldtNnJXWDJEZDZuSkZhYkhlNnE3ZUpxNzJ1ckwrNnJQVzJtSEYzM3h1NjQwY2ErUHhaTG0rYXo5dWswQVdZYnp1NjViWjY3ajJhNnNJQ0FBaCtRUUZCUUQvQUN6dEFNa0E3UURxQUVBSS93RC9DUnhJc0tEQmd3Z0ZDbnBqd0l2RGh4QWpTcHhJc2FMRml4Z3phdHpJc2FOREl5dUNFTWxpeEdQSGhDZ05ZdnBIQTg0S2t4WXB5WnhKczZiTm16aHo2dHpKczZmUG5UQ0RCazFKRU5PSGZ5RHlOUlFLOGVmTVRGQ2pTcDBLdFlQVnExZzdjTnJLdGF2WHIyRERpaDNMOVNyVnMwNlpxcFY0ME9pb2YzdGVybjNZODJ3bXEyQmg2WVVsU2xTRnY0QURDeDVNdUxEaHc0Z1Q5OTBMdG9OZG5uT0ZmdmlBNmgrQkw1RWw2anlydGF2ZXZvUTVpT1lRcTNScFZhaFRxMTZ0YXBucjE3Qmp4NDVBdTdidDI3Z2p4R2FkMnZSb3dxSVlkM1U4RldqbTR4NTNUc1hMOWZOZzBhZFZMOHN0b2pvQ0YzakM5SW1uUnc4N09OZ1JpUDhmVDc2OCtmTUk4S2hmajhmRmkrN3c0K3Y1d09nUEV4Y3VFRlFYY2R1MTZ0Sy9DUlljTEY0Uko1VlRNaUdYM0U5VU1iZVZjNEdORmwxcnQrM253aDd5WmFqaGhucnNrVUFDRm9RbzRvZ2tqdmpoQlJ5bXlHRWQrWW0zSDMrMStkZGJMS0lCcDFlQmp5RklTV1JPMmRYWmczdzlSMW9zcTluMjRuanN1UUNBaWt3MjZlU1RUenF4aVFVdHRNQWVIdVM5YU5zeXF3RllvNERDbFdVZ1ZUMXh4Sk9QUHdMcFY0VFFFWm5hZExVZGllUjZWYll3WWpBOVFLbm5ubnltQ0FZYklKSllwNVhybGFkbGpGek9HR0JnQXhZNEpsVEdWYlRaY2w1QnlLYWJxTUVacDNWenFqY29pUjkrR0F3b2VmWnA2cW1uL2dBS29LR1dHT0tnc0JML3F0K1cvOUhJd1dDTmxrWG1UWkxlUkdselFiSkptbXBHNG5FQ0Q2Z21xK3l5ekpvYUJSTjRWQmVqb3JjeWV1TldqK0trR1U1U09XaHBCVzIrdVNrZWFhelQ3TG5vcHFzdWZFNElNNnR1aVhvSnBwZ0g4dHFVcjkwQ3UrWmY0V1phR3dKTW1MSHV1U093d1dxb0NDZXM4TUlmQ2lFR0l3T2J5Z01MTGVvbkxXMkpxbUtydFFSaVc1eE4yOXFVYjNQN2dqdGthcHVLTUtjRnAvUVJjWk1tWUJGTXdxNktHT3ZOZHRhY01Cc3NmUEN5ZkJERUVjeXJWUmJxSW95NktUcXZ4L1hXTkJHK1VmMm9sMkFuKzBzYnArbDVXcVdKQ1FnUkJBZ3ZJeUVFellMR2V1WFpXc05hWXNKQzZCT3hFNkRNL09HSVJSdTkzN1NvYlF4WWNNTTEvKzEwUk54R0xYWEovV3E2WDZkYmk0Z3dHeEJFdk1IWUNKZDRNOXBveCtvcXdrSXNHZkVvWXM5TWQ5MVlIbzIzeG5yL3hUZlRVV2tMT05SM0FVdjFoSWFyTEI2ZGlTY1FESVkveDVjSDVLMjZpdlB2TlZ1QThLamk1SjVpRDNaZ0Y3ckZTRk5yYmQrcDIzdXZ5RkY3Um5qVnNjdCtIUk51R0ErbEU2RUlJVGZEbHpNc3F0Zm1ldDhuS2lmZ01icThnVjNMU2JiU094UjQ5UStXYkRLbXFoalpRcW5xQzZBQWx5V0ZGbHdzYVhrclhRVVdBejFJcVc1Nk5ma1ZKNzYxUCtsc0NnSEM2TjRBTjhqQkZNVkRBUWFrVlFLL3REZjV6ZTlqOWFQTC9mQ25KcXIxaTBJWHhJUGFQbFcrVUFXRERZRG9vUEhFd1krREJlcHpoRExhMGYrUUJpL25nYWxqdWtJaHlHSXlxWkhwS3pSVkUxZkt0RGM3OXRCUWNiYXJBaXAwbUs0bUNBK0k3TW5TM1VaSHVrV1p6b1R6ZTVRRGRXS21NM0VtVFMxMFlSU3ROa1h5V0hGcndTQUJGOVAxZ21DRWNUeUhvazJYRkhoR0hPV29UR3RCa0YzdWtpWUs4dXVGTUx6YTRjYmpBaWswaXhGKytHSHdMaGVNRVRBTEFpMWduZ2hIU01Jekl2R0VTa1JrUjVhaUZoMDFxSkhCRXRhRVdxTXBTVm9IUDVlQUF3bGtrYUk5S0k5eXdMd1Nlc3FqSkJOMDV3TWtBTUIxbUhkQU12cW1XaHdiRHYwZWlCeERXTk1RUktpQlhCUmt2eVk2TVk1eU5BMXZhT21hM0pqem5PZzhwMnhlTTg0WmVhbVVKVVNqR2lQRnpZZGM4NTdYVE1VRDNzSC9TZ1c1Y1Rsd25LQWpEek9hZ2hyMG9BWk5qRUlYdXJmRm9CRmJhbHdqRytzNWtWY1FJUlUrS0lVRUpJRFBqcjVpQjBBb0NYSVl0TWlxT0lnc0tFMnBTbGVhUnF5VU5KV1FvU2hHYmpBQUF0VENGS1NBQWkwdTZvT05kdlNuaG5qRk9mZzVVaDJSRktaR1RhcFNZeXBUbUZBbUFLeTR4UVFTUVZNQ0ZNTVVoOUFwRVlpUTBZMXlGS2dkTGNVcnl2Q09iVFlWSXprNXExbzlrZ3NES0NBTGg1QkVMbVJLbExvZUpBQWo2R2RUbDhyWHZpNTFyZHkwcTBvRXNnZFA4S2l2TDAyc1loZkwyTVpLTkMyQTVRaEtNR0dVZjZCQ0tZZXR5eUt2a3RLOWVQYXpvQTJ0Wi90QzJ0S2ExclNNT2kxcFFTc1dxeXpTSjVHdHlFQ01jaFFhLzd4QnBKbjU1emYxcFQ4aElYUklwZ211Y0lkTFhIRzJremZGdFZWQkRaT3JCdm90aGJIMWdsNlA0ODJxZUlZdnZaVVEvOTVVeTNTKzZMdmdEYTk0eDlzQy9EQlRuUmxMSUNGTmFjam5RamU2SGRHdGRaL293bGwydHpybFRjTWVvZ0NsZHJEQWozZjhuWUNyRkF3V0lPdFVCeGppS0VtMzN1WkNkRmM2Mm11UEduVGQ3RWF4bkNramp3dHlpQzRuVk1HSERCTUNDOUozcmo3ODBsRE5SQ0Fwb2RuUVV6NzRrRXhka0h3RmQxMVkrTmErUnNKYTF0S1dBREh3ZDQvTmlrY1ZmbGduWVFKeWpNNkUzeEcvRXRGTTBKT0pPWGxscFdJSkdFaldVazVWVEZ2T3NPZzFJSitMSFFEZzNkeUFHRVQxaURIRjZWVnlQTnNiUFdxdWp2OTE4d1ZubFMrY1l5b0dlTXNoWWxzRHZNem5KcTBqRGRGQ1dzYlVYTWdrdWpkQklZdmdOeW40d3RpNW9BQjlqclQ2Mm5HSmQ2bFlZL0E4SGVvZU81TTNLNXFGRTlSZjRUYmxnZzFJV2tWcTBBY1doQ0FFTmdSamZNTmpBNnNMdk45VGIyZ0RMampnb0JYWTNERzVlWVd0ay9NTGMzd2RGaGl6ejQ5YjJDYVh6YlhoK2FGNEhRUkVNRUIzNVBmUmFHbW9iRE5ORWswVENWSjUyQmZNY3Awc3dJWlF5Q0NBdXlOYjJRWXM0Qm8yREFrdmE0Y1lEdlk1SVNMWmlJWGVDbEozNU9sdXMvQmIwSkZpQkxCR096emJNQTZPaUZnb1FMenVJZ2Z6YkpZRGxRMnh3STZCclVNTTR3T2ptVVdIc2Q2VXN0ZUg1amNFUHgzc1VGOEtVeG4vRnJmQlA4U0dPS2poWlhzUXN5YUo5cnM3UjF6aUxHZEJBRTBnQlRaUWlkb2NGeVFwbjhlVmZYUDdLZisyOGFVRVBrbmFzYUVPbU9pZ3ZCbk83S29MajIzdzdqT1k4M052ajdPNEF2S2I1dDlVU0wwNG0zek9zQ00xSEd5dG9TVDhnQVdnbURXc1k4MXFQd0FBQWo1amU0Wk1yR3V2czFqVDJlWTBvc2xPOHBLZi9aSERRbG1jeEFNeHZUdStXU1F3WU4rSFR2Uk5PL205d0lhbHFPY1lPNEFkKy9GOTNvT3JJN2R1STUvWDJ2QUUreWxkRzNLUkg5M2ZpNTVhT1BsMzVVbG1XY3RydzF3bzJnRjZQWTJBZHczLzR4Q0ptT1lHeXhNdGFVV3JjaWc4NWQ3dUQ4ZDF0dk9kRlJjSjN2ZmVTUjhJeGJRZHZuRUZKOW1NZjVGbi81TlZHVitmYkJhT0E5VnVrYUp2eC9VRWc4UG53a1FOWkw0d05tQ2g4U1VPei9BWFRPZ0ZtakNpQ0VKUlNjVVp6WGRqdEZjaDF2RS9xSUlLQU1BRzdQYUFkUklNYWVBRVVMSU9mUkFHNVdVeC9FZG9ET1JjbHhkalFoRlVRV0JXMUxWOEVnUWtVR1JjQW9lQTMzVWRMaEJLNHhXRE1qaURSSlFiN0RSSTRPZC8vd2RoNzNVY1AvVUtEVUNDL2xSZGpGU0FoV0ZRdzNWY1NyaUVySkZjeWZWYmh6RWdMc1o2KzlacGErVlZYd1ZVWTZVRWN6V0VKaWhsZVRGYXFNVlFoYUZhWm5pR3BpVmFEK1VvSlFWYjBWVU1yWkJURnRWVldRaFUxWkFLVnFBQVF0aEtSdVZZZnZpSGdLaFlmQVZmRThFS05EQUJOQ1VBMG1BS3JXQUxPLy9GVlJwVmgyQmxUYTlnQTJDd2gzUGhWNXE0aVVsRmlHc2hXS0JJRUk2d0JKam9pWm5JaVc2MlZybUFXL1VVaW5YVkEyVEFpcG1GaXJSWWl6OWhpaDdoaWdXeEVtcndCYklvRkxhNGlZSDRoMzJGaXhmaGlrZnhBUzlRaWpLbVNNUDRqSytVRmRJNGpkTG9XQUZvakJGUlY1WEZDcGgxaXViM1VsakJVdUs0VW1xb2hpcEZoVEQyWko2WUVFYXhFc3VZVzVyMVJtSVJXcVZGaHZaNGo0cmhVR3VJanEyM2JiaTRpeC93Rm1xZ0FrVkZoQ2IxRlhzQkd2ajRXd3paa0E3NWtNdUZHRkxJaGp5WWlwSDFEN1JWR1Jzd1hkNEliRVZZWTg2SGVOcVZoRXhZa2laWmtzSVZrYmdpZmhXNVJOSDFBNnp3RDREQWpFeEJoQ2YxR1JiLzFpYmJKUjBZbGs0KytaTkFhVTR5Z29PcDUxRFMxSkpqaDQwMUdXVW5lSGh6Qmx5cjBWMElLRVBxSVlQRGRKVlk2Ujd3WVFJRkFBWWlnQjNnaFJ0RFdVWkZlWHhJMllOSzJXOWxkNUQwZFhJOHlZTFgwUWh3MEFUSGt6d1BkNWZBRkF4MWtIZFB3cFZlS1huRVI1UzRBbmlCcDIyMzZJbEhCV3BPK1VqUXQzZ25RQUo4eVNlbzhBZERBNEdKUXlMQklBWVVtQ3dma0FZd2lHUWRSeTFmcDROc1pwaUhXVS9PMkMyYU4zc1dsSElYY2k0UXdBOURFendLSXdSN2RpNkFvRHhuMWgrMWtvTU9sa2F2QlZtSk5HRW42RWhXeG41VjVBSi9zQzVtd0FMaWt3Q2E0QWY4RUFsWUlBWlZFQXJRbGk2TWtBQmx0anluRjVycTVac3MvNW1PRTJVUzMwaUExbk5qYjVseXQ5Y0NDUkFLMTllWC9jQ2QzTmQ5MzFsRW9qbVk0M21XU2FsOFg2aWFVMmFBcldsTDJqTjlJYktaOGNrazJoZDhRc1JNZ2RtYlpUbUZBRmllVU1hVUFHV0Vicm1DV0xaak1qUnVJNEpEQ2Rvazg5YzdaR1o2OTNscDd6UVlZV0o1SDRpVzNXU2hOTVpiNFRTZ0EyZDdWM0pGZVJZcUloYWlUOUlBejBtaU5sT2YzaGxJS0NxZXBkbWkvVGx5aFdkNHhrbG5kZFFwSFhxWk9Tb3FiSUE3UE1vbmFsQUZZaEFLTEFBQVFZQUVnTEFCQlhBQkVNQUlUZUFHN1JBRlBKQUU2eEFQc2hBUDY5QU83Zk9nWlBsMURpWjJTZnFpYThta1ZQWjhHcW95NVlVZitQRnptK0FQL1dDZDE4bWxMQUFHQ3Y4QUFBRFFBQUZ3cFh2RURvQTJlWG1UYVlDSHAxYW9sakxCZlBrem80cDNOUmlrUVpKYXFsdkpCSmFtWWh5NGVxMzNlcFJRbkp1WGRwTGtBblZncXJZcUgyN1FDSmEyYS9BVWRyNldRcGtuTlVxSGRwZ1NPM2p3Y2xmNkFTYWdCaGV3Qnh1d0FYdndBeERnQkxkUXFqMFFMYWlIYllIM2EzRFdTS0ltcXdQWEFnclFleVlRQk1GQWYrYXpNT2NxQmorZ2R3ZlFENEFwYUY0WFRaWUhyTjNhbG41S1J5TFFBbEx3WTVMMkFUVmdDZVpqZFZpa01LL1dya0JXQndDMlBKWktTSnFtcWE3bkJUQXFyTmN6SWV6cEFreHdBRUFXRHd1bk1BUkxzR3pEQUJ0VUFCL0NmZFVHbmdDQ2JSRHJxZ0Q2cWNRYXFqYnFLUllRREgrd1JRTC9kQXNmcG01a1pwbDQxbXc1dDBOWTRIUDExbjNOaEcvK1oyaUN4N0pPSkh0VkJxNEVsellpRWd4eDRESzVJdzV6NXp1VFF6azQ0MjYyazUzcXdnaXdwbkZISnErWCtuZW5aSFNjK3FwSlY3Rk14eWtGMTJ6QmdBWCtxaTRzUUhWQkNpdDRxV1VlNnJQbFpyUHFZZ2F5Q2FTZ0V6cElObWdmeDZxbU9YaUVCM3RNV3JGdWtqM3R1WEsyRXd4ME9UQmhwck0vaDdkNUc2VjdXN0FKd0FaaVFHTHBrbjMwZHJmMlJyYVlaclpJOUt2MnVxZURrNkdRcTNJK0t3UUl1eTR4RTdZTk55aDNlVE81cDZOVSt6TTkwRU9tUzdTb3EyWVBpN1pLMnFsSmw2SDlFMjQ3SnFVekN3b29ranZwUm5xNXk3TTlPNlcyNHdmbk5rQWpVSm1uLzlzOGxKZHYyd3BkS3lTc3IxT3N6dnUyYk9CSkE1UnMxbHN6d0xOSk80TUYxc2RGTWhBS0ZWTzQ4eG8vcXh0eVNodG5UTXVZYlNzNzdpY0ZGYmRISkJBSElEWnpIN3N3SWphM2ZSWVBBSkJydG1HMHFvZTBTTHFwZXNxNDNzcThjUElpNmdGQXA5WURWZEJxNlpyQ244c0dDb0NnamdjZXhjdHJZWWU4SFl4MFVaR2VUNm0rVjFOcXBib09iZ0FCUDdBQmdBQUllOUFISkNBRHZIU2xNcUNyUlBRZm1ZYTRpUnV4bWVjNklEd3VlblNyV0R3Q3VkYkUvYnRtOVdxKzkwb3k5YVhETllvQS90QUdXRnlxejVLcXZHcW5Pd2pBQVd4MmZRcEp4SFlKM1p2R0FiUUJqZ29BWUNBRkxNQUNvWkFHV3RvUGRyQUpXeU9vZ2hwb28vL1VmLzhIc1lxN3VJekxwNXVYZUhRMGNBRGpCcWlReWFnUUQwbkFEbEZnQWpMUUJHcEFBaGRRQUhzQUNFZ1FCQUFBeUdJZ0JpU014eHZTQTNHRHVicmJvS0NaWnVEM200Nzh5TW1ydkxGblliQlRlOUpYY05sYm0za1FxYkRjSFFGTHkvVjVablJLbGlvcW9md1pzYTdxeTRyWnBFNzZwTGZIdWIzN3VmQUp5MzBBS0F4cW4wUmFmQkY2cElMbmp4ZnhuMlluVUgxcU1wekhnc09NZTNmU0R3bWN4bVl3bnpRbmZQZHB6azhzemNoSG9mNEpveTBMTE8rc2Z0d0ZsMURLelNGU3VYZ01BTnNuZk9VTW9YWkttRTIyd1JhWkVlY0podmlhdzdRbnpQTk1ZTCtMTGpMQUFscUtCVmpBRDM2Z0NhRHd1VlZBcXVpeUFRczd0cnovR1o2amFkRUI3WVo4dU5FWFdtRUNtdERhbkRVSlVLdm5zZ0VObks2ak10TEtBZ0VXUU5QZmQ5T05QTTB1dXRQRVdkRHVETXpiQmRLemN3a0hoaW9ta0FheitiRWx3Z1lBMEEybzBnUUtvTWdYREtIUmZKUlY2Skt4MVllZUttZUkxNWkyRkVwaHNBSDMreVRmMjUyYiszQVdzQW1ReGlFeU1BS1hBSlpFR2dHQ3VXUWFqTkhxSEJrUE1BTmQySkV6ZHBNSERVbVJORVg3MFI0SUVBWjdjTDk3WUNWWU9kcWtmVFJSR3BaaVdYd05odFA5U00yWllVM01nQUpLSUZQc2JIaWhscE96Qk5Ub2hEVGloWUJCK2RzWU01WVVmZE1XUFUvSkoxUDRsQXBab0FLVHpVMjFqWDd2TEpMQmRaS1prbDdVZmQyMUVsd0hWWVlyV3BqcC84ekJ5UDFURWxBS0FNQ1I4RWpRYkduUUlmbVVCK1dFN2cyUjhKMVFDNldQVERhaEF0MVVrdWhSS0JCU3FEbGpIemxsT0ltUEFqN2d6S1dQM1UwdjVEblYzSVJSa1RpSlFaVURYT2lGL3AzZTgxaU9GbjdoNDVqaEVIWFIzNjNnOVNTSFBPVlZEdjRLYTBCVUpaaVlKU1dOR3Q1UzFEaU4wTWhZUm1XTU5vVlZqc2hURGU3Z3BaQUtER0Rld0xoVUwvN2pnRmlMYWVrUWlEZ0FBckFBY0VnS3REQ0hQWlhmUUpWUittQUF6VTNad1ZqbFZwNm5RKzRGVUNWVnExQlZONVZWTzhYZ1B1WGcxeVFCSDFWV1ozWGxhZzdlc1dVQURzQU5kS1dMb2JnSFhmQ0xXWDdpMTJpS2JvNEVkcDRaY201WHNNamphN1htaEg3bk1QSG5LUCtSRGd3aGdJVGU2RXBsNkJpQjZBZXhBWVpWa0k1KzZYNEY2Uk1oNlJqNUQrbEFBWUxlakpqdVYzNUlpNXJ1RUgrK0V2OXdBVjF3M3B3STVMRGVXSU1JNmJxbzZqTTVpNjRVNjdxdTZ6R2U1YUJZV2FqZ0VyZ2VqMy9ZNHNaKzdBRzE0aXpPNGEyTjVldW9qVWVoQzBzUTZtMkU0dWZIV2NxZTdkcSs0Uzhsbk1aSUZKV2xDOTA0bk1TT0pzbk9VaGVlN3VXNFd1aytGbWFSNEI2dVZwT1ZqSEJBN2RWZTJ6RmE0YUtGaHZ5dWtBUmU0Rks0aHNBSjc4NStrVzB4R1RKSmsrVTM0ZjhONEFIKzd4QVA4UVplM3dULzJQQmxFSlB4RmxOQUNKYnVrUlN1M3Y0ZThRc1YzMURJVUVicEtNYXRqZ1l2RUc3eER3dndCVk5PN3VqLzNmQkFFdDFRUlBJTzZkNDZuNUlJRllXLzZkMk9iZkVHVDF0djhRZjJMdXA3MnM1WFRWQUk1WVRZL2ZUdHhQTXFlVVJUbU5Od0hWc1orUStUd1BFU0RtYzAvL0MrcFpPNURmWEh0VTVtTDl6anBOMDVTSnB1M2RvWEg1Q29nQVpIYjU3b0RkMGhPWkk3eVpPekFkeDgvNU93Z1Z3cHVwSlYvOWF1TFZNclFBR0EwT3JPYlpNZ2FZQjVUMDU5RDVRMGlOcnBoUGFCejlndjV2YW5mdTlKajM3T3A1T3MwWlBVTWZta1AvblhVUWM5c0FTSC9abWdpU2hFQ2RXRDMreUZ2L21RSE1sMkx5UXFXTWxUbEY4RmtBSW53SFdsSGZ6bzRRTHVLeDlPNEFIdHczV3RqNThySnZodEg4VVpmZWZzdkpwakhKVzRjVGo1Z1FZa0VIWHkvN0VCVmRKK2YzMlh5dWtrU2RBRGFOQUlMNmlCQ3diTm1NK2lRWC9jUXo3OVBpMUxCemlWR0RzQ2U4MGhCNUFHdndRUWVBUU9KRml3WUF1RUNWc0VBeEJQejBPSUVTVk9kRk1IandpTUVUUkdXTFpNMVVkVnNXSng0RkRCNUVsUm9tQnhZc215UTRkTU1XVlNvbG5UNWsyYlhuVHU1Tm5UNTArZ1FYbmlKQ3BUWm9lV25HREJFblh5SkVtUklGVXQyN2dSVDRzd2ZSeE81Q3FSSFlCZ0NzV09KYXN3V0pwMlhkVnlqY0xrSWtZUlZTTklEVG1TcEZPVFMxZTJmR2wwSmxIQU5ZVU9KZ3cwY0ZHL1NKTXliZXFVSklkWWRPVmlkT0ZoN1dXSkk0SWxzTkRaODJmUW9SUDRZWVRaOUVNRkxoQWdnQnUzS2wyUmovR21YSnFVRS85TXZ6RVBCeTdjMi9EdW03bGZMbWFLOTNIVWp4MnJ3a1hnWXMvcDAzMDBCUXRkL1hNQ05odWduLzZqZXZWcXVGVTdTbzE5ZDNidHBIMXpad0tPMC9mNzlqYlhLMmE1dFBGVHFKRkJVdDNJZkxVTDdiWXpUUTBzMkVqZ1FBUVRURkNJR2dROGJROFhCdnFPdFl6RUk2ODh2Q3FnYlMrKzF2dXJ2ZmNJaTYrbStZaTdEei9ra2x2T1B3VHdjR0VFQjA5ckp4UWhEZ3ptUmh4dkZLSUtFMkkwclljSUNmcXVOYms4QXFtOGtqSlVpVU9YY0Z0dnhCQi9HcEVTRCtsVHFqampJTk5QeGY1WWJOSEZPbnc4TFFvUzFHakNDUm5haWFLYmRXVDVRRXpURHJBQW9ZSW1KSElqSTQrMEswbW5sclR0TmlkekF6RktuYWFzMGpZc0hjdi9UNnJKTUpxUW9BU2tnSE5TU2krVHdZNDU2WlRRemdyeGhHMVBKZld5VFQxQmdTTTB2aXF0dEMvRDQ3WlVya3NSSGgwSW9RVFMyS3BTWEhIbFFRek9NbTJoemlIRHMxQlAyVUpsMGlVUFRZVVB1RlFSVFNsTExhWGlUNlBXWkwwcW9RVHNrQ0ZYYmluOUlCVHFQRk5JeUdBNzFTalBqNUEwOXM5QVArU3ROMmJuVTNWVlJhUGRiMFZIVnpzSUljOFNVS05iZ01Wa2dZM1F4dDIwWE5mT1JWZmQ4NDRsMWFqZENvczNNU3VWZXJiZUZLZkNOOWJ2Q0VvSU5EWUtDSGhrQVFFd3NOZlBERDZZUW5NNXVyRFlQdEhyc0ZUQVJEeE1Ya1FUUlhGTGpXSGxXTjlaUDc1T2lBWklOdG8wSkN4SnNPQ0VnQVZQV0UrSjVSTWxQMmYyLyt1d3dXNFdMdWNUVFZyMFhwK3R2WmJmNnc1a1E0R2owMTVMbGlDRTJBeEJwalZkK2M1elg1N2FwS3FicE5tOW9MUk9qT3NzUlhLMTBaKy9GRWdoMEJKa0k0N1MxSGE4cXczWWVQdkF1SDhsOTJsejgyUVlKWmtCdmJybXZnRVRidDZ1V3dXYldpODlGcnBmQkcvczQzSFkxWUxBRDhuWnNQMTIyemV6QUk5Ti9PbUhDU2JTU09NRTRSdGhiZGgwWWNhNzg0ZlpBOTBudjJPcW1GNzhJSk1XWDdFUkw5dEdJUUNKL1h1MWJtSG5UVEVMY0tIVGhaWFhrUG5QaWZvTnNhT2NMZDNlbmxFdlBPZ1dMR2o5UnR5RnNFUWY4QVdRWkJES25OUWFscDcyM2VSOXdmbGJTeGdUdU1HaERnRk1VQUFjUnJDQkFseUFCSXhvZ2h2YVlmK0dLTEJqSGFnZ253Qk5tTFlObkM5aExrdVhYYzZEUUlpNUQzcWlNd3JwSUhnNnlnVG9oRHZrNFVNQW9jS29KYzg4SitsY0FoWFlFeG9lUlZYelM5RzBNTklDdFBWUWlqc2NBUkRyMXNJaExvOUQ3WHJlVHBJb1BlSkFLNExVUXNBbGVqUkZOQXJ3QmVkREhxZzR0MFVqQ2dhSjhBTmpmWFJXZ2EvVmp6STlTR01mQTlpZGhHbk9oVTZSMmNPNjZJWEExSkErMU1Nai9ad29BaGU4d0krVC9ONGZXaERJSTJWeGZURFVqUXk5U01kTXpPdUdIMWtPSGs2QUNVcXVKUW9YWUVBby9CQU1JY1JTbG13QWhSZ0FzSUVtb0RLVlhVSERKWU9Jb1RkYXpYbDgreVJPR2xnZkp1SVFBY0p3d3k0bHdnZ3d3SEp5Q3FLbWpkZ2dCQ3ovQUNJS3p0UkREL0JBb2Rka2NtcDU0eUl4Q3dYS1Jlb3NqMDUwZ2NpNDJRTXN1SzJhODZRbmRvUUFnRFAyc1IxcDhBN1VOSmRGY3NhUkVuTTBaZzBkcUU1SGJtU0NHTmdsS3ZJZ1QzcGFoM1h6cE9YcnBpZ0xzQWdFYzcvVXBFcUVPY3ljREFXZEJ6MVJIbGZrQWpCczA0OE1xRkUxSmZyU3psVHpSaGZvNFF2Q2NqRDBpZk9GeUlyaEVZdkp3UGpac2FUMFc5Ri8wckN0S2FvQkZOT2tIRXlkT2xFRXNhRUtQRERoSHFnanQyRDljaVE3dlkxQVoxalFPbDVwcUNtQzFZUmMwQThTOUhBRExWM2FTOHVTdjVjcTZFWnAvVjRQUU1HWnBtbjBhVnE5bTBkNTZpNDVpaFNzb1Z6a1dMZFVWcURoUVg4NkRDQWcyTnJVNnJ5MS95d1NWWkFRYVBvNFJ2QWpYTDdDNlFxSnhkVnkrdlNuOGxHaUF3MExrcUltbGw5c0FBQlZ2M2VCazhFdHNwS2xiWFhrK3ErME5hRkFrTTFVWnhObVFNNTk5SkJmRE9WQmpkUEVMblhzY0dSamd4Z2E1N2h1aUNHMnZPM01XdzB5dHJIWU5xcFZRTVhSZXZEWWxHbXFYRkVENXZLU0l0Q0JDaGFvWVYzS2NjZVlMOE90emdJMzhwN2E5dkJZbElsckxOYzFDRmxFczZEbkdFMGNDWmhjZUgzTDBYRXlLVkNIUk9SZ2kydkh3T0V3WC9qYm5pVUFrRFlBNExkeWN1T3Y2clMzdlFNSkFReEhrOEVyWlZ0ZHkrblZuem9OcnQ0QUc5alJraWlvWWxYVWV5ZThYTGpHMUVaWU1NUFJRakhkL1BvcXJ4M3VyMWorYXlNeDNNSm83UC9BUW9IMWU3bWNDakZtY0h3eFRiNjYzblNlVm84L1U5MzJOdE5Nb3cxTVFhRFpMNUdML0dHb0JnTUw3REFhS3FvUTIvQ21PS3RYREFsQUM5bFRjelo0c01OQlpvMzE4MGlPZVRqTnp4MFpTOGRNWnJHWTJjTm8xckhaUWxIQ2tlbERhYndkOHB4WldPY3MzaG5QSVkweFRSUnBXajl6S1FJc0NocUkyWEJaa2swQ3lCdm1jSWY5bTdnRkljRnhHN2hSbkR2TDF3UUwxNVBuZEhCaFE3MWxMaThYeEpaZzdNakFvR0ZFbC9tNmt6MHlnZU9BQ05nMTRjMG9sdk5lNlJ3YnJuSUN2VmNtTFh0aDhXdFZJRGErT2RZZmdVRUJBYlU1UXJOdFRUWnQzNnBkQkFtaDJJNWJSeEFJaGxWcmF3UzQ1aFVtZzcrWVR2ZWlOcm1xSlp2Ly9vSmhVY2VKNDBic2JyZTc1UXZpQkFnaER5Y3N3Q2wycDFlV2JXVGZtK3ozcm5tTlplTTZCcmtTSkhqK0NEeHZ0Ym5CeENlZWJXMHB1eUFHOVBBQVRJalFlSzl0WjA2Q2xOT2RwdEtNMnl0eUd3ZGEyR3lRdFFBL2NPeERQMVhwMUdRRHdudG9CaW4wTThxWXhvdW1xNXhlbmhzVXdqV1dzTkFGd3BEdTdsQU4vRmkxMGw5ZVdRQ0VQWTNyUUlNVjlZM0Z1MW05azNuK2Q4aFIxSFdndVNBVStld2hJM1pMVGJNM3VySlNVQ2tsMlhFQ1BPQzY2bFMrT2tGQkR1cWRpZG8vTGJEREFTYkpEbjNZcnA2YnIyd2NBdXhNRXZqeTJvUFVvcTdwVHNjbGd2dVJ6VUY1SDIreEFURUlRWEtjVHhBczJSQ0tIdWlTbTIwNTN1aHgvMjU2MGVyNThYMnUzbnROeVdadVNzUUpld0NBR0VCeFRWbkdNaGlhcUVJTmZwQ1c1RXVrN1N2ODUrLy9PdmZnRTNjeHlSUjFCUEF3NHV5bnYxSUV4Q1Rjc3gzYThJOTA2NUdYUEJUVmYzOGZOU0hmZ3V4ckVUZTljK0hyTm04Ykt1dVJQRWhDQS94THdOT1FoVFI0QzhXTG1aelRPUmo3T0FGOE1PS2p2eTF6Z1RCUlFBN3NDamh3dS9Hb2k0NWluLyt6TXNjYlBocmp1dktqRERqb1FCZUVpRDRBUWJ0NXY3MEJRQXFVc1Jtem1GR3FuMUdESkVsNndUNGFoWGhJQWg0d0F4T1FnU1pRQXhLNGdBTFlnQkdBQXdWZ0FuQ2lNMHpydi9TQXYrQzdRVS9UT3FIYXdXbnB3UmNCUWdGeXJGakNIUnlCbTByRG5QYVRzZ1A2S1A4Sm5FQXQzTUljL0RuVk82bjY4cEVQWUFma0U4UG9XRGlXbzdZVSt5YWI4NzI3V1I4RnEwRWJqTU9lSzYwdTlNS2lhb1RoT1lGUVNBUGc2UWM3OEFmRklqRGNNVU5hK2dFK3ZBeEdpSU95MHk4TzR4VHVtOEhGTzBUME1rRXBJYTdwNlpwR3lwZ3ZyQmJsd3JHQ1N6TWhRQUxkKzhTSGNBTHBTanBxYzVxTWF5TTNDcVlJZkVNNFZLLzFDaXRrbWgvNjRVRmFUQ3hiYkxhSVV3RFg0a1Y5QUs4NEMwUlRQTVdOMDVDODhaeFZaTVZXSkM0TGJFU01jWlZaVEoxRm8wWUw0MFU5dUMvcVVobEJWRVBrRWNGQ0RNZXVRc1FzNUxabFBFZDB4TUFWOUJMRHdhNGp1ejFJQTBJUzBCMVM1RWFFdWNmTktiMHJmSktJc1JsekJFai8rNEJGMHprZCs3bWZkcnlPWUJDREFPQkZSMGdHbEJteWVtUVpiNFM3L25PWWRnRy9kN0hJaStRemtuTEdBdVRJSG9RdmFYeTRCT0F4WGt5Q0tzQ3JOTFRISU1MSGxoeVZsNFJKQmhPS2lmazBFOUhJUEpxS2RkVEpmU0diQkVnR01QdkVhRUxKaHl6S2lBUkhsMHlXUVZtVzZIRktFMkdWL09DWkw4eEpqNXhHZjRISE9yaXB1U2tncVRuS1kxVEttQXdSVk1FWndCRWpXU1NjdGh5YllPQWprc0VFVklpSFcrQUJFM0FFTjJnQ2NXQUV2Z01ZUUFpR3VlUStRU0s5Rm5ORHZNekxVMmtQRHlHc25MbWpSbnBHYUdUSHd3bUd6K3VXSkdBQlM1Q2NIRGxESVJBRHl3dVlBcURNYm9SSTlha0FVZEhNS2NFNlFsSEdzandtLzVKQ3kyZDhsWTYwbGdUNHdXNUJBdnlpcDhVaFRHNjVBTy9ZS0s4c1Jvbjh2cXZqek44OHdhWVV6aFJNUjNYY21FZHhnUXVMVG9ZMHU1UGpsdEJUU1lqRXpPdmN4M0gwdU8xY29MM2NtcWRFeTR3cFRmaHFnVFNRQlZ6eHhjMEtQTTlnQXpoUU96aVJUcWloUXVzMHhGSGhSKzJjejZ6cHpVVTB5NEQwbXFpY1NvNFJCaWVnbENTUUFqWndPSWNMQmhhSXpOUDRBQklBQUFTNHBKV3NDL2ZrT0JjclFmbUVVTDJVME5IcHkzUzhIcDlwQVFCb2c0VGNEamdJQzRkYnRGWnpFYlF5alVIWUFINVMwWmFCamR6MEsrQmJ5dm5NQlJtVjBBbGx4dThzUHJXY3loUjFBV0VBZ0Q2NHhzdjRvVUJVTkRMMW1CZnAwUU9BZzBhSWtQL1dXQ0dPV0pnRkRjZVh4Qm9aL1FrQU1JQTY1Ym1adk04YnhWR2Z3UWdYNGM4UmFJSWUzWVBkbVJCRVRWUkZYZFJGZFFFbWNJYytDSU1XVUEyNkVRODRiVkU1ZFZCeXpGT2VlSVVRd0ZOTzFkTi9wTWtydFZEU05NNC9kWlJKYlFRMHVJQVIrQlZHalZXVmJGTmFyZFUybFF0TC9aUW03Uno0ekU3ZkROV2RNSVJTcUlZd0FGVmdGZFVxdFZKR010WDhsRXBjM1JoYmpWWnBqZFpucmRaY3BRc1czVldIMGRSZlBWYWRNQVJ3ZlFVWVdBRnZCYzUvUEVlOWdFb3Q0Wm45V0V0cmZWZDRqZGQzN1FoNnhWWTkyWk44M0UwM3BOTnk1UWx3QlZjSklGWmo3ZGZneEVqUkhNMTF0ZGQycFZkVXJWYUdmVmlJZlZpRm5kZ0xFWnoveHloRUxkcFdidTFYbi9qWGYzMkZISkFEamxWRU9XVEU0Y3dRaEJXY1pxVllsbTFabDhWV2xiWFlpOFhZakVWS2lvVFNjdlZZanlXQ0lDQlhqdTFPMENTT2d6WFZpNDFabzAyUm8wMWFwVjFhZkozWjNGUVNmUlRIK094V2p0VlpqeTBGS3lqV245ME52dVJUbEswWHB3MWJzUjFic3IzWXJ6MWJsRTJKcUpWYUdPM0hxclZhajJXR0xKZ0JJeUJZcnUzYWcxcFd0TjFidnUxYnYrWGJEZUZWemR4TXQrVllDWkFBdVBYWVY5aUJMcEJTYi9YTVp2a1R2Y2pJdjYxY3k5MWJ0UTNjeVQyV0sweEt3aTFjanZXQlVqaGN4RTFjUXdEWlFIQmNZSzNQMGFrWW9aM2N6TTNjMlloZDJ0MWMyNzFkM0wzZFA5bmRGeFZMWlJsWi82QWdnbFR3QVI4NFhOTU4xeHhRQXRYbFZFUDV6SmR3WGQ1OVhYMk5YdXF0WHV2bDNlZjEzTGJGV2VEMUFpaDRCZUVWM2RJOTNsZVFCQ0FZMkR4dDNzK1VIbEs5WHZkOVgrdk5Ydmx0bnZYOTNBZnQzcDFvQlZMNFhpSWdYdU05WGtNZ0FodHdBUFN0VXhxdFgzbVpYd1YrWGdSdVlBZCtZUHZsVi93TkNta3doVU93QlZvZ2d2NGQzZkUxWFIvb0JEVHcyVkNsMG1TRllCTStZUlMrV1JMZTFBa0dpZ0VnZ0Zvd2hmM040T0g5WHdDV0FIRlZncm9kNFJXdXdCUlc0UjRPNGlscFlkOUloQ2NRZ0FVb0J2M2xYL0h0NE9NbGdnZFFBQkhtWVNHdVlpdStZZ2ttWXQrZ2dRbTRnUUVRZ0FwdUJRelc0Q1lHNEgvRjRSQTQzNGJIeFdJMmJtTUoxV0lJQllGYjRHSXZobUVMSHVNTnRtRXpUZ1VKWUFBNTJHRzdkV05CN3VFV1h0NXlSWVVBa09NSlNJUTZMZ1laSHVQaDVXQXozbGtyQ0FJREFHVDhIZVJFaE9OUU5ZQXpnSUZ6QU40UCtBQkVaZ1V1TnVJWGp1RkRnSUlNem1Nbk51TlhzQUo5Q0lRQzVtUmJ2dVdnTUFBZ2dBRWZTSVZVMkFGRFB0YUFBQUFoK1FRRkJRRC9BQ3p1QU1vQTZ3RG9BRUFJL3dEL0NSeElzS0RCZ3dqM2RESGlwYUhEaHhBalNwdzRrWkxGaXhnemFzUklzYVBIanlCRGlvUm93QUVTaGlOVElseHBFTk8vZEJRTXBQeTRzYVpOakpseTZ0ekpzMmZPbTBDRENoMXFjNmJSbzE1WURzVDA0Wit1SlRLUlZpVHFjMmVIcTV5eWF0M0t0YXZYcjJERGl1MTZ0V3hWbjBRcFNWM3JzT0NIRDZQK1RTSEV0bU5RbjFpNXdvSWxTbFNGdjRBREMrWkF1TERodzRnUEMxN011TEhqeFgxRjdmVjZ0YXJRdWluaG9rSVRGWE5Fb0hpMzd1MjcySENzMDZwU3ExN0dlbG1FMTdCank1NU51N1p0MmExYnE5NnQrdlJwdzR3bHcrSmFtZWROejhpbnB1MlpOK3ZvMG9SUnI1WXRRZ1FlRndqQ2JIQ2pwN3YzNytCbHBQOXhnYWU4K2ZQbzA2dkhnNkI5ZXhjS3pJRFhjd0FOQXV6VnE4OWV0dHMzWWNpVGFkVkJUOGNsTjFKYUZsWFZnVjdQRGNhQmI3dTVCbHQrSXJpSEFCNFdNRExmaGh4eXVBRWJDVmdnNG9na2xpaGlNRmlvMGVHS0hLNlRCaDRVeHNaZmI3SDhKNWhreEJHWWxtZENLYmlnYUEwR1ZwaDBxYkVXRzRVV250ZkNraTBrMEk4SkxFWXA1WlJVVHNrREV4YWNaMkYrTXZaWEl3Y0FEcmZWZ0dnUkpSSm9QUDJvVlpDQURSbExoTlJWWitHRjVqSFpnb2tKNUJtTUdGRlU2ZWVmZ0haSVFqQWsycW1sZXpIQ05tTnF2OWtJV0Y5aWpta1pVQlRabENhUWZna1ozWnRGSG9uSENTK01BQWdnSTR6d3dndHcxQUFBQUdDd2tFWVYvU1QvbzBrQ3diQWhoQ1ZpaUJQb3JyejIydDBlYkFTVFo0Z2xHbXJlbGx3cVNtTmhOd1lvb0k0MWZiYlJwV3RtMnVhRG5Lb2lZUVRWdGNEQ0I3NkdLKzY0NVBySkNBTDZ2YmFvS2wrQ0dSaU9BcEtwVTdRUDFXU1ZhTlpXc09sMHI0bHdpUXpsQml6d3dBTWYwSjRJc2ZYbjZGL3daaVh2VHh2VnF4RzFuT3cxR0pIYjV0ZGVlUzVVd1IzQmY4WURnQkRDRG10eW5pYVdlUExKYk1UUkE4ampYdEFDd3VyMnh1eWprWEx5TUwxZTJIdXZjL251bTlxRWNtNWMzcElsQ3NFQ096Qi9CNGdRSjZjc29wMVVWNDIwMUN4RDBEU0xCNGlSd0xFSDB4ekJvbzIrbTdOeEVUZmtjMDdOOGFXcGRCa1hyZVRWRnBnY2pJWWcxd0MxeVNaVy83MmVlbFhqYWJJUUFEVHRSQlY3RjdvazJPaUtUZmJDd2owN0w4OXJaNkltbTlIeHk2M2NSOU50Z1JDaEFMeTFHaVVQMjdmZmY5Y1p1TXFETndCekU2Q1VydmloeVk1dHM3c001N3h6MmoxUCszUEZzRnljYmR3VnZpZUdpbHRINlFnV3BSTXJ0ZFdyWXoyNFBzbC9KekliSXk1ZUhxTHBSckFzN2hVMHpBbmFHamxVZWR2QnY4MXB4Z2cwSW5yMXU5N0NBQnNncm16Ly9ZT0RBZ2dtOEZmcEJoUFlDWnV5R0ZXalptMkZmQnd4bis5MG9pYmdPUWhqUkd2ZisvcEh3UXIyeWtVd0dpQzd2bVMyU0Qwc0U3eFRXK1VzaDZrSFprc1ZSN0lPSGk2UmhoT0FBUUIxK0lPb05yQ0hBaFNnRHhmb0FRUWdRQUpHcU9HSGZiS2dFUDhIQmdjWGRNOTd0d05mK0hTSHdBUkM1Q2JNWVZDKy9pSzBUaEd0YUVicm5PZnFOcXhhL1dDSXlXTUVGdlptdW1JeDZWQmhPK0s2MnRXc25PbXNpVTZVeUYzdzBrRGdUVkZmMk9MTnRqWlh2Q3ppd1U0akNzYkx3Q2l3RDRRQ1JLZlRIdU1hcDhZMXNyR05PWUpXQ0VHeW5OQ1UwSVJ3dW1JZjY5U1BkaEFzQ2lSUVF4TmtZQUoyZ0FBVi9JT1ppeEp3eGtVbVNsMk92RmtIM1ZnY1NSWUZPUWlLSXI2Z1F5UnRwYkJDZU1CYnI3cEdLS2taYzBTMDJzQzRtc0FlN3FuUlM3TEVtYk4wOXNISjdRZ2tuVEZRNzBiWUhEczZDRnNuTkZLY05OWUNGNXlnRHowQTRKeld5YzUydXRNOUx1akhBVGEwRGdqQUFVdjRxWjBHQ1JqL3pTVk9zNW9nTkJObURFRlFDVlFqRE5uRUpSUjF1U1kyWGN0TkVPS05SQ2RhcE54WTlLSjd2STJpTEVyUkRiWkxpYm1qWlpsNHBrMkpFUFNrS0RVRU03SXdBNVR3YUk3TXFXTkRSME9heDlqMHBqak5xVTRoTlUySEFmUXlKZjNJSzRpUUNoK1VRZ0lwVGFvaFhpRUpJQ1JVS2dpaXhGbDhWSmFxbG1Vc1dNMnFWdU5WeTdOY002Z2llWUlBRmxDTVZwQUNDa00xcWdTUXF0U2tFdUVCQ2xpQmdhSksxN3JhOWE0Q0JldGFsTUxYZzZUakRVL0ZERjRIUzlqQ1hrU3ZZTzFyUVZ6eUQwRElOVGxSbmFwa0owdlp5bHJXc25oRnJFaFd3cFIvZkFBT2dhMUxqM3owbGIyWXRxWTZUZTJqSXNQYTFycVdwNmFOclJ2SkFsQnIvMUpLc3hMNUIxUGc4bzgvaFBhbGxrcFRIV25LR01UNDVvUWRUYTV5bDB1ajR4NDNNU0I5VitRaUNjZnk0VmF2TVAwZDhOS25LWERxa1RZVXFwQUxXcENHRnh6QUhaZVltVHZEeTk3MnV0ZTlHbVVOYi95enNKQ09xWnEzdkc1STZHckpodDdSVFpuc2w4WmNvRXhmTVNJU3JJU2VncTBtb2dJQUtna0ZHTS9NeEdhNzd5bHh1ZzZ6Wlg3Qk9wU3pkTk9iMyt5bEx6V1pwRHI1NDJNQld3Y1lMRUcvWUxqNHhYa1NRaFVtT0M1WnBNRUN5T3FlZkpPNG1KNys5S3N6UVpOd3BRaWRQSzRtb3hvcnNSYnZoRXcrRVZKZ012Q0hCWXpWekRSU09KYjFoUlJ4YWd0VXV3Ulh1dzdGWXkvM2lDVDNvQWVRck5NVEd3RHhaSUx0Z2YrTVpsUmtsUmw1WldpQ0ZNTVoxbkJHNU1qTlhYWVhnZ0oyQVJyYVRHaEE1WUZrZkZPY25IUGNKWDdlK1ovVnRZaTBKcllUUDE4TDBOeENBQk40VU9oT0R4RU5SblRjOXlBcE9ZaUZjSUZzYStnRE5VZk9QbmlhUXhCZ2dhMmFoNzh1MmdvTGdPRDBxenRVQnlOcXNHeXJQZHRPU0lwcUVqcUh1MkllWGdTenlDUTJzQ0NJRldSRTdGWjJ6R29MYm5DaFdFZW5lUUNHQU9wNDFEaVRsRzJkMkdlZ3FjK0tmRFJ6NTBnMHVDK0M3QlpWcUY4WkZZMjZNMFB2Mm5saVF5Z29PQUpoVFZtUjNQczFCOE9kNTNFZlZvU1VUdld4ZzJia3VLbDczY2pVa3lab0hEQXd5QnRsOUpaejZsU0hablozVVF5M0FCa1BJaUc3N0xVQWpkLy9aaFRrbkxVNzZ5SWNKNyt6bUpBd25XVFZXU0FZYks2Z0daaVg2RGd2ZU1FcE81a1FDZ3d5a2NIWjVDZXZjdTBlQno3eFJWcUJDYmZjNVpDdEw1cUxvQVZNUUxHbm04Q1BpMlBjMnNkY21kTGlRVWgyU0NFWVNWZTZxQjF0dGdNTzIrWGJ6QWpGTUdma0VXL09CUy9ZdFpTY3NBRUFlTTFXUWdoODROa0FDakVBWUE4VTF6dDRSakRoWDJmWmc5VjlZckViNkxZLzd5YUZlRmU4NWdtbWdGQUx2TDRzYi9tZUpWOXNZeTg4eE1vbThjUC91RVV1RGtzSTFOdjhyZ0hoK2MrREZOSnZueVRVUjZody8vSnl6TDlVc2haWnQyYlpBMm9FaU80NTB0R1Q0eXVURGRnZHZLK2VKVTJUMGZiMzlKaTh2T3I5aUxRV05NSDRma0pGL3lpSytlOUZPNVBDRmJad21MWTgwZzBIT1pjVXcvNURnWDlGOTdUZ0VsQWlsd2xDUWNaYUo0QndxQkF3WnRBUFdiSTk1eWNqV1Bab3RGUmJBZFZsdUNWa2JFTjVsVGQvNFRSTzF1RUNqZkFIV3RjaGV5QWk5a1psUHdkSWtTQk1nZEpycjVSK0c5UlAvaVI5a1JZVVJsRUtCL1Zib3ZWbERBUWtWRWRGbTRKYzJpSk9HalViNy9XRFFCaGVkSVorQ0NoUmphS0ExR1Z3Y0ZkU1NrVUVRZkJZa0FXQkRDUlR4R1ZUMEdVYXpwV0ZXcmlGRVpWY1hQaFI5VFZMU2FpRWNhUmZSN1ZXYlVWUXI1QURnWkFMd0pWZGRDUlRwU1ZiZEZpSGRoaGJyeFVaTitWYWRRZ1dYZFdDbzZkZkVHRUtoMkFMdEVBRVJLQldiSldHaHVBRG5mK0FCbERJRm9WMVdaUllpWlk0V1hVbGlDQnhDelF3QVRjd0FBUlFDNFJvaUlpb2lJeVlVcWtnQVF3Z0J5NTFYWWIxaXJCNGNOcmtob21sV0xZNEVEMUFCaklvV0xIWWkwT2hpY0RZRUxmSVZ4dmdDZHJraThpWWpDNFlqRE14akVzaEVCZlFCWE5sVjVkWWpkWTRLYjNJakJSaGk1MkZDbkFRaWJ6WVlaTmxWVnVsVlZaMWp1aVlqbjlZaVhTbGpXM0JFcDJsQy9td2kwY2hqcVFGRm5mSUYza1lHZm5ZajNkWWpwU3hqb0FZaU1CNEVMdlZXT0NvVUFzVlUxNXhXbmVrV2hBWmtYc0lXejBWTDE2MWpJSzRGTHkxQUY5QWl5VWxoUkhJSUJOWVhNYjFoU2I1aFZlWWtvbVJVN0JGVysxSFVwcjFGcWp3RDVOQUZ4eTJrRlAvU0dSRkJrNDZLRkVZOVpNY3hWeENhWVRQQlJ5TmdXY0ZsM3U2QjFZVUFBalNHRlFnYVhyeVI0SEl4WU8yRVlRLzJJTmFTUnM3UnBTUFJHcWxSb2JVNTQ3dlozMDVhV25uRm1EMVYwNlhnQVlYQUczZjRRYmo4VTUwV1pkYjBnS05VQUE5RUFaTGNvSWJOVjlmS1UzaXBwUkxTSmE3UnhWRDVudW9wNWFiMHdKU0lBdTg0Z1JpUUI1em8zRWJweVF1TUFKUzBnNGpjQW5rb1U5anMwYjlwR1VXU1ppRnFWLzh4WkJBUXBKZGFIZDgxRWN1TUVqaGNnRmZCM1lxa3d5eXlTdHVJQXlOVTRTT2RtRzRaNW9GOHBIMnFKcUsrV2RWK1V0OVJDY245MzBCd3dEOVYydHNJQVpPVUM0MjFnSlcxbWhzQjVadk5IM3VWNDltYVJYRC96V1NGTWlZWmNaOWQySUhuZ1F6SHlBTDY4QUQ3ZUFHVGFBR0VMQ2VBdU1pQmNob2YvbWJQUmFjQTBtUVp4S1ZVcWVUeVBsZHlpbDhhT1lrOGdGK1ZHSUNCR2grZEthZEtmaDRJb1dOdDBWSk9CbVNsMVNnbWlOZ1dFUW5ITWRreUxRbmNNbWdMT0lFeEVKbGMzYUNDY2lkMUdTaDMwbDZwVGVlLzFWM3J2bWFDTnB4SWlKMHNXZWlVbklCaUVSdmFNUkl1R0Zud0xtQUwzbWFMeWQzOFJkbVZjU0Q1d21pUzRadmhPZHFQdW9uRURCdDh6WTFyV1NBYVZTa0JEUnd3YVk3K0JXamNRZHpOWGljT0ZoM1pPWUNjSENsYllaOHlzZWxFRXFrK3hTWUt6aVlZamxwVEpxbVV5bG1BZFl0Q2dDbm5uWUw0dkJEakVBQ0pBQUJQZjl3QVgxZ1EzdXdBYVh5QjNYQUtpZVFCcGRRSGltbmNrZ1lsZzI0aE9YbVFKYUhidHlDQjJtZ2JZU2FxaDJ5QWJXSGduanFuNTlLa09lRGxvQktxZ2h3Q2ZhcHFybzZIMG53SXBzS2ZibWpwN0VxaTJlYUlERTNrazg2SVc0S3B5YlFCMEZRQlpvUURJSW5lQ0FpQm1BQUNFMlFTajY2QjYzNmZDc0hlY0twRm9kcHJINHFjNWZHYWtYVEF2S2tkMzNBRDlIcGY5SXBCRFd3b0p1SFFXdkhMbytucDhRV2RhWm5ybFJrZGFzWERLR1FmMkNrRCs5YW03WVpjU2NUREtDZ05idkdBMUxRcmVBV3JHRzVyMzNhZThoYWR5bjBjRXdpSXM2bWEvQ3pBZTlhYlFwV2JRc0xDc2hEU08wUUN1UVJjRFd6blJTYmxKUXplZFdTbGlqLzVLRWNLNkt1cHpRZ1N6QTk0SFhQRTRJbGkyOE02NXdVZEFISmtHQ004NnRpdWtTZU9yTlIxellNQnpmMXgydzZhekpza0pzQzh3UFJtVWdxK2pjTWxtWXhacVZOd3c0ajR6eGQ2ckxwRjVnczkzUkxlaEhpV2JPWHRqNVZPemNlUnlzSlVKMGdJMnRSazNGcGQ1bEwxbnBZV3dWa1J6QzNJQVlsUjZkTGU2OU5pMkdpRjBlek9wV1pnMjQxTjN3Unh3Yjg0TEFnZ3dSZDYzT1dDYmJSbzdBSjRHd3c0d2gra0xqL1JqdS91bktsYVdxeXlxOVR0MnFVeXptc3gyUnNFQVNGV3oxbk82ZmxSeldnRzdxaUd3eHhrSGprd2dqTk16dGV1blMzMDNZVnl6dWg2cTlWbDNycEJxSUprQXdYQUVhd2M3d3BJN1RBSzdyL2x3ZlYvMk4wemxOK3ladHl3T3AwNFRxdTVEcWd4eVk4NkNwZWFiQ0JUN2E3VzVxd1lTZDA3bFpCNjZBQWJKQzJBZ1FiRSt1MFdoRjU2aXRWWnltcTUwcTVMdUFCc3FjR1kzUS85bnMvU2tPdlQ3Wi9YNk4ybjJkQUF5eWNFZ083cW1hekdlT1kyaXA3NjdBSFlpQUV3UUt2ZG1NclZkQUg0TEo1SlBBTE1MSzZ3UG0wY1BlODVKbXNnWGE5dTlyRDg4RURhWUFBdGhkOVNUbXM0cXEraVdsdUlFdzBMUkFHTCt6RHUvb0JKekF6K3dtc0FsekVrOFI3bERkRk9peGdMY0REVUp5cW9NYTArV3JEb0tyRkc0cUQ5SWV6cTlleGQ2c25RZ0FHdVJ2RzFmTUNyYnEyVFp1bjNibW5Nc3F2VWxreE5ickcwK3RIdGF1enJoZGpta25ISGYreXNpeUdTSm9RQ2YxUUJhSEFBaStFQmpVQUI2ZFNLcU5pS2xJd3czZWF4NlJaeEVaOHhIM3N4K09adzVOTHFvTXNwWVdjWmtMQUFJcnNIUVVBQ2tEcmM4eDNnTFozcEN3WXJxUmN5bjdNdm1xcXhzZzFUc0pYdXlYQ0JnNUd4K0ozY2JZOHBINkpaWkNCWitzNG5KVVNubjc2cDNqMElMeEJ6RzE4TlFsQWdqNHNmdVJIcDM4N0p5d0ttS09KbEFKNW9SaHF6UnFLelFCV1VjSFh4aWVteVBHUUJpR2lvczBIcG1FYWhzS0JwRW1xcE8xY25HQkduc21tbGttMk1lcEtzT1FTQlN3QU5TLzJZdlREQnBaUUJReE5MbGRTZ0s2a1Qrc3lvWjNhdXQ0Sm9Hc0JmM0ViekVPQzBCcXpRcm5hSzI0UWJ4SDhmMGhRTGxIbXBSSC8rc2txR01vK0JhTVlpVjNXTElHQlhJRlhkQjFwc0FFbE9pVTlrTFRjZTI4N2FnRmd6Q3M5Z0owMS9iTDg2YUkvaGlDR0NaSSt2WmhIWm9IaWhRY0FRQUlqckFmeDBHdUFXOWJxRVUvek5DVW1VQUFLSUF6akJab3R5cDNUSEZWU0VRTDBDRlUwMkhzZ1prSlZtVkhLaVpYdVpaZnUxQUwrVUFCdE1BSXYwckxzdFI5eHJjRWc3YnJVN0JscUNBTUpxWkF6U3FEZDVWMFVaVkZiMmRtZTNZTmRhYVFmTGNxalRLeGdsVkpyS0FmRW1kZDZ2WEFQdWFZUWRWeERPZHUwN1lWRkdZYjJ0Y3RpT1piWDFWYWxZQVVJTlkwWmVzQ1lnbG9TbWMwcW1kektmWVVUV1pIckhObjZ0WWh0OVFvNzBBVWVPWU53bU1RTlNZZXVkZHplLzcxVEZCbVFGOG5PbWxoVVBvQ0dqTGlHU25EZEk0MllrbFZWQUJuZlkrR1BGUmtXQXJuYklnMk1aNVZXNXkzZGJVVUVOdUFBZDcxZmRYV05CaDVUNnBqZzl6M2VlV1dZb1dnS1ozV0lSWVhlcHlnQnJ3QURTdENLN2EyTWszamdERzVYaGlrUm5qZ0FBaUFOcHRBS3BKaUlaM2lLSjJYaEllQlVxODNoTWg2TElRNFNBUUFDdHpBQmlmQ0pCRkFNRUU2S1JiWGlMSDVTUkdBRlFXQUFHbDdqU0RIanBoMVVCbkFHTUhBT2V1V010K2dJUzFEWlVNbmt2YXprYTVFTFNaNGNWTTVYQVRBQ0F3NmVXbjdtTU1ubHpSam1DSkdMWDc3aGFCN25tYWptSGNIbXowZ0QzeWpjY3I3bmcwWG5FR0huTHFFR1gvRG1TNDVYSG81WmZQOU8zalZPNVl5MUI4WVloWkYxNkpMdTRZWEY1Y1BZRkIvd0FsaU8xKzVOV2VvWWtBbys2ZFVJNG9hcFdKMEZBdk9vNTltTjRISW8zNjd1aDZGK1dYUk5sbnpWV2F5UTZxck8ydUxaNmlKSjMzVDQ2c0JlVlpnSVpKcklXZDJJNjVBdW9NRGM2elRWM1RhMWo2L2w2L1NOVldieDRkQjlYUWpCRkM2aDZUR3U2OHMrVS9yNDJ0ODk3a2ZKajcvK0ZRditpd1c1V0x5MUI1c3VpUUw2WWRzbDdsYTRrdVErN3VaZTMrbSswN2hGRUV3UkYycWdBamM1M045dVIvU08zTXVkOEFxUEdCSFprbVNoMHdJZFZBSnhrRFR3Qm9RZWpxWDM3YWZWR0NXWmhiVWRwaWNaOGlyNTdLYmxraUc5NVhxMVd6TzVBV1Z1NWxwTW93K0poYTMvK2ZFMFA1UmF5UERsN3R3QlhZWjY5UUV6U1FCZndOTzZUcU1rcWRrVHhkbWZ6ZGhBK1pPemZkdlJwY2M1UFpEWHhRb0lLZlF6T2x6R3ZhWXp2NE5KMy9WZUQwdTZRVkgwRlYzcUhOTDYxZklwc2VvU2VJUFpMR0pXYVlIM2NYNkFQZmZoMWRtaGJXR2p2Y2U3N2VjZTBlbnZ2TmNQcGMyTTZhSGk1UUpNQUFjUWdLcjBnU1dDM2ZoREtJUi9OTU5INUp2cUo5Y2ZkTzEwVHRMRURjaEY1dlp4Z2dEbEpBd0tVQUFyUFIvaWdSMS80L2p2NUFKcDBBYmQ4UUVrb0FEWEVkWDdPZFZFTE1xWVQ1YVJIbitBci9WQUhVRnBNQUp0OE1SVThqK1VhZFptN1FKMUFKa2M0Z1IvMEFqNU5QbU9sTWRYalB0bUNveXBxZDFPV2tVMy81b2ZtVGRNL1pCZ1NWMXZHRUpnVlRJSUd3QkFraStoUjJqNS84bU0yYy83MjIralpKWmtMcERNdmdJQlNSdTBRZ3NRQ1pMMTBWUFE0RUdFQ2ZYSXVuQUNnUWdSRVNSR1dLYktvcXBZc1Roc3JOQ3hveWhZc0RpTjVOUWgwMG1VbEZTdVpOblN5MHVZTVdYT3BGa1Raa3VjT0ZIdXpOU2hBOG1SSVVWNTlMaVJROGFMcXBaTmpBQVJJZ0tvQ0N5UVVGalY2c0VDd1JKWTROclY2MWV2d1NKUnZWcjJZQlFtZUp3eXJYZ3hvMUdpRlVDS0pHbVNaMDY4S20zdTVYc3pyMDZlS0g4Q0ZScTM0MGFrU1pkT2RDb2lLZ0k4ZUZvY01Gc1o0UWcyQ1RSdjNncVdLeHN4bEMxWGxwV214Y08xRTl0YWZNdkI4RnlnZG5mK3hkdlh0djlmMmlvREN4NU1zbkJjbzBjVkw1YlkrSEZreVp1Y2pHYitvWVlRenRFM3M2bmlocm5sMHFlaE5tYWJWQ05Ib3FKQUFpMFpPRGZPMjN6UFU5cDlzcmR2V0VPQkk0NDFuS254cU1nbFc3QWo0enB6TTJwZ0laUXF4SWlFbnpoQUNVYUlLdno3ajdRMExNRGpzZFJVYytzNzErSUtpYTZSWkp0dFBiM1NtK204OW53aTd6ZWlqTXFvdm91SUs4NnA0NUJyWVVZTCttbm5RUnh6ZkRDSkNKR2pFS0x1TG9RcnJ2RmlhdzlFU2tURUxhOFMzK05rUThNcW9JOUZpMXhzQ3NiOFpKeXhCUXNTNk1jRUhjTVU4Nm9veExDZ0JmMmk0czVDSWNIekNEWWpqMXhQUk5wS0pPL0orQXhUa2NvcTc4TXl5OGkyNUpLckJNUXdZMHhFRTlYL294MDd6a1F6emUwcXBNZzdESWtzc2k0UFA4enR0am9ETTVHd1BPYzdpczlsWE1RUEt2MGsyL0tyWU1TSVFsRllkWFRpRks2MmhEVFNpSUprN2J2WFFpTFBKemxwcysydjNaeEVzU2o2RkdQcXlxY0FEWFJWcnpScjlkVllxNzFPbk01cW5mRlcxSUJrYzljaDMvVDExMkR6VW85Sm5qNE42dGpEUnJXUHNUOGgwdy9hYURjTEJvdERyZFczc2g2MDhrcFFiaVdkdE0xZU9ld3cwNU0ydFFuZG5Zd05OVVhFbElXM1dXY0ZCWXV6QlpIWWQyT3pDc2dzVzIyMzlWRk5TVmZEaUZjaXg4VjBOMkZwWXBnM1VPVkRWcmdXL2FSWVhpMXByTmZlWVBiZytPZXJSckNFczY4QUhoblhYQ1V5dWRLVURTNEo0YjlxZXJtbjkwTFMvOVBkbWhuRHd3V3V1K1k2Z1dEQzFrbzZ6dGpnQndLZzA3YXFqN0NKL3RmV283dE51bFR2d3YxSTVZUE5NM2ZFbkR3RjllckVsTG9QZ1Vhc00rc0RXVzdod1FRWm1tQ2toejcyV0U1dHlxdmFRSWl4UVE3NTBjaCs5RlpwZ3BzbTk2N2FaSnE2Nm9mYkRkeFVxRVNyL1BWcWtZQnVNN0NNN3B6a3BBYytHV1Z4RFFaV1UvUk14eXRkK0dSV25VcFRSY0NERWRpYnJ4WVZBRDRHVzJ6cTJSRGI2MGRSMDdVMXcvQ0d1dlFsV1NMZU4vRWdYdDNQRm5wd2ZuMzJDOElrQ1JQYUFLQ0YzRmZqUGp6djlRNCsvSlhHRDhwNEtkR3NUeTl5QVVIYWQwRDJmU0FNOU5zZTcrN21POUx0N3lYRGF4aDg1bk0rQXZvTWdSdDBuZ3dhOGYrUTdkbE5MaEFFbmt2NHB4dkJFQWFBRWN0YVUxd0FDQTdHc0hrOWNNSG42TVlhTnowd1RpbkpTVXdvNkI0VlFreUF4QkdCQzE0Z1F5Uys3Z1UxbkZ2b3hMWERoUFh3aE94Sklmbk1oN3lKSUlBSlBFaWlaVkRoaUVuMFlRT0FBTVFHQ3RDREppU2hpNVlCQS8yYWlNTU05YTR1RVRUaEJBRlRSVHhka0VXbGVoRUNYTENCTlNMa0F5U29BVCtFSUFUclpRNWpDOEpjS1BaQXJVQWVwQjJYQUNIb3dCWEhFWElvVStEelF0OHF1SzRMdGhCR2VQQUhXWklvZytoSmoyeXJ4SmdReEdEQVNPcWhCd3ljU04wd09VSW9jdEtUZUxSYWlqRElyS2pVcUFreC9JRHNWTWxLWkVySGxXcUlKU0JxK0MybTNTMlhVclJqUy96WHk2TC8vQkpMeUFsR0dtN1VQbGtBWUhiUzhVdzV1N0pLTm9EaUFtczBRUnJVQWsyN1hhbzhQSlRnTG9FSVNsOWlzWStvZWxZd1FwR3Y1Z0Zpbkc0elowRjNOaDErVEk2RFBBQURFOTk0c2h6SzAwTzZ2T005ODRpc3dQa0pVS3RpQXd1NFdMbDFoT0tZbWpOb1NRbkZHU0UwWUlObWtJSUxTQVpOQjBxMGhDdnhZVVY3WWtXTVVtbGlHeDNVWjZUQURyV1pBQXVLSk9uYkJIVlVlbDBNcFdCb254UFNrSURiYWMrU0VNV2tQT25Ja2lsZTAzakpzc2hPK2FtcWVnbUJCVURsMkMycWNFelBJRld0YWkxbmRJUUFBT2VSSUJKUVBab05uWWpMRGwyVnB0VzA1aWVmdEZXc0VaRmlXanFvSlg3QXNUd010S2hyWlN4U1BlUFdFYnh1L3crYWdkdUVJZ1hUaUdwU3J5SHFwRDF2K3I4ckRoQ1lYOVhaU1RYRGhuWHVTeHhFVFN0U1U1V3F0VDdXWHFCUUtNZEd3WURNaEt5dUQ0MG1YdWRKenpyK2tHbzRQWjVvLzBUWWM5ckxsTlpxZ0dKcjU5clh2cGF0WDNHcnhqaG1BaFpBeDZpN2hhZWI0UFRiVE95dHN4VlZWK3E0S2xqSDRBeXN5WjJlT0RZR0JyUVc3YWpScGU5MEQ4cUdVR0JpWHg4SXhUaTNHMVc3d2hGL21nVXVWck9LeDcrR1ZuQXZTdSs4ZXRvbGFTWEFRZnBpUVh5N0FsMzZSdGV4MUxXWEdHNnhMM1lNbFhZWEZwbGxwYXE3bUtwc290UWNiMTh0ZXF6endvdW5ENTRPRmlCcHJlZEVSNzd6emJCMGo2clUwMVloQVBzeWd4OHk5elpJVmNoK21mK2RaajN0MlJzWUQ5R3JPWXNXYUliSnNUMDRkOGUyNjdHcUxBYmtCTHgxWTI3UXhKRkpuT1FBWTRUSmN5endYdm5hUDc5R1daK2pwVEpYaEFDR0cyK3NUSXA4TG9ZemJGLzJha1lJcWRXWEdzQTJZbTJobWJkcnptdWJPZHRpT1BNU0ZzRFJack9veklZWDZKZHlmZEN5VWRmcTROaUN1YU1jZzhCQS80dTc3dUlQS0p0TjBnbXZPZWw4aXRMU3lObEtBWnduT3gzM3ViR01sYTIwNGpEaGZjVkRuSm81TmE3WWREOXBrb1RWQjVZMHBlZTh6YTNaWWJuTlkwQ250N3pyMG5KNHR1NU5tN0NGZ0dRQWYrNnVWcDBwWjRYNzJZdG04OW5OY2dFVHJuekFMT2Zhbkx3dWFIVFlnSVZ2VW00ZDBYTVU1MUF0a1hFYmJMTTFKUy8vbEdHdGJsa1hNUTJHNDZBWnppcHZreHBVbWZwWVh4TGdXK0tYMXZLU3FsWjJ1UW51NHVIaUU2T2lSTUFsWElkRVJ2QmpwRVUxS2RtRThNOERSb0VGd2VEdVZOK1NzbFY3bk5raFQ3ZnFSTm1DSmNUU0RmMGxLc1FQS3AwRkFZQ3NHMnhIR2x5YWNSUnJCT2NkZC9USHhSZm5neGQzd2NYNVl5d0xBb0VxSURLWnlXU0RXTG1keEFQMDR6Uktka3NPZmN1SmdlOGMzWEplTndLWTZmV0MzT0lITEFERklkdEd0ckFkVWhOZ3VFQTg4TjZIdFMvNmxwZmFwSk50YXZBVlZob1BURmc2M2c5eUN5ZjBvQUNBR01FSUFIRkdKNnpEOGdsQnhRbndFTUtxcWpqdWI0NjBSUk9zNEsxRHhBVm9HSDN0YzdTSFo5bzh4UVN1dXR6TC8ydGVGbllWWGwyM2ZmRXRVd0FtWWxaMGplNjk3NE1JZThGQzVlN0dwNzVDWnBsbVpIY2tmenAzZnZIMEtHczhwS0h5MWE4K0l5WlV2N1puVnBNcmxpQ2tyNDVnZG5FMTlpSm9BUmphWUFMUms5LzRCOWhPQTkwdTAzSnJ0U21pSWdSN1BlalRxRUR4R3JGaGcwU2lucllKaG80YVAvMmpIRGV3Z3hOYkdoSGFQa2NUd0FIMEg1SExLWWxobHZSU0x5OTdNQWpiakxjYWhRbXNuRW02UUZ2cUZTZ0tMMDVpdmRaelBUeFpvZURidXRINnFtZkp0aE1VTk90YVFiTXdnUUxvQXdoZ2hDYVFBVFBnZ1hWQUJVMHJDeDVJQyt6cnJVeUt3Um1rd1Jya3VSc0VIRkt4bVJqSkdSTnNKVUFTd3Fwd2dyQkRKZ2ZVQ3EvcEdqZnl2Ly8vMDhBb1lqR3JBem4zUUozVUNTQ3MwY0VkSk1Ha01xMHd5d015UklnZWlBTUxJN0VTaXlxNVVRMzdjU0FkWXJNQTVNQTVwRU1iTk1DWjZVSXZkSllTNURBaGlLeEExSU1Oc0I2ajZ6Zk9RY1Exb1FnTWRMdTNBNjg0YkQvaG1abzZQSkU3REtBVlNZcGxPUlgxNnNNRVlBTU5Fa0pVZURpQzJweFU4Wno2T2NWYnFzSVlsTUVyYkVWWDFNSXQvTDRXWXJBdjdFR3ZZQU5ZV3NGUkVDbGkyN0pneEozYzBSMnFLc1lOR1IxV2V6U3B5WTFpY1JnQWtzWEEwY0ZUQWJWQkNZWnAwNzlyREFaZDQ1WkUvSmFOSzVoZitSN3hPcGRPS1JaWVRFZjUwOE40QVRXdU9Ma0pSSVZRb0VkREhFVVR1MGVsV1JvcU5NYVYwWjkrOU1mL2YvUVUxQkhJVVVHZTVCbkJXN1FBNVFoRVdWaElZSXliVXB5cTNVRkZpc3dibG1tWjlFQVNPNGtaTGd4QkVheVkvZ2pFZFhncUxoUEdaWkZJRVpLTDczSkppN3pJbUpSSmphUkpJVnJIanh6QlFQa1NhNUU1ekFFRlArQUhMQkNES2dnRkZnQ0Eyb0tWSktpQ0JEaEVuOFRIYjlSSGNTeEtvMVFTSkNGQXYxb1hITXhEZHJ5WkZyZ0VNSUVWTThpdXNSTXJDUndUdEpBUWxDd1pvRVRGb1h5YTlrQkdoVkVTbDFsTHYxSEtTdlRJUzhRRHVsUVVHY0RHc1VQQklJZ1ZFMUE3VWl3WlNtSEVSblJFdEl3YXhPd0x4VXdYMUxrYXVQeEl3bUc0TUdrQ01XRElpSnRHR0VvVU45ak16L0hHMWlqR3dVU1lEVXpMMGR3THBHeEwvM1pSUjV0MGl2QXJnUHpERVVZWXF0aHNxd1N3dFRFeFAyN1VsYkpjdm9vY1I5SDh6ZDhrRVEra1JLMnJrby9jR2lZWWdYeXJqRDZnRld4THp4a1JDTFFKRTl4TFNkeWN5TjE4eWJYVVR2dmtHMWZjU0ZGaHlsbzBEaGZ3aHlWQXlNdHdBWWZzTWdORmpocVpQdWFRZ1EyUUF2Z01UTjMwSG41RWt2dXMwSEk4TjNUY1QxS3hFaEYwREFJbFBGUW9pSFpvcU1jb1VVdzgwTmVxRVFGRkNCNjRBRFM0Qks3cGxwK0VVTE5rdmtmMFRSR1pnVnl3MEF2MUxIUURMUTFOQ3FYZzBBNVZua2U1R1JOTlVpVmQwc2VvRVZOQ0JVWjRBZE53QWJWb2pHNzB4dW9jc05pWTBNTzAwRmNJZ2hYZzBSNjFxUitGRXRSY1IvQmNGalV0VXY4cmJWTTNmVk00ZllvSm9WSTNYZE1iYWhQZGxDZFZYTVZrRkZORFlBWVVVQUl4VGN4elk4Wll4RU80SEE0aVhWTkdiZFRiakZPQmFkUTdwWlNnbkUvc0pNZEJqUWxEMkZRaXFJRXd6ZFFCWk1zQ0ZJcDBSTlFWNFJNaEJjOVNXVlUrYWxSWGZWVllOY1ZKdlpDSmJNazlOVXhXQkZWTjNWUkRTSVVzVUlFZDFkV01mRVZRT1ZSRW5aSlpURlZsWFZabVZWWldmZFpaYmRZVkNZNG9zVlhlaEVsZHBRbGU1ZFZYYUlCUHpWUnpUTXBpTGRXWkNZNk9QRlYwVGRkbVhWZDJUZFYwTmRkcUZRKzhJY3hMelZhKzJGWmVsWUJTQUFBREFGWHVOTTA3MlpEeXFWYlVORmVEUFZpRVJkWjBYZGgzUlZpQ3pTU24rWjE2dGRlOXdOZi9iVTJGQjNpSGZoM1Vmd1hZZ0NYVmh3MVprYTNXaEMzWmd4M1pCM0lhZXIxVVNLVFltYkJZZkgwRkZBQUNJK0RZanZYWWo5MlErQmhZbE8xWm4vMVpTNWtMbGIxVlBwVkRsNTBKQ1VoYW1PWFdNbENDWU9YUjlTaE1ac3habmRWWjhiaGFyTTFhcmRWYW9IM1lySzNhTzFuWjBNelZvNDBKSHlnRnBWM2FUWDJGSEhCYU1RM09KbkdTc0oxYnVwM2JxcjFidk0xYnZaM1hPNUZZK3NUV3NxVUpJa2lGczAxYnRYMkZIYURadDRWYnFhVWFuMUNYdW8xY3laMWN5ZzNieDIxY0NnM2N2WUNDVnhoY0gwaGFDVkRidFYwRGpWM2MwbXhjMUUzZHgxMWQxbVhkeXExYjFrM2QrdFJjdm1nRlV1QmNJaWpjMEJYZGFrZ0ZLMUNBOG0rdDBMWDAwZFF0WHVNOVh1UWRXOENsM1pxb0JWTTRCRnVnQmM5RjI5MFYzVkpJQlFiWVdLZ2QzcHROWHUvOTNzTGtYamRqWHI0WUFBSnczdHVWWHNJMVhORTFoRmM0aDlJMVhmR2RYL290MVBDdFg3SWwzNXE0Z1FFUWdBVW9CdHVsaGM3MWdjK3Qzdlk5VzMwd2dLZVZYL3h0WUFkKzRQelYzNXFnZ1FuZ1h3R1FCbE5vaGVnbGd0eWwzdmJkMWxld0FUQUkzbXlGWUJNKzRTNlZZQ1ZoaFZ1WWdGWGczL045WGloUVg5Mzk0SHhGM0hjZ1lRbEdZUjQrRDVjMUFBZmdCb3BGaFFCZzRRbElCQmd1QmhtVzNnNEdYUnZlMUZKNGhUTElZUld1NHRuVjMxd3dBQVhJZ2tPUWhBVUcxWUFBQUNINUJBVUZBUDhBTE8wQXlBRHRBT3dBUUFqL0FQOEpIRWl3b01HRENBZCtLS0RDZ0plSEVDTktuRWl4b2tXSmxESnEzTWlSMHNXUElFT0tIUG5SZ0lOekM2U3RNVUt5NWNPRU1HRnU4T1J5Wk1lYk9ITlN5c1N6cDArZU9vTUtIVXEwcHRHakYyTVd4UFRoSHlvNEs1Q0NKTHJ6NTg4T1dEbHAzY3ExcTlldllMZGlIV3Uxck5telZxbm1sTXJXQzBLbVRRRkZiZnRScU5rT1htSHBGU1dxZ3QrL2dBTlg0RUM0c09IQ2doTXJYbHlCcjJOUmVpTkxEcXVWN05taWRFWENSZlZ2RXFITUZJbVd4Y3MxY3QvQWhtT3BWc1c2TmV0bHNKZEZtRTI3dG0zYnNXTzczczJidCtyZnZ3OGpaZ3dabGxlc1pZT0NYdjVRTGNlN3BMZnVQUTI0OEdyWHNtdUxFSUdnVVpnWFBVem8veGxQdnJ4NVBZenN0TUNEQjRINzkvRGp3OTlPdjc1OStyZHJ3L2F0ZWpqZzRsd2g5OU5hekxWRUZWcFpkVFdkWU5aZDExcDJ0TlVISDNzdDJOSE9lUmhtZUI0cVlMQmh3WWNnaGdoaUN5U1dhR0l3ZHZTaFlZWTlwT0VDQXZqUnRveHJzZmozbDE0QnBvVlRnUlhaWlZXQzB1MlZXSU83d1dhYmhPK3hwNlNKTFh5WWdCb3JSaWtsZWV2SXdFZ2ZnQVFoUlJWeCtLSGlsR0NhVjhDTDdzVVl3WXl0OWNkQllBQ0twZU5RZE9YMG80S3dNRWlZZzY5cFIxOThTbEpvb29nV0pDQ29vTWdBRXVhaGlDWUtwaG9Xa05qbmUyYk9ocVlxYWdvR1dZQWRKSWVaU0hMNkZCMG5zRkRubDNYWTZZa0hDWXFtcXVxcXJHcklTREFKaVA5WTRxTmxSam9wcFRXdStSK09PV3BLb0VVNFhSV2txSU54RU11RDJya0FSNnZNTnV0c3FoQUVBNnVnc3M2cTVIemI2WmRtcm16eTZ1YUF2MkowazZmRFZtZXNhM29pMEFJVE1qenI3cnZ3d2d1SEN5TElPR21sdS9iYVU3ak5qZHZUcDZHYWUyeWVzKzNwM3BKTkJsTkF2SW51RVljUWcwWXM4Y1FVSjhBR0d6VkV3YkM3ZmRCYnI2VGJFaGFZdDV4a3V1K09FQVhyVTJtaTNqa3doQWIzV1NLSUVRdlJ3OGJrYlFDeHhJQld5eVNKUFljb2NUQnhOSUh6cW00MGdvQ01JZXZxMTZYZm50eFJ5djd5RkoyUWY3bE1jQVF4SXl6MG9HemN2SEVmT3c4SzZNL3I5YWsyd2t3Q0tuSFlSNi9vQkF2QlhGc3IwNnpsNm5SanhsWC9CdTdVWHFqOGI3bFpuN3Uxd1Fnc2FRRWJhR2djdDNramxFMnR6OWF1YmZuUFBVZk1CZ3RISThIR3RDRldEdW5IWnphZHI5OCtvZHlwMVN3TFBMQXFNT01CaGhtUEl5cURIOU5PZmpiYXZNK2NlYzE1SEIxUEZXeVlQYUtqN0kyT042NTc4eDAxVURkUjNaR3cwaEY3SjdJUjRwRkdFcldyZW9BWWtrY2NkTkFWQ3hIS2hkMlhaMElWd1h3byt0MGc1MTNqeUgyWG5IcjA0azd2NmRVQnUvNGF6TzR4V3ZvR1NFQlZiY0FGN1lGUnR1SkhLUnRCelg3MzQwaVBCRGM0d2hYT1FSRGkybllteExZbWZVMVFRbUJCUEFwSVFweDFqSFMzNHRicHRQSTNDUUpMSjZPaGsvV005VHJZNllrN1NXS2JpQVlsaEJxVThJZXJHZ1FULy9Dd3dOS2x5VWJPZTE0bVVEYVZvZHhGUVRPa0lmWUtoamlaQVkwTmZ3RGl4dllBaXVMeGpISnBzMXV0aW1oRStTR1JML1ZEbmRRQVp4UzF6TW1DbzVMaS8yNllKQmVnUVl2d1FrVW8yaGU2eWlWdmRKRXFveGxGWmltU3FUR0MrT05SdjFiSE9qZ1dDMDhaM0E2SjBPQ0dWYUhpQmJBYUgva3N0akIzb2FGdXRCb2pHUVhKUEVKMnk1QWxNNW12ZEJLU1hQQ0lrWmtBRXFqNjU3b2FHdWsyOVhGQkl3QndDUXZJNTVjSHM1d3cxUmFNT3F6cUF5ZG9nUUpIbVVJMU5lOXBoaFRRS3FsU0UwTlk4eFV3bUF0b1lQakdJTkVTTmFuNVRXOTZrNXRiNXVlY043eVBPa2Q1bS8zUXlKbVdhcE1Tb2VjY0hsbnpudmdzaFJYQzRQK1F0b2htTkoraVU2Z2N3NWlDTGtZNGh3R09RaGZLVUlRdUJvMXBySXdxMThoRVJZYUVDS253Z1E4a0lBRjhldlNhT1ZDQ0s2WGluSXlnNWFSalNha3NLVU1aeWJoMG9JK0o2VXNqUXhscHZrazVGcTNKQUFoUUMxT1FBZ3Ewd09oR08vclJqMG9BbTBwZ1NXWkt5bFRublBTcFVEVkxVM05LRjFRRUFBUzNtRUFpYnJEVFl2alVGa0hOYUNrNFd0U3lHb0lJVmdpQ0FaUktWZVkwOWExQ3lha0J6Z0NEYzFCVktYaE5TQS9JMEU5Rnd2V3ZhbW1yWUplVDE0TmdRaUFYNklKRm1SclZ4anAybW9DRjYyQkpvaFNtL0VNWCtlanJLNTM0eEsrNDlERUdmYWhqWm9wS2xySlVwWTJ0NTJRaFFoQ21qT0lmQy9qQ1NCY2JGSUQvQ3BSWWhXdVFRc2ZKVy9reFZHOElOVXhvaVZPYzB0b1VrZnhTNUFvb0FBakZzcVdwdGkzTlFPMGt4d2RsTUowYmRNR0xtTENFWks1em5lZ01yNlJ5MDF0Y09mT1pmSXZtVFJPNTJoZTZFVHA1K2VZRjhXVERkTHBIV2EweVF4b1N3Q1E4SUcrWXdvUVBpVjdBUGZLUTRBUXZDdVJzZGdQUFhhWHh1TWtWTEdkL0ZOQlp5amVPTkxUbGRaRVVUSVFGWTFud0FrRDRLQVlpTm1CQmJNMGlRWHVLNk01U25sSmY5SXh3bkxoSkx1bGVtRWlsd2k0SE8rakJFQVVqRkhpRWx3SVFtTUJsa3E2TStBSU15U1lhNDdpMmtZS3hsQzV1dFRaRnJ1RWhESCtvQXdEQ3dJUkwrQ05RMHNyazd3UVZqQkMySzhqeEFnQWYvWWl0STk5TC8yOHZubWVUWlp5LzU5UjRsalBFb0hhMHh3TTAremxLQmZDaTd0ejMzeUl2VTF1bWMzQlhtRHpualZ5RWdnRExjNVZkNElFL1d6cFJUYWdCQzBJaGhtUWtJQmdYazFhcy90dm0ydERvakJGbGNvU2hmTFdXVlJkbU9Fd2NIaXp3aXdOY3Vqd3kyQU1BeE5CRklmajYxeEREZ2hRQUlZNFAzRHBLQjJSeG92L3lRQWhTVkNOMXRuTWpad25PMThFNmgvNEZHb2g2U01BOGpIalFtaHl6NXVMQWlHT2poNGdvUEtJcGszaklKU2FTa2Z4RGpaNnBpRzNmT1VsUW16dGFEd1FON3VQMTd0ODkvdUNuNDNCbVBNb0F3WWRHc2dxaENXTUNzVHBJOHJaMmhHS3RReWNKb1FybGpsdUh2dWh2UHdLWXh3Ry9ONzVETVlydTlRQUxIdjlxVkJnQnVieUYrOFZiRTNWNDFYalN1dHhLbk43dWFZRUxYb0FLTFhxYjR4MDMwVEI1Sis1ZytLSGc4U3FBNVBxWU5wWXowT1VQdEtuTTlWZEJyWHlUeXZXMWNoZ3djZXdhaEMvY1lIZWJ4SVR3ZzlwZFFOU3hPcDRZelhTdmRVYzk1dXlGSmY4a2ZUanVYQUo5NXFiU0hzRDN1WXBWRE5SQ0VNTWVBdkRuT2dSajVXUEVXNUxUKzd5S0xwTHFWb3QwdFc5T1JlMWFvQkZNQUVNZEFORUhScmdoQ3NiT3UrZ1BsZXgwRDFMUmgzUjhSR2hjZGF2TEYrdVJSSnlzczYxdG1vR3RDclFiL2FYcjRMSGxOYkI1elZZMWUwUGpvNnNBN1BYVnpib0dZejE3Mmd0TkUwN1FQYXNZSVFaTEZDOFNWUUFEQXpiUWd3T1lRUlpUNmtIL0M5ait6blcvL01FdGRLRk5EbVI4S1U4K3g4dW4rSkkyRVgzcGh5bHk0cU9jMnVKVEg5d3dHTTdkc21pTVJtYzE4VTkzaG1mdk4wVVNZZ0dkOUN5eTREbTVNelJzNEd0ZkFpOFFNR29lMTJiTTlIL0NkVW9SbFVxUXhVWVNKbmZ1Wnk3SkYzdjBnVUJ3Z0hjWXdnTjF3RjhnQjNDMTl5RnNzQUhOY2dEcndYK0IxRXdBR0dlWWdoYUJKUkt2RUFLYXRWU3dGR1VsQ0U0WnhodXhJVjVVOUYzcUJFekFaQUhzY2g3cmNBQjdnQVpEcEYwcnRvTzNVa3JQQkZFQ0dJS2JjaFFmOVFvNUlBZmJWRnNVRmwvVFZWREJsV0cvVlVQbGhSM2xkSWQ0MkZ2QmdVVFFwRjdycFhwdFJWWm1aUWl2c0FOZE1GdEl3WDVuTVJhbUpWQ2svelVkb0RWY2tqaGNFUFdCSUVpR2p0WmVGdEVLUC9VS1JLQlJnamlJUkdBRERsQ0VUeFpaSnZWWXFoaExLZFdJalpoU1VCV0VtZ2dTTkRBQlhDVUEwbUFLclFCV1JQQ0pZMFZVZzJoTlJ4VUNRR0NLSTRpS3lKaU1CRGlMSUZGWXptZ1FlOUFGYkpWVHlxaGF6SmdaSm9FRTAxZ2d6NWhYNmZBR3hqaGoxVGlPVEhXTjdkV05CbkZZNlVBQjRlaFBiN1dLcWtpT2dHV09JWUdPaC9VUGNrRmJpb2dnS3VXS1lvRmE4QmlMOHVnUjlQZ1NlR1ZadXJBRTdTaU9iQWhmTGZXSUVFbFQvaWlBS21VWkFkbG9jTUtNTUdGWkh3QUhDMm1FckxjL25yVWdrMWlTYlBJWUVXbUpyMmlSbDBGTnEyVVFIL0FCcnpVRm45Rld4ZmN2RmY5R2tvb1JoeTdUVUR6Smh5YVpHRElsa2NkeFhNZ0ZpSW9rRUhEeFduL3drZTRZa3RQbVNCZ21oM1ZZbFZacFhqNzVrK2FuR0pWWWxKaVlpVG4xRHpLSkNtamdsQ1JSVWpFa1EwT3loRVZ5WGVLbFlFNklHM2Q0bFZoNVh1aVZYcWsyZ0t4VWtIVUJYV25wVFZQV2szWjRKSHVpY3kxd0NRcmdBWXpRWitZeENBZ25oYUlFaGYwWGwyZlNZdThFWElXMFpIK29mbndaT0dqcGtJQkpYZUpVWmZHSEIwemdPS2t5QXFEMGNXSUVtVHJZQXIrZ0FKZmdNVWRtTHh5NGxmTGtiTThHYmZUNFhxQXBsY1hDbG5NMGNSc0VIeTV3QWMzU0IrMGpnMmh6T2NFQUJpeDRIbWJ3QXY1QW03WFpUTGlwbVVmSm0rMWxnRzE0VzJ1WmZMRC9zMkd5MXljdXdBS2g1eXdRQUFwcEYzWTBnekhzc0NydEFBZnFjcDFOQTN6YXVadmNTVlVOMlg1cUdaNzBaVTVQeUh4cWN5SU4rQzZNQUFwQ2dIWVUwME9NK1N3cWxuQU05SHY0K1lQYk9YeFBDV1ZSNlhxNEZad0JTcGpGaVcxK01vTUowQSs1WjM5VDhnSmtrbmd0MTRNTU4wK3llQlJRR1ZCWVk0SWZhbDg3TnFJaGQyOXNFQVFvQ2laUndBUVcwSnEyY21ybWw1dDZXWWJyTjNOUldhUHpCWDhEbXFPME40TWloMjlzTUFJbDk2TlRzZ0ZzSUhSL3hLSVR1bmpuWjZIcHQ1Y2g4WENPUkNwVnRoMHVzQWRUZ2dwbWNBQTlzQUVNQUFaVkVBa1dZd244VUlGYUdpWThJQWJ0NmFWZk9wbFA1NkxzSmxGZnVaOFRCSGxJLytoNlNqaHZCZE1kOWRlbkJZUi9neWFvUlVhb0N1ZHlqUGVQaWZwb1RIcDhDWmgxYkFvR2xLcEY4Y0FDUzhkMG9TU2hnbVNvdWFtYkdKa1I3aVZ0MCtha3NCY2hMbUFvcCtwblhwZC8vdGFxUmFwdWU0TkdpN2FadEVwOGtDZDVUMXAzTzllcktQb0JVZUFHVndJSWNBQUdUTkFJT3RkN1lZcHE2SGVoQkJsdHFWaDF1R280cEJxaXp3cXQ2dG9PbHdBanZzZXBTRnFteWJwNlRGcHpjUVNwSWRvbndRQUFXUnBrbUhBQm9UQ0JFZWgzZ3dKNFdBQUk4YWw3NjVBRzZOWnlEZ1J6OGpxdmo3Y1JkNllYMWFhQXhWbHh3U0FHbFZSQXR3QUFsa0N3N2JsSkZjTUdmZ0FCb2djRzQ0ZG92eGVBU2xSUmFBb3Fyalp2VlRTaVgvL0RCZ2VLTTY4eXNDUHJudU16TVNFRWZyZTJCUFRTb203M3Jmb3BQY3RxcjQrRXNUaFVjU0lYREpFUW5mQUNDRjhYTk16NUp5UkxaaG5uWjZoUUJ3MnJjRWNMWSs3R1JwRFdhdjV6cnZLWGJRSW5CQTJBTXlCQVBFQkhhTTI1TnIwamRtRERPVnEwQjV2Z1N5ejZabVBiZU84V3FoQW5NRTdiWWZZV0tKOG1CQUJBZUJ1akQxZkxkQjRIWUppRHR3bkFiUU1rQzVqRVg0aEhmbmx6dFBVamZJQURiMmg3UVllTHVFQVRESnBnZzkwalluUDdNNnhab0cyelE3Zm51RGpqQnFvYXFLUUdwc3QycUhDSFB6RnJzWVpiZDlpMnNhaENRazB3TWJ2VFg2eUpOcFo3dVNPQU0wMEFDcm5UUjZHa2JKOWJyQkI3b1VwTHNhMTNkYS8vUnB3dXdBUmRxMFhzSUFZUjJETlplN2ZQS3dTc3V6Ry9lcW03cTBDbWRuck1sa1lSMjcwYVFUMVdON09VSndLbmNtc21nTDdBcXI0eXFFbGpwdzl4MHdUcHEzWnJaM290ZTcraHk3MzZPNjVONm1ybUNtc3VrTE4vNWdRb3A3dyt1N1VneEFMck1FQU1BREhCT3FoSDFydFJsNzhWYk1HUjVyOFl1NnVqdHc2ZXcyOGlLN0tmZzZWYWRBRVlTQ3VlRzhFMzBuQVlHck15TzZvYW5FVmEyZ1NBQUFaWVlESEE1bXZGZ3dWZ0FBaE53SFhINWdiOU1LU1pDc0dMMTJ3dVRLK00ycWhIYktOcjJnSUFvSzVxSEFWcDRFdEJ6S25idTV2S09zYkhsMmVVdDN3aUNqU2ZkakY5cHdsaUVBb3NBQURscThaQU5DWmVESFZJVzdhYy95bXUrOHUvL2Z1b1VGcXpVRnVsbkVUSUpRUUkzQ3EyMmp2QkZEekhUTXFLU1hpdnRrUkhlWnk0WThlcmxodzNIeUFGNDdmQ3hJcDZxWWVVTDl6SS9sazlqM3JISE5aOHBueTVaWmZLMGlzTTlCdW04QXB6b3J2SWl3cVZHK3FranpUS3hMbGpXdnRqNmVuTGVoQUZYamV3WWhkbXdlQUNtOUFQVEhBQ0NyQUVjS0FBWVN2TVc3bGt4V3pNb0RwaEI2ak1XS2Q4NVRtaXdjQ25oTndIeUFEQyt0ZXFScVlmZ0p1ZHFSYXhFbnVXKzVqTVVjVE1UOGhCRnBBR1BlZkxBRkE4eXh0R3JablBMR3RlVzltcG51clA0WnFJQVEwazdIdzlhNHF1cVB3dUVJQUZtbEFGTEJBRW5NY0lNZ0FDUnlNRG5rYTNEbTFvRUIzUllDaVVxUDlrbEU1V0lEY0p5aHc2ZWJqTXB2TE1LbW9ndHprOHdpWDhMaHR3ZUlWbWFKcGFtYmVKWHNYbGxZbDYwZndwZDNOM3k2UzVKK1BiQjlFc0pZekFCRWhOcGU3NVl3L2FLdkhReGtUcWhaZkpoMkk0aGkxNTA1cEkxVktwcHFSWm1pNlFCc2hKSGgrd0FiOUFaTEVyTTFQNk13bkFzYTF5UUlCa24rV24xa1NKcUcydHBDQUJBR1paZ0JwS28zd2htblE0bnVna21TSHFtbnh5T1MxdzEyRENBNHpnQWJMcHFxVFVZRDZvMk1qcTFpNWhDS1ZRRGZ6a1ZrZTRVc284bGNEQlc3bEJtYmlFMmV2VUFta0FCMm1BQUZ4b1pIQnBtVE9kbVd4dDBXYmFGdmdrQWE3OTJKelNuNjNIb1IyYVc3cFYyM1JwaDAySTIzR3BHL3pSZ2FmL0xhdXppcUgyVkZSRUVBVGE5Rnc1SGQydXA1T1RxSlhWdlZEWHJZZkFjUmhjR1UyTXBzaXkzRmJCeUF4Wk1BUGJlSXJwalpNVlptT21FWWxCQ1lmdUhZZWg5ZFRIbXRwZ2FZNCs4SXZBV0ZSb0dBaUlDT0Rxekk4ck5aR08rRm1nTmQxQldZbkdkZC80bmQrYUNBV2VLRllUWGxhdklBbkZpTjUrZVpHTFdKRWNYdU0xUmVMNktkNzBtSXVId0l1K0dJcG01UU9kZ0FibmpkRURlWVF5WHBGS3pwSlJWVktkU1JHSjhBUUNzQURGd0lrby91TXJibFpFOEFBS1VPVExjZVNBSmVPbytPUWZnVlcxeUZVOFpRbzlIbFJZSG96NGxBb1N3QUJ5OE45a0xzWmdqb3lLZE9FRkVwTld4UXExR09VNzFWT0hBRlM5R09GQTd1YUUvMmdGK2hBSXpsM250UnBabW1nQVFBQURQcEFLcWJBRGVrNVk2TmlOZ2dDT2J5MlBqaTRWUnJBQ1FVQUVXVURub0xIcGhlVUlTK0RsT0gzbkxobnFyWVRxcWE3cU1CRUFJOURvTGdIcjR5anI1MmpyQjdGWHRBN2p2Rjdzak8zckh3SHNTdmtQTkFBVmZ2VlhNbzdjeGk2Q3lPNFd0bjVZYXZBRncyN2tueG50OERqdE9PWG9tMzZQZTBBVHp4N1FVTFhrUys3dDRBcm1aTjZOVGZFQkwrRHFJSm5oQUxYaE5vNHBUTTd1RG02TjVsaFlsZ1VDbWFXUEFTNlMrWDd3L3dpUS9ON3VxdjNyTVdGWnJERHdCSS9Na1JjV014VlRHSS94RUlud0NhL3dxZVhrczdpUmxvVUtFai94R2xyeGJnaFRJQjdpR3YrSUhDOVJSaG5WRC84K1dBbkJGSWMxN3pZSjNlcHRZWk45NEQ0ZlQwTzU4YTRZOHd5UHpoWmxXREw1RDN0QTcxK3U4enB0WXlzL2xRa2VYRDlQWENLZTJNY3Q4MUlkbHEyVjlHcWdBc2Q0OG1TODB6c3BISE40OWd1bGxWVi9rc1UxNG91OWpMWCtEM0RCN0crdzdSbDY4cko5WWJSdDNmRmRYbWMvOVNVcDRsRGQ3MXZQSTNMUDUvK3dBYnErNndGT283UHRvYU5wMjNnNCtjUnRsV2dQWFBSdFVBeE9wa1hmVm9oUEFGL3c2dDZKay85NXk1V2QzZHBObVhQWjkya3ZIQStGOVRFZjdvcjBBNnlBajB6UCtFN1ZUZEpOMlhRb29QbGhIK3FDYnQvRk5hbGZtZVZrK1hzNDBZMFJxellOOTNTeCtCUHhqdDhKbklJSnBjUzVRVHBubWdDd0FXci93RDA4QUFZckt0eTZYWnVxejkzOGdabVoyYzhXN2V0d0ZWM0RFcGppNlpiYmdRY3VjSmhnTUFJa2NLSVpJZ05DQ2hBSUJBNGtXRkNnQ0lRSkZTNFVFYUZoQklnUkpVWll0a3pWUll5cVltM2swTEhDUjVDaVJNSGlWTEpraDB3cFZWSmkyZEtsRjVneFpjNmtXZFBtVFp3dWRlN1VxZEpueWc0bVRjS0NKUXJrMFk0YlkyV3NPREVobmo1NnBFNmxXdFZxSHd0NHRHN2xhdENyUVlZS1d5QjRPSkdpeFl4S08zSTQrbkVrU1pNZFVQcmsyUkxuWGJ4NWFkYmxTK21uVDdsQ1N4STEycmJDMm8wWlZTMXptaENCQlRCV0pVK1crZ0ZBTUs2Wk5XL0c4M1dnaXhPTTlMaEIwNkpGUXJNVUZYUDAyUFp0M0xrcjYrcWxYWHRtLzErZWZ3RUhGVXEwcU9IRFNaY3lsYmp3OHdiS3lhMGVpSlRBOUhQb3BqbFB4K09DU1EvSnFQWXdjVUVXNGNTS2FXTzFQdm82N2srK3R0WGp4ZDFUTjFEQm5Id1hib3Q0T0ViR3hSMFQxS3BHK1grcVhtRERBZ0lMdENBNkJCTzBJSUVSUmdHd0RRQmNPTzA3aWRDNmlEVzJ5b1BycEwvU1crOURtZHBqNlQyZ2VPdnROOFBzdSsraS9DSlNpRCt0TEdCaUhRQnIxRU1HTVlJeGNFY2VlV1FqRkNkc3BHcWREUzdwcml5SUxOUm9MZGVJRWlxMmxQb0M4VU1SU1F4TU1NS0FXNHVEeElqVER5RVl0Mm9oR0FDRXRCRVFJUkpRTTRFZWVRd21BVURNcE95QU1NaXFVRHp5UXRxUUV5aWo5SEJLdmRwNzc4b1RSZEpTT01WVU1mL3J4WUV5ZXk2WU9PVUUwSXdxMkZqelVrd1RFQUpJU1pNYjRpQWtsV1N0eVQzN2JBL1F1d1Q5aTlDaFVLeFB1QlVYYXd6TU1MV0N6b0pnc09zVXdCOUNFY09QWUlRUWxvMWdpbVZqaEYyVjYyRXNoZTY4Y0x3OEszRHlQUFJFUlBXMnZuUmpWYjRzVTBRVXZ4WWhNcTVScm00bE1JRmszRWgyMTNqYWNXUmQ1VGJvRHRSUUxSeFZ3MUk3RkpHU2E3M0lkbFVzdTMxVkthYkNkV2cvY3NWOGJzZGdxZ2dBWG9nanJxb09Gem9iQ0xXSTdJVTJRN2RHZWxMZmZRSDk5eWNUQjNNVkpQc0tubFdFZ2h3MTE4QUUyRkJBWXBvaFJpV1VyTFM2bU1JazhlVFlyV2s1ckhaZmZ0ZmphOVdTQlVhS3kxakRIVmNnelY0dThGSWhrS2ovK2VwZFpkaWtoYTUyRGhXamV6VVVyRTgvcmJWdFpQZ0s5YlpMRmxldUZZL29lcncwV0RCTXdQcHVNL3NJNXJtdXZlTlpWR2dOQzVwUHNqTWh1cmFqQVF1WXZvOVN4c2lwNmx3NFVMcHlGK1lSVXlHdzBCVnZ6bXRFWWtDK3QvTDY2MmVaeFBkajNVSU9ORGVTZXpOMGFiWmxkUkVQSnV5ZUtoNFRuQ0NoRDBEcVVDQU5PM0JsWS9oaTF3eUdEU1FlN254NUFFUFJjWExLZGFiWDJkSi9CanJmMUU5bHI2N1dXMTE3UmYxYUNBT1ZUbVV4UVJ6ZW0yQisvZitjMElUTkFrT1hmdnFNZlNiMXljTE56b2w3eFUxbVBEaTJPVTBFTHFnQit3eTR2QjlZQ240RWdrN2ZtbFUvc0psT1QzdmlVL2FrdEwrZGRJOWIvL3VXN01RMS8wQmtIVkNFZDZ0Qm10UzBvd2FLamw2a3UxQzBLbUNlaytUdlR6VkpYSWxheGJnT2VoQWhMaWpBQ0gySU5RYVk4SVFHa3AvRjZOY3pzQVh1ZEtpanl3VnB5RHFWSkkyRFRNT1BpMFNBQjlIOFVJczBrd0VXRkRoRUJoYVJJQmhEb2thVWVCVGZNRkUyTXd3UkZOTzJRZGpkcDBVc3U0UU10bmhIbXFIcFVpaU0zdndlcUpva1JndUdGUndhVDJ6Q1A1VzRibUFaa1FnQ1RrQWpQRVlTWWp3SWhTV0lCMGJvOWMxdjFBdmI5ZkJYU0owYzBvMVNYR1RieElXSE5QQkFrcXVNMkNoNDBBNXg5S0FBSTlDSEFrTEJCSDlZd0FYQmNJR0VMTVl6UUpwUmtJTWpHeHRoZ3NoTW1FaHBIWndqeTFxd09WWkdzM1Bya0FFSk5nQUFZZi84TFpEV0c2U3Back9YRFBZUGppampVaFUveURJRXVBQU01Sk5tTzVmbmpnbEJVSmpjSkNZbzdRSk85MFJ4S0RoTWlqa1BoazRFVktlSDdyVEtPcHdBZ1FJQVlnUWpBTVFlTGlBT1ZSSVVRQXFJWnhrN0tSTHNyVEdVMkFwbkl2Y1pSMy9TS3FCYVNVQWFiQmROVlBRQUFIRVkxcHN5bFlCaUNTc1lvZGhERkNRcUdUVjRSeUpwR2VhR3ZMa1RmT1l6bVlva0o5djBrekRUc09FRnEzUUNHSVR3eFpkR2RXNUNFRU5VYmpvVk9MaEFtOVZyU3owMXV0R1lJRE5wcGRTaFNHMzFuQVJvZ2dSYlJJVStoT0JTcWNZMXFrS29naml1aW9GRzJNbWlad1NhR2cxbnlEWjJkS2dtSTJzejBhbXdGaFNJRFN4Z3h3ampBUUFoWXFyL1RaTmQwRXZaQUFwb3RoTVFXaTJMdllicDEyOGUwNDJEbFE4L0EyaEZwSm9HWmtJSUlmdjBtQ25LeGhabW1HSURGdFRsemlRd1FhL0IzSmpZcVBYVmU0cFdzS1E5R1RQUG1kckVUZzJtb1BEUDh0WVJDcWhpVXJiVHpaUVFJdFhPQW1oVm5oZk5hTm5BNnE5UkVyVng1VFRsUDZHbXNObXFLUmpxNjV3SnNBQlg2Zkl4UVhGckUrYksxRTRlNlBZaEdzdVR4MzdyM1pjSVY3REtoRVY5VG52Y2tjSk50Y3FOV1JYaU1jMUtTWlpIODZXdzVTNUh0UUt5a2gxbzRPeCt0K2xib1FHWEpXRWRMWUZCZXBHam5sZkJ5VDJYbW9TUVljNjVWY0x5clhDRjVVWTE1RVNTQk55aEgzOS81dDhRL3hXdzRCMndNazA3SE1PbU5yMmEvOXBENTVvQTB6MU9PRUhUbWUrTjFlc0hPMm94Q1hCd3poZzcrMkU5Q2NXZUl4YXdTelM0VFBLV05XRUtUdS94Mkl1M0VVUjJnZkZERUhVUUs3VVdyNG0xUDd5QUhUQ2pRcDFhVklJdjlPbVlpMFprb1JLM3dFZzVzSGtUYk9FRlhSWVFtRmdlWkdkTTV4VGErYXowWGZKaVJTZ0RLWUNPY2w3YmJyU0M5dE9OMWpDWlJqNnhvbENyWXN2RnJBWTJYUjhZb2t2alBtcDZ4WkRPYzRPVnQ3d0FOS0JZWWVTYUg3ZTZwQjkzMTBPcUpyQnBRMnJXczFxQURWWElvZ0ZsSEdWTVoxclhDTHF3bW43a29NNzFJUktXSW1MMGRyYmQ4VFJKekUwRWFwbGJjdWJpcGpuSkNhN09LWEk4d2o3SVdjclIwZld1Rjd3akRIZk9ESEdBYS8rNWkyM0VZL2NXSktjMk5JbUh5MnB5eXZ2VlVBc0dHTnF4eFhWRWVFMzc1cmVkRlFSd3FtWDJhaENBYXJtN1JrYlBKcnZRSWlZem9zMnN6NDhXVlk2dnRzQXZCb3JIQzl3YTEzVytNN2U3SFRNV0xDL08ySjRjb0ZITzFURC9kOWxpRlM4QVovNUIwR1I1bFEzUU44ZHIvSEdRWDFucWVHUEJGdzF1OUMrWFR0MUJGakpZa1VuYTByWjZqc0lJVWp1UlVIV3JYNzIrY3dPRlhRVWVpWUpqR3V5bFZyblNRM3QyVXNvOHBDNW9yVFIvQVBjMlVUaTJtQW9HRnQ2MVBCbnd3K3QwUG5uQys4dHdsZ2MyMFlFZnI4VEZoUUJoM0xhZFVRZ0Y0cWRMMmVybTRZQWJNS0hKalIxMlpJTllMdXorTHVDYkRzQm51NkFPTjFYRHVGLy9ldnFmNnprVUZ4Y2hLbXl0ZDJPajIzcVlCM0NBM1QwaWNhWWRkb3gwVVVDclRWQVpzT0N0Y1oxN1ZPbEc2eDgyb1RtWlBpSi91N3J5NXJmOCtkQi80empIMjJpRXRHQm1WNVVLQkVvZlhibG1pZzJidXY0ZEFiRzNnL3NseTBzMk5Rb3RoOXU4R3hvWUpOTVBGN2dBK3FPS0pDZ0FGZ0FGbVlJdnh0cy9VR0NCQWtpQ2Rrb0NGdmd6aEtPUThKaW5KZUtFaHVNb0JQUWV0Yk1pVkdLbkI3UUtkaENIQzlpREVVQ0NCaGdCaDRLb0Y0U0FVK0NhYzl1cnkvdXZzbk8rQTN5NUtHbzJCY3k5Sm50QkpwU1VHcGlYbzJzaGVoTENJZE84RlBTZkpDeXZoRkNBRFNBQkdYaXdKZ3hENVZBRGZ3ZzBpQUN6aFVPL0lRd3VLelJDLzVnanJLVkpzN0k2ckJad0FaaVNuRTBRZzFCUUFIM0F3UjRRQnhtSUFoY1VRNElhQlREQUE5ampyZ0tzd2paOHQ5MXduU2xhRWNNQ3FNcjV0OG82SGphd0JDellPa0prSllyaXBFRURNa0pLdjBORHdZZExtcE54T245eU5CWGJ0YXpURkt2cHhGVmloelJBUk9Yck83SXpRRk4wdy9aenY4NlRSQ3VDdGsxanNWNExoaml3TzFuY0lqZklLeGJpSzBKVHd6VlV2MTNreFZVTG1POVpSVWFoTnp5akdnQ2d0R1QwSVJMb2pHWjBSbEZFTlNJTXF1SHFSYVZSUld3VUtXMjB4TXJ5dHFEN1JoSEtyaWdrd1JJMFJ6WjhJclN4b1JPNXhuWUVxSGNreHNyYU0zbzBvQkhnTEU1U3VEUUVMVWJrUjFVN1FyVnBOUS82SjBwRUxQK0FDNGExT2tqbGFJY042QU54TUFGWjJCVU9BeVpSR2JSbmhJMFRUQlhjR0pURmVSVTVGQ0NCck1TcHdZS0k0a2pKMkFCUStDSmpJUjRMc0lNMFVJQTZHSUVDSUlFbWFBY3dsSXA0T0lHS0FzS2Vjc2lIRkNWVklSbFVCTWp5WXNWSFd4Z3l3VW1yVUlNcWtMTTV5emFhN0tXbURDWjhMTUZSekR6YTJCZVhUTUE0Qk1aZ3JKVkh1UzZjdklVZzJMNUxJN1lBbkIrL1lhRjVzcDZVRk1Kb2xNYnRZVXVBY2N1SWcwc0VlOGNFNkwrRFpMMjhoSjY5TktLK0JJL1ZjTWJBRkV4aldoM0RmTVNZUzh5blc4d0VzNEIrT0NtY1pBQUY2aEZ0bzh6S3BCNmt1eCsvR2t6Q1JCeWlPVXdzcEVpWkpCY1hrQUt1bklxdTQ3ak1LSWovUDBvU3dFRkpUL29rUTl0SG82bE5EZUlXcTh6TnovZ0R6akVCcEJ5aEtCQ0RPVnRONFNTak1ub1d6SHhHQ3BLaHpRUVI1bnhEWDJUSHE5d1BGMWpDcTltRG5jUkVZWGtyUDlERGU4T2FKOVBMNFBReVlESkxNMkpJdEl3aEM5TEZmbkc1czBPN1ZNUzlnRVNBRm5CQW1qRUJwOG8vbU9LSHRyc2F2ZEhPMFRFTEpmbEw0TUFvQ2lLYzk5Q2VBWVhJRXB2SXhQU1NEOEtERTloSWVDa0FndXUrNm1JQXJFR0N2Y25QQzNYTi9qVE96RlRKRHdYUkVMMkppRFRRUmNQTm8zS0JSaGlCbXhTU2RqZys0QU00UHppQW1wR0NpZ0cwMXR3cDhmRFBDWXFQdEV6TzcrcFJsaHhSeFB4RnhiVEk2Z0NESWFpUkRUZ0Y1N2c2Z3ZRUi94aURsM1pvaEdMVFR5VGhUd3paMERRYW04SWh4YWprVWg4dFVGU2NJaXBhUll0TXAwWUFCRWlxaWdOSWd5aWxEalUxRjVHVGxCNllseFVDaitKMG9SY2FKQThsRWFLWlRUN0ZvSFQ4VTVpTW5ZbzhwL2h6QVFWd1VpZFFnSXBwbVg3YkRBUUpCaFk0MUU3SnFrbTEwVG8xakxjSXp6eVZ6ZkhFQ1FQbzFINHNtZk1NamtBRmw5UndER2JKUnMvd2luNUxnUG8wa3dNUWhrMnFrRW9GVFBERTB4M2RWRTdGaXdlWWdWemcwMkFGVlpnc1ZtTk5qUzhKaTZkWlZvTVFFenR3MHVSSUFrYTRKaWFvam1TZDB3eTlWZGlNVFQzbFVmVXdoRmNJZ2hVQTF4OFYxblhzUEthSkZSYXBDSU14MTJCRTE3QllWaGRJZzR1TGh5YllnLzhsU0lOMFdsV0d3TkRMdE5JY3pWUXQ1ZGNQTVFSRFlBWVVVQUl1YlVtcWZFbHZVWkZFU1JTRlZWaUduVmxTZFZpRXFBNXgzRmlHelZBTmRRMVJKSnhpMHRadEJSR1NKVmtpcUlHQURWR1ZiYzdiUEJRVklaaVhqZHFFalZtYXJWcXJ6WmdSVENLUC9kalpBeG5WNlZRdktGcVNUWVVzVUlGdkhkQ3BqRDZUT2RCeDNSS2xlRnVvbFZxcGpWbVp2VnE2amRxM3hkRmNIWnNBZFNLd25RbXhMZHBYYUlDa3ZaWXEwUllzblEvZ1dOd3RhVnkzaFZ2SWxWdkpuZHdxM1Joci9kZ3MzZGVoL2R1d0RWeVNsWUJTQUlCZjdaZTBYZG40OEkyaWVKM0ZYZDIyZGR5bmhWeUVmVm5ZdGR6THZWYmtwTDFlNWR5WThGeXhUWVVIZUlmLzBVV1Z3eDBVWVcwVjFCV0ovMkZkNVcxZDF6MVl5RzFlSEEwSlRNMWN6ZFZkdlpBQTNoWGJWMEFCSURBQ3crMU1iZG1XeEVWZDhrVmU1RjFlOUYzZDZGM2V2Y1hXdnQxVDY2VUpDWmhmN00xZWZ5MERKVGpiS2RsVUVqbEM4Y1hTOFNWZkFUWmYxVTFmQXk0UER1MVFrQTNaelkzZm1FZ0ZIeWlGK2JWZmtuMkZITWhmNGRYVy9rVWF1ZmhmQVA1ZzR4MWc4ejNnUzAzZ3dibGRyODFkQjU2SlZ5QUNDSmJnK3JYZlY5aUI3czFnb2ZXTERjN2gzZWhnSGdaaEh4WmdJQ1pmSHdiYS92M2FGY1lMVW9DQ0ZvWmcrcVZnZjEwRDRQM2VHM1pFSGE1aTR1M2dJYzVpSCs3Z0RkN1VJNmFOWW1pRkpHN2hDSjVnQ3E2R1ZMQUMvd1VvWEpHWllnMjJZamptNFI3K1lEbnVXaDNXMWkrdURRS29CVk00QkZ1Z0JSY3U0eGkyMzFKSUJRWUlYaHQyWTBWT05EaHVaQ3UrNFR5dWpSc1lnRDAyaFNRR1pDWWVaQXAraFhPSTRwUmRaRkF1VUVjdVlrV09aUFdZZ0VrV2dBVUlZMUtnQlRMMkFUTjJZa09JWUgwd0FQMEYyMURPNVI5TjRWdzI1ZlZnQlJwQTVRRVFBR2t3aFZiNFl5SWdBa0dXWmNHMUFUQmdZMThXVVYyZVppK081ZzhKQUZhNGhRbFloVW11NUVPQUFreGVabVkyQkFtWTRYZUFabXN1VEdxbTVyODFBQWZnQnM3OUFGVEFabTFPaEc0dWhqNEc1MlFXWkUybTRGSjRoVEk0NTNSTzVIVlc0WDdKQlFOUWdDdzRCRW00WlQ3RmhBOFloWGtHWmlwVWZnSkt4dWRMM21jWUh1ZWlMZWR6Q0lNVmNPaUIvdHNHem1NRE1BQTBlSUJYR05zZEVPa2VEUWdBSWZrRUJRVUEvd0FzN0FESEFPOEE3Z0JBQ1A4QS93a2NTTENnd1lNSURhYkx0OEtMdzRjUUkwcWNTTEZpUkVvWU0ycmN5REdqeFk4Z1E0b2NhU1FRa2xZRFdoVmJZMlNreTRnSlk4cjgxNE5NeTVjNE8rcmNpVEdUejU5QWd3ck54TFBvVHB4SWt5b05PZlBnaDM4ZlhqUmM2dEpveHFFL08yamx4TFdyMTY5Z3c0clYyZ0dyV2FKVzB4cWx5aFppVEV3Zk1QMlQybGFrVmF4YnY4TGFLNnFDMzcrQUExZmdRTGl3WWNLQ0V3c1d4WGl2NDcxaUk1TXRleGFvV285MW1mNkQrd0hWdncwRzJGN3VhRFp2VjhkOUJSdU94VnFWNjlldWw4bGVGcUcyN2R1NGJjOWVCcnYzYTliQVl4MDJyTGg0WThkaHRacGRtN201bDlHVUtuY0lpMXJ4NmxpOWFkOFd3WjA3bmhPajlJai9IMCsrUEhsTUFGd2dXTSsrUGZ2dThMbEhFSkc3L216ZnJvTVRYd3pacS9LZ1JUbUhsRkdsVGFjWFg5WVZCbHgyMnRrV24zdDRSSWlIQmFISVl0NkZHSnBYUURBV2RHaEJDeUNHS0NLSUVwWm9JaDR1MkRFQ08rVHQwWWdMM2VYRzIyL0NJUllZY2wxUjl0TlJBb0xFazFDbWNZV2dhb1MxbGwxdUQ3WjM0b2dlV3NER0JSbEdLU1Y1UGJBaGhCQnNCSlBBbGx4dUtVUVZFRXdwNW5oT2hJRUhmYnJCeHBxTmYvWEhsWTQrOGRnalJEc0ZaYUNRc0tRR1dKSFl2U2JiZGk3QUVZVWJKT3p4aHhTWHRMQ2xDeCtHMktTSFhTWVFqQkJpUURubXBaaG1xcWw0NmJVWFk1cjUxUmlZS0xENEI2QlZkZWxrNTJsNUJsWWtiQTE2LzhjRUJwdldhdXV0dUlyWkI0Y2hTdWlwZktDcXNpWUhvNWFhSTV4b29mcVNxbGw1MWVwZmZQcnBJQUo0a0pEcnRkaG1xMmtUb0hUWlpLKytyZ2Rmc01JV2RxT3hieUliSjA4K2tnYlVuWHU1YXFRcXNYSzNub1NLOXFEdHZ2ejJLMTREUW5qcm9ZZ2x2Z2RzYlRPV3k2WmZibkx5bjJVNlVWUm5zM2pxT1JnSGZkTHJvTDMzUnVpb2gyeUE4WUcvWWpiQkFwYVJwcXh5bDVOV1NuSy9mYlNBSnNLL21mc1hxZWc2ZkNwSEZ6SHIwNTJjUE90WHRCclgxaDE3K0lMWUpKZHNBUER5ZU91RXdrYktqMVp0OWRXUVJpckVCay9maWtrWU10K1dzS2lBa1dvcXhEdy81eTdGUWxwTXRDb2JpNEMweDBwYmtBQWJXQlNBU2RmaU9mOEJpcFpjV2owaWlTY21QYmpWTEVkaUJ0K2FwaEEyemFFdWpIT09PNmUxS3A2dVlpeXQwZDY1QUVBN2pJdUpSTUFDRHp4NDRhampjZmlqWGJMQlF1am1tVkZIQWk2RWk4REJFY3c0Yk5rNUl4dXh6ejg3Ni9hcnNVMkxBQ093WXdvSTZZRlhQZmp6MExlQU9KZkI4QVA2MDJBd240RHBMZGorYWU0MUUzdXptNzVIclBiYXdWZThKL0ZGenllQ0MyZ2t2K2tCV0V4Tk5kYjRxL3psOVh4dm9EMzNCYnZkd2NhMnNBcVFEMjBkNlJuNk1tR2FJVUVMWXhtcmw5enUxUUlYYU1rZmFhakJCa2pRanIzSmIweFJVRU1mQU5FQUJqQUFDWUQ0QVNQTTRNRVBTb2tkb1FnR3VDSmtzR0R0Ym55VVE2QkdMUEtqeTdFcWMvTnEzOUgvNWtZMzZTMXRTOEZnUTVoY3lFUitqVUE5QXB4WkJOUWt1UVB1S0lFaHVRdVFuQ1cwb1VGd2M1eWJJTFVNOXlnMjlLR0phTXlXRXk1eE94dVNyVTNvZWxpeU5xSVV5L2t3YUxESW5PYkFDQjhpdGlBWWRVZ2o3TXlnanlvRW9RQk5XTWV0MEFDakFhcnBqWDZaWEE2dm1EYm5GT1dPRHZSaXhvUTRSQ2NJMGwvTEs5MjNDR1lpOThSSGJBa1RWbzNFeDd2ZUNZVmRjNUxJeE5nV05JdHBNb0lOY3A4SVVJU0d4VjFLRFN5WUd2NVl4N1FxUklGZlNSQkRBa1pVeWw5OVR6ZXBWT1VxRlNQSnMxVU9peUVKVFhONlNFczgydkppWDRSVkxyY1RueUc2QjBLcE01ejBrdEdFWFAyaGRxWjhKdVJvdEVwV0ZxdGh4MXBPV25CaS80aCtNZ01GU3NqTUpiZDRJTVlVQjV3S1doQitHUFNuK3VDbW5PWEVBeE1Va0laR29NZ0YzWXZpS2UzVEcrRFliRlRWUEphNktBbWR1dlR6cENpVlFDa0FvTTJsMkJFdlFBUExZL2hpMElNV1p6aDhDczRtRjhwVGVnNnJnRGNMNlp1d0FoMUt4TklpUkVpRkQwb2hBUW1nOUtuOWZFVU9sSkFMbHhiMUtwWEo2bVJpS3BhWjVxbW1OZzFyQlk2RG82L0lVWWZtT3lwVkJrQ0FXcGppRUxhZ1JWS1gybFNvUXJVVXFXQkFTd1YwMWI1R0o2dEEycXBndHdwWWt1NVRyYzRaUlFCWWNZc0pyT0lHYkhYcklhQWdWNlV5MWFsMnRhc0VYckdEZDB3RnNWYjFxMmhIZzFnRE9JQWJpRzJLYWhQaWlDVjhGckdqamEyY1FNdVdYUC9jUksyclRZaGMxUENGMng0Vk9vVU5ybkRSS3R2WjBwWXFxb1hMUDFpUmo3M0Nsa0I0NmVwakdQTk5zWTZWdWw2TmpFalBPdHgxaWZhNE1Da0lYRWJ4RHpXbzRMZVhnZW1CdXJpK2hPcTBwL2pSNlU4UFkxMlFrdlV4Mm5YWVNBMExTN1Z1NFFlcytBY2dYcnVzdmhaSXBsOU56SFY4TTg2NERiR0NHQlhHUk5Od0pvaEswYUc3aVNaUDlVUGZneDRITE55ZEl6YkJXNUdYRGlWSXJHSnZleFhxcDNIMnNUMHVVRUN1MmlHR0Q2WFRkdWMwbUlVeHJPR2ZKaWFrNnVvdmljOEh2S3h3bGFZS3ppbURrZlJpSWhaUmV2NlFBYjlRRWN6dERmTlIwbU5ERmZSMUtYYkFvWHZQVE9VTngrZEs0aG9WdkxQc1ppYTlHRTR3aGxIL2pFNVduWWltbHdBaDZPT1QvWXJDSlNvc3hiRkJjcXhXNUM4ZGU1Um1CbkpSai9QS0pYZGNFSVo0MkNvZVRTaEFFS3FnQUUvaXVXdUFDRVlBb3lnMkdoWFFiUGswODRnTHpCRWZ4bXQ5aWQ0T0FxeDE2VmFQaVJGYTRsNzNhS2hqY28wNWtqblQyVFhUMnE1U0EwVjRLK1lqeDF3UVNGY2JPMHJpaUFQZ3JBeEE3MzNQejU5dUdIZUZMTXNGd3F1TDdKT2dIMEdVQURHWTROaDZZSWM0THJDQkVTQUJDUTNZUUIvVWNFeHdtNEFSRzZoREtQeGhRWXppUVZ6UDlyUTlBZTJmOG8yYXlCdDVGN0FmT0M5eWJ0dUlIZUtTblVPM2p1eXQ3TXBWV3hrYjRyQkVjT3ZoQlkyMDRVY0JIY2RYWXJIUTF4NmVrYlRkTVRrajNHNWIvOUp5ZUY0V2p5cllyM2xZanA3TXI2YTFQQnk3SFkxbzR6eHZYVTEvMHpITlFNTjJtK3RGUkFzRUF3eVcvbUFOdE1kc1dSUHV4ay8rMkJHOTVMUlBzdU1QSU1wMzVJcmxGWStiMk5DbkdkNGVoZWdDcnJsNkZDNFhaWWVnQi9YblJieDFGZThhQ2FSbTVSbldldWNGRExSM2VWYmtvTnVTZlhCemtFUjVBTzQrdkh4THc0emVNQ01WREN3NGdtOE0rSi9wbkQwekF0cXpNWlBjKzZBZDBuY3UvbjNzOVNxN3hjMERnU3FnYkdXb1o5bVg0aTYvcFRjZFhIY0hYMzd5M25FelM2eklZQTg3RUNQb1lDZExQZUVLcjhIb2g2OEhScHhpMXZmR3R4dXJhRTBSWTRhSDNCVDR3QW5PKzdncDZjbFR2eHVYaVEvdUpnaEQ1N0pYSmYvdE0rLzhNNDlFTFFSVkg2cXJyMHN4bHNoUmJBQUU5NC9OampUSVRJcVBISC9tZVIzYTZLZlBtN3ZuWnVZMElTY3dmN1hDQ0tFZ0JNc0djNk1rUFpLeVBaZHdBbkN3UVU0UUJVK0VPMkkyVGEzVWZKcjNmTEhrZnlFWGdNTDJIUWVnTFFlUWdBdElQVlp5Slh2d01tclFkR3RIU2ppbVVSZVdPeG1vZ2Zka1ZrTkJiYUFGY3A2SGFKdlVVQTdXQXIvZ0FTTWpIcWl3Qi8xUU82a2pjM1ZUUmlPZ0xRQ1FBTTNrVERYWVl6NzJZMlhGZ1lKV1NTRlJDZzh3QTFXVktvWDJmK3FuUnhBVVJDM1dZRWpTZnVXVVk5Y1hJUzdBQW9xMEtUWFFTT09DU2gyRmd5Q0ZUK2xTR2FTVkZGQ1ZDbG1nQW1QWWYyWDRNMXlGUndsbVhUai81VjRzeGxPejRWQ1VTSW4zNFJ2enBZVit1Ri9sZHhselVsZVpGVlVvQUFTK05TRG9CMWlUa1Y4SU5sUFVWVjhQOUlpd0NGU0xJVlQ2UlZUTU1XUVcwUXFrQUFXdk1GZE5oVm1oK0FwcjhBN09sUlRGNVgrRmxZcXF1RjUrbUY4aEptcWJoNHN1UVFNVEFGa0NzQURGb0l1MDBJcys0QU9nR0lvbnRWVDZZQUNIS0kzVmRvemRkUmFqWlk1c3NSa2ZNQXFvc0ZqVWVBTlB3RmJGWUFxN0tGZEVRRmZBQ0k0cDlRcm5FQVlyVUk3c2FJckg2SUhnWlFBR2dBWVA4QXI5bEFvN1FKQTlrbHNVYVJDQzhBYkZxRllIV1ZJRmlSUkdzQUpCUUFSWlVJb1RXWkdxRlFBamtKRjh0WkVzK1c4ZGlZc21lUkJ5UVFOd1FHQnpZbURwL3loY0xmbVNzUlNUbXlFUWUrQUp0RFVhcUtpTXk1Z3VrekZjTFJrZ1BDa1J1YVZjSU5CY3gzV0tKN2FJWE9SVldKbGR5MGdXT2RtRjYxaVFNb0VKeW9VS1VqbVYwQlZZcTlpSXJ1aUsxSVV6K0hXVWdwV09WelZrQ0RGZS83QUhOa2xvV29TV0JWVmRyM2dZYXlKZk9oV0xiSGxkYmpsVGNQbU0wT2lGUjBVUW5QRVBOUEFHSkZsSE9KbCtyQUpXN1pXR093VmZuQmxmZzRsVGF4bFVpRGtXbkhoWVBma0JuZkVQQlBBRmlBaGM2clZlMWVWZURNYUdsVmliOW5HSlBTV1lqeWhXWkFWaUkzV0xSNldTdlVhVVo3R0lTRVlrYWNnZ0Q4VWRGZFFDRWdZR0U1Z0NUcEFFR01JSXY1QjhPclpqdHJrYjhNVmhHNWVET3VoMS9QOVhrTVQ1bXJDWklHOFRHeTcyWWkyQVBMYlNCMHg0SW5DWW5kckpZeG9tVGQrSmE3a1daTVlsalh0NVl0UnhuR2dZaWZTeW51YlVNUmF3ZmJoU0F6SjBPbENIblhDNFN5NlFCa3lRY1RLeWgva0paRDRYalVOMmxuZUVKeXJHWnNrcFRzdDVvR1AwZnNGZ2Rtb1VDVERvUE5Iak1jSEFCR2VVSWJJd0FwdHdmeGVXZ1VBRlpMdUdFYmc0VUI4S2dNalpabTcyWm5CMm9sSFhJY0ZRZGYwQ01LZ1hjVnJHYXJYU0Rvd2tRTGVSZjFWVVpsNXBscmdYVTJ2R1ptcG9vQndUaDBsYU5jSFFEeXpDTndIZ0JIMkFCQ3dRQ1d4Z0NXS2dvUHVpQVBmWGFaR3piejNYb3dpNWtndVVlMEs2WWtINFVIQzRKSFAyZGwxaUNheG5nRlAvQXAreHA2UDdKbTE4dWtPV1pHMStCNFF0cG1yVklpVWYwQTRRTUFJS29FeHNrQ1dNSndTaDRKNk1xaWt5NEErekZudmhkMnY4Um42ZHlKZ0dHWERTZDRhM0pJRHYwNEtwK2tuclVBWExoSHpPWkd0L0pxbVR5cUZWZ1Q2WHVuNENHQ2k5Mm1wU3dDR05nbnpZR1diNmRubkdlcXg5K2hGRk5uMjVXankxZ1FkaFlDSFBlbWsxSUV3TmlHUFdtcWZnT1ZUaU9aNGw1bXRzYzJvRUJ5dGhoQUF1d0t2bEtraitJMG96QktIcktuNTZtcTJMT1p3YWNhdVpSRFFrUnkwV1VBVyt0SzlvSkF0VmhuanBTbm1WUjBYNjk0ZkhDbjN5Q3FoQ3gzN3VzMjFzY0djUW0wWk9BQWcxRUFxUmtFU2tPcTJiRnJDd3lxUFFlSHNkbXduZS8vbzJSRmR5VXNjR0JmQko4ZEFITEFBS1Z4SU1LVWc5U2FTQW9iQUJEMnR4UEFCdkFIQUp0ZU5JN0NxYUhOaWZQdGcyekFxdUlWdHljblpFd1FBS2FwQTg4WkFIQ3BoNlpyc3lYOUpPdzhjRFRBQiswRGF3VmN0clY0dEhRQ1JzRTBSR1djTWw0c0E0b1hRL0VKYy9rY0lHWXZCNDRLWUc0cko4a2FxbEhlaWpuTmQ1bUxNbnFYYXZTUHFFS0pkeWROb3ZabEEva1lJL1R2aDd4S1J3Tm5kc0cyQ2hyeW9jN2JxaG1ERzM5S3BKd3VaN0oyYzNiQUFLRFpDbUx4TjVtK3VpbmF0NGlPb2wrdHBxU3dBamlMdUI3dHFGQUhld0NQdXhkcnR0VGhJS1VobzZmY3VBTWNoTWJiYzYyVmRuS29wbk1tQW1GenUxdUJhM2ZHZHRsLytadFlISE9leFJRV2dnWldnRUFFd1hjekw0b0NibnVaVjdONkZ3aEV6RURpOXdDbERFYVhpWHVPVDNPOEN6clBXcXRYTERCS2lLWjFWeXV3M1l2dWxFdmRrbkJFRWdQMDZnQUZwaWQ4cTN2OWphZGFKV3ZEMXhxN1VVYkFMOEhmUjdhUkJ3ZUMzcWhPK251NTk3TjFMUU5hT3dCMWhBT3FQMHN0c3JmbHkzZitianVGaUxhc0xtQW44QWJpT3d2b0tUdS9BTGZOUURDbnY3TkUzd2dCUWJ2YzUycGR3YnE4TTdxdytCdzNRcnZ2WFNBcFpDZndtSXdIOEx1RjBpQktIYk5TYXdzZ3hJd2ZvcmV6d1hSM0F5VzNQYndUcjhHcXJXQ09nN2VvNXdNa1dyZG5tck1wUENBa3ZMTjAzQUQ0QlRzZFVLTExMeHhLREdGWk42anJiL3lzR3JlekdSNno0b2Nna0FzQUdNUUhqRHh3NTdFRU5ZY3NjcWlMUWIwRzVwMUFPeDVySzBacVVhZDhFMjdKSmxHSFRzaGJQV2QzQU95TExCNEFlaFVBT0FjTVFsMjBRandBWlA5NmpoSTd5NnRyaU1PeEhJNktXZjk4aTZGSWVlMnpwaTBNZTVuRHpyd0FMd2hHOHovR2VIakxyRFRMTmR5c3JIRExJSHFrNE5qQVRQM0VROTBBSm5ERzAxWEl2RW0wVkF5c2hDTjNUazVINTRDeW11TTg1b2hBYVBVN29EVzN1Q2xxd2VTa3V0VEtRU0pNL3ZtM0JWQUFMMi9FR0FRTHBpRm0zZWk2enMvSjhNRklKV0hNK3Vhd0Yyd0Q4SnpUZmxiTW83WjgySzI0bWlJZEhjWExkMlM5QVdVTUFiUFI1dW9BQ25wNEpUMHc5Z01BSTkveUFESVh3aGJaQnpHSWl4Ky96UUVFMlo3ZXl4M2F5cllpUjZLNjBIVFVDcWZ1dDA4bmxPR0FpcFBSMXFXNHBlNEJ1K0ZiMHgzK0ZvL2FJR29XQUpiTUFQTE1BQWZlQUVBUkE2ZEJmRS8xcksxSXc3Tm9pbCs4Wnh2WVBOMjNxVGZ3ckEzNnExSWVzQ1lPQUd0M0lBVlpiSGFDdDgvb0lFYk1EVVZialdNaEpObWNnZisvbWIvZmxjVlkycjRKUm9pdFlkcXZNQzFKa2hKSkFHRFFvOWY3c2xLcDByRjlEWmgwMkRGN3FIZk5oS3VSYk0ybXArSFVyRmJpeW9SOEprNzhNRUo2QTY4K20rTWhjTVVvQUsxOUlFaDcxUjBJVGErOEhZcTYzT093aWNJUkVDd21tTUlNZktLaWFiczFtSkZtYWlPWlpPS1hvck1tQlIyWG5hOVArVW41RkVpOGh0aThyQ1Q0YndDa0dRbDg2OXlsNnFsZ05Lb0F4Rm03UU5VZk9KeFJnU0R6TEFDQVh3QWdCUVVSZDF4dVNDbjdJSTE3NEppQnlwRkU5RkJEV2czcVNXaUlBS29waUpudGZ4WHZDMUc3YnBodFV0VDdoUnlJK1UybVJXNE9ROWw1bVJXYS9RQUF4K2ZoSnRaTktGR241cFU0OG9tSnlaWVRJdTQ3bTUySDI0MnMvb1Y0amxqNm53QU1SSUZWUUpVMWJKakN4dVVDMmVaRGdsbUVxdW14MUdUWnU0WDZaWmtKZjFqWGIxQ21WQVZhMlo0bHBsbEVmSmlxMFltbUIrWFZzb3E4Sk1xenpKaTNOMVdmN0lXYVE0MHNYVmxVYUdZZ0dLbFcxWjUvZjFsc25CaWJOS3FVMUpFZEtRamJ2SWpXb09qdFdRQ2xhZ0FDZi9uaE5MaVh2U3dlVkhtZWQ2N3BVdTJlY1E4VmlSaFkrVTVZdjlDSTRBK2VNL3V1aHdMcGRGUmVraUlZL1ZPQUFDSUEybTBBcHhSUVQ3T09qK0dGVTJBQWFKVHA2TGZ1dlpUT29pZ1pyeHlGZ1RrQWlRUlFEM09GbjZ5SStiRG82bFlPV2VwZXZhak92bGZWUzVZQUFLa0FXSElBa1NLU0ErYVpJZlVBQXEwTnhVdmVqTVBoS21kUTRMSUEwc2tWclp2bHA3MEFXVFNkZk9yaGJoVGhHbWhRVHQzaHpwUGhNMTRlMEM5ZTVmR2UvZ2RlOElrUTRZMllQOHZwVCtqbHNBVHhBYklKU1FYWm1oWHVaOWRmRDJmdTl5a1E0VW9POXRVVlFQTCtxM0x2RWdrZTF5OFE4WDBBVkRXWjZOUGxnb241UTZXZkN1SGU4eEdmSURWdkpmLzFlVlEvN28vYWFZSWY3dXBFNlJZMW1UWEJyVWRsTHpWNW1WelVpYU9HL2dCdCtScTZWY3VyQUVHRStHLy93dVEwN25kbDcxZDE3MFpzV1ZvWDZNN05nVVRGK1dNbytNaWpqbjdoM205cVdWenFqeVhhbmpkUGtXVC9FQmNQRDBHYS9sRHc3aFIyNzJ4bkhuTnE5ZldyL3lnWGhjdW9XYUFsYnJVQS8wWTMrVkVUNmtzVWlZYklsZGFMK1ZmYStPbmtoYlR2R08vekFGaEVEd1dpN25BcXI0bWlsZm9hTGtzQmlhZG82WXgzM3pTSy9jUGVtWWxyOEFYM0R0UU82YWZQbURTUDc1blhuNzhyV2JZZTc0WTU3MWtxLzYyQzRRbkVGZWZ5RDMzT3J3VWcrYjN3U1lteG5mYkVqam5QbVp1bDlmYllubi9hWlBUTm1Ubk9FWmsvK1ErVmx1OHNsZlVPZ0ozd1Y2NGVadmd4eStZYmsvL1dIVm15Q1c4L0NhR1FIMmpxaUFCc2F2UUJwZkdxc1ltd2tGRUtvRURseTJMTUpCaEFoRkxHVElFQUdDRmdnYU1reFlNV0hCWlFNMWJsUVZ5K1BIV0J4RWp1UlF3ZVJKbEJWRXdXTEp5ZVhMRGgweXphU1ppZEpObkRsdmV1SFowK2RQb0VHQnJxQUFxSXRRcEQxMUxtV0tzK2JUVERGZnZtUUpTMVRLa3lNL2JqUm8wU0ZFRnk1YUNHTUNCczZHSGs3WTZjSEFwTVZFdUFzdFdzU1lrZU5Ha0I1SmxzUnFVdFJLV0ZOZHlvVGFOR2RTeElrVkl6WGNHR3JObUIwRWM2cDZ0YS9XV0Z5N0puU0laazhLSjBuMGpDWmQydlFHRnc5VnI1WVlWKzdjaW5YdkRnUkpzcS8veXBhQ0NUOXR2TmozYjZHTm1UNkdMSGt5eTcrM01XZld1UGtnWEJlQVRFK25UbHBHdnhaNHRMUG03cm9oN0lzRlozKzBqUld3N3NlOWdhOWZMRnduOFpsU2p5Tlh2cHhyeFltcThUQ0pVdDMvOUJxQzBXNUFBcmZqYmpYdktJSk5QSTcwRXFtdjg2YmFqU2IxMkxNd0tQZWNJazQrd1pDekRDdVNQT0xJdWVlKzBzK0ZFZjVUc2JRK2dtbmh4ZXl5SzdEQUE3dkxENEVGN2FJdHBBZFQraXN3Q1F0cjZrSWlmY29RUGc2bjhyQStrVVM4RHo4VEh4cXdCWDlrV1BGS1BhNUxBRVl1dVp6eFMrN3djQ0dOQWxBeEFZM1VYZ3RQSXdmNVFpbkN3WVJrcWtnaTNkdlF1QTZ0K2hDbEVKMGtpTVFiOVNzd0dEU3dOQlFBTml4US8zUlJDN3AwVk1ZQ0xYQUJBQ2VvYzBLS05OVThTTWVPZUhUVHI5emlyTWt3T2kyMEU2b2tYYXFNeWEyYUl6R0NRQkdZRWNZRWVqRFUwQTBTWlhUWFhSOU5JSUU2VExpU2tUUmNVQkFoVGgzMGNhVWdSeDJ5MU4rRTIzQytQZmxzMGsrQkNvSXlTaWtKN0RLQk5PSzUxVkExUVBuMTNBUjQ1VFdZQlA1WWExdzlMbURDV0UyVEhjbEhJQWViMEtZNW9XM1BzTWRTcFEvRWE1bjdjMXR1Qyt4eVVUWlNoQmRMZHFwZ0ExMkt6N1VnbUdDUWVQZmgwdlpveE5pTDJPUVIzM3hqNHExZmY1Tnk3Q21CcmJyczJpYzVhNGkxV2JuY05kMERPRFpVbkExcXFBSVVJWVJnZzkwRTJHQ0RBUjUwOWkrZUUvQVFJV1NCbEgwelZFNzJKZjgxNWVBQUxrN0pnYTNsQUZ0VkFKMTV0WnBoVkxkb0ZwVFdHUk1USU5pZ0hiWC9RNlhwWSszOUZMZDhxejRaWmF5TmJJcGxQQ2x6T1NYTW1rTllCSm9WdHZsbWRJWFlJRzdJSTUvdUFOV09qVUJIcVU5aUZxYTluKzFiYThpNHJyWndndkJENEJKaFdnaXJVY1hOUGh0ZG8ydm9SbkxhSXg4aHRZZSsyM1RISGpVUDFXcjNzUDZiWmE0Si90cHd6dkJJb3ovVG9qaGdEemhDc2FOb2RobUhQZU9rYTlkZTdYalNzQUNQeXV0bXMzZFE4d1krZURwQmowOTB3cjgyT0d5WlVSeVhIVFgyOExsb29ZV0lBNUFBdHZkZjdSNjRnRURoZTlydWVIZTN6WW5LV2VpNzBQQm9Fcml1bVFSbXBWTUlBdXlRTThqSlloVC80NkRTQU9EL29nSG1ybDRIeEZlekZzakE5VGh3ZlZRWm5mc09WcUpKZFZDR00veVBFMXJRS0VpQlQ0UnF3dHpJcG1ZK09hSFFOeXFFNE9DeWNqd0t3a29FTGVnRERaMzR4Tkc4SUZGZU1sQnJlRGcrQkZKdFh6UEpFQ1dBbzhLb0tHbFBXa0VlckpTWFBTaW1rWU5td0VLNkZBV2pFRm9SYXAwaUgyNGt0RVYrQ1NkYXd3bWRxbURSUGo5dFJnVHlVMk1oLzVlclhyMG9qcGJyWVIzaHBMY2dYazB4UkJTajF3em1uQllBd0pDYjFKNHNxa0EwUmxGUmh6dWNZK1pBaFo1SThrMWxmRnloNEFCNVNZVXNVUW9mNEdRdDQrWUdmaEROall1QzQ0QUlPTWVPT0ZLTFd4UWlobGpaU2lOS01KQXlrMVUvNEdaTGFEN3NBeXdRZ3NWQ3FVaGYvKzZ3Z0pjVEdma2VDY2tUcXRLWVMrbWo0TWJvd216RkVuR3lzc0FGb3ZuT2NRR2ltdFo4WXk5SEtVZGtrZkNISmd5blRoQkRTVDhDTW9rbTBrNHc0QUJQaEE0TEZMcE1aQTUvbWMrbytkQjNRT3pjVWxaSnpnZmlLWmtUaEYrSjFrbWdCRlRCREFrbGFYV1NFQXBrQ0sxNnZNUm1GZkhKellnS2s2TDl4QWxqQUdwT2E4SFNvNExDdzRzdTVzNlNCblU2SDJnSEl6YWdEK2tsQUdOYnlpWXBOMlVYVStLTm4xejAzRS9BcU5IUkxiTkVQTzNwRFMzQWhob2cxQWtiQUFNV2doRTB0S0kxR0pGZ3dRalVRTXVTZmtBR1BSaUJBaTZoT2dGYURvc2ttNm9rL1haTUNKN3pmZXJrcWVzdUZvbEtiZklEUDZoQzBIUlpNY2ppRC84TGdFQ2pVUFV3aUF1Y1FDSVFwV01XcDVwSGZ3TGxxbFRaS0JJN3FzUjF5cXFyWGxYVXI0UWdIVFZ1QUdpUnBTMXQyU0NFSUREUHNrNUEzRFliZVRjdFZyU21WZ1ZqSlkvb0oyWjJhN1dNT3BjUU5PbkVKSUJobnJSVkYzTnR5dzhTV0ZZUENuaExLWVg1MmFxcUw0d0J6ZWxBRjFKWW43YTJ1VDl3WWcwc0VkbnF4dGU2RkdOREhOUWcxQUxRaTdOUnBWb3FkNktVNHJJd3B6b2xxSFlNYTRGekJVTU10NWdoSTVaS01mbEdtRmNWRXdJWTRKcFFNMXlpTlFic2JBazVSMU12OGtTOGdTMXZPbmVxM0FNMzEyRWQzTUIwNlZuZFI2VTN2aFFMaGg4U20xQTQ2SmZEZXVHckFxbHFVUytzTEQ1WUhmQkFrcXZhNVM0cXdYSC9jSU1NNVFsaEdNYzR4ak5PTUNqRVFWSVN2TVczK2l6Zmh5blVyeEdUVnJETUVlUjVVU3hqQkNzVkdYbVFJUVFtaHE0b1Mxbk9ySjJ2VXZueFRIaU9JZzFPMisrOUp1cmxINGRXZlJ4S1pnWFFlZHF2ZUl2T3dXQ0RGSm93UTFSSURNclhmTlNYcFB5Nlg3RUJEQ1QxQU1oMkxGR3AraGkwaHdtekh3VnIzdFJPeWFmczBzZEluWGlCTjcrNG5sMzZVdGtXVitlaVpSZWhsTnR5VEQ4RnAvUDVVN3pHbFdDVHpNdlZGZ1FqR1lCWWh4cVI0T0pkc2xTVXRWYjByZXNzQkgzQXN3ZVgwREZNTyt5N3ZzNXB0QUkrcms2VktLZ0U5R01QRjFZakFLRGRVSHRTdTNVSFZtK20wMlpMWXVGT2ZGR3I0KytFVzlOeHU3TEVpRGF6L3d2NjBVUmIxdURkbEk2M3ZGVnQ3WG9YTFJUc1RpTUUwZ0RDaDhLVXZ5WDd0eGVIVGU3am1yY0Z2M2pjTzU4TVozaTMxT0dycFhmRWhhQ0FRdlpCREd4d3FGTi9PelYra21yUXhEYTBzVTBNS3hjZ0hKNXUwTVJqZVZYcGxUOXF3bzJETFEzakFRZy9UTEdsR2NlY04vME5ZbzhmYzd5cU9xZHBCZW1DSlpDVUFRdG4rTFRuRGZHSUIrUE9NMnhIRUJoTjZhWWVpOHQyQlBTb2h4dHd5blRkM0lpN2hMQVF1ZzVKeTNyV2M3NzAwcHU3Qnljamc2SFNqbnV2ZzJuMXVsOE43NlgxZWl4ZFVBQ1N0aU9YS0Q4NjRSMVZYWW9KZ2MwZFpJY1lGai9yeGpzZTFNRHVlSWduMzhLOUx4SG1KSTNDekRtdkxzL0xOL1RabHVFUFhQL00rTWJ2TnlRZWRrbnJBWXpSQi9LODU4aXRvQWh1bkZCOWtGM0MwMDl6NDlnN1F4YkVlcGYycERwdHJNNXhyQjhmK1ZzWGVMbk5HeDJoeXNEMms2YSs0UnZIQXRFMFdQdHdOOUMrNlppU3EzK1piNlhHNlJFclh5TGxRUVhMYWdJeGdEYkIwejNJRW9JcXNCSW5Zb0QzK2hYNkd5WDdXNzJac3J2aCtxdjNLS2U4ZXlYendnTmRzeXdRUUFLanFTMFNwQzgyUUlMK1NhTUNlTE1JREIvaGd6eFI4eXNSMDdvaWdqMkQ0UXdFU0lNTGNEWHR1b1VOS0VEdEs4Rk1FNExKWXJCTk1nSFR1NmJVNnpQZ0FyOUFDeTNpb2tIMkdUam5PQzh4RVl0TFVJQVI2QUVab0RoNCtnQnhBQVFXaUlTelNpdTE0Z2NXYUlDM2dpY0cwQlgvN2hPaEYveTF2T200ck5FNjhvc2dNakl5d2xLdW5sSXFkb21FVUFpQ0RTQ0JkaEJBN2JJc0VraVhxWE1xYjZOQUo3VEEveHFuOFl1S0ltcWYvenN4SkdNNTVzSVlJYkFFTE1DelEvdzdGaENRNEVPSXZRSTNRS3NxMFFLalZ1cS9rRU0xc2pFd2VvTWRvQXJGaEJvQlV0U2hDUncrbkhzSk9yUXA4YnJEUXVPb01qT3pUSnpGNW1JQVd5UXBSdGdFQ2J3aWZwUERSN1RBeEJBeURZeWc1VE0zMUlwRlRWU3ljMkdES3RpWVpZd21ka2lEaU5oRkdQUXhWYXhEVmt5U1lmUzVueHViWTBTejZzTVlSaGhIaEVLVENleTNhUlFuZG1SRllZUzlNdHBHOUtLek5Lc3hVTVJIYU1veDFYUEV5QU95U1pJV1ZPbVFGcnBFZ2p3ei96UkxBQ0ZRUm9WOHB3TG9MZzU3UE9JREowamNJNGtrSHRLeXhQZXBRbU9zTmlYVGhFZnJTRnY2QUREd3RCM3pzeTZMUVgrOHFKUE1LT1VqUnBsSkxTUnpIVFo0THBua0pFYjRoYzJLdzVHY2tIV015Q05CU2ZMeXY1WGNRNHk4R0FnNFNrNzZnMjVyUkZBTE5aSXNTVk9KU3FuRVJxQzBTbTlKZ0ZEUXluSDVBRU9NbTNaZ0FxZlpKbThUeVgxNlNJaGtqeTZpaElrRXVXTFRLa3dra0dBb09iWmNrVDdBZ3Z5cHBpcW9nUTFRQTNHOGtqMmdGN3I4TGMvQ3k3eHNJTEpzUlpiZ3dHd3BSckpwQVdjcVRQOElBRUNJQXdPTU5xVWFHbjhJaFRyWUF6WGdRZEpBaFpvY29ibkxTWjI4ekNMSlRFb1VNMHNxb3loeGdUb1F6ZitoUWdKR2d5emNtN1liQ291MzBEQk5xY3Vvb2p2TGhNS1VPWlhrTXpYT1BDMkN0QUJiRWM3U2dMV0tPYzZHdTZlSldKTUR1aHZvRkRWSURMRyttY0hYdTA2V0ZBRTh1QVRZckowbzJJTWVNQUZNVUtNYVlNSE9DMC9XR0U5ZzZpenovQ1ppZXNyUG1idy82czNPVEo0MEdBVHRpWWNSQUlVM1k3U2dBWVhGYkV3dnBCMFRhS1ArVkRtWHNxTG1yRXNCaFJDcUNjdjBWTS8xeE1BTXJNNnBOTCtmVTZLUjg0QzMxQm5TMUlRZ2pDdzI0QWNHM0o0Q0NBWjRtNUgvMUIxazRSUUJIVkFDTFZBRFRkRWdrMExlTExJa1FpMFhhQVRNZ3hkVUFJU2lvekxJWW9OYXJCMHc4RkVjOHRCN0FsRzZETWxPOFJUekJNdTZlMExjVkZMLzhjdUp2blRGWWpzMDdIUUlGMkNDN1ZTUkpCaUJVM0FSdElzd0lVQUM3V21DVS9oU0lFVVFJWDBxdkdpVE13V012RUZQTlpWT05sM0ZTYXhCNDZuS29FU2NNY0VnMHpBQk9KQ1VhaXU4NmdxR1VHZzJ5Y0ZGRHcxU3k3a2NJaVVQbkNTWlJxMGFQQ3FtU0ZWUk41VktPTzA1T2NYT25YSUJNR2l5SGpnQnNlQXFhaU84MWpvRlRWV2JkV0NDNzJrcWJhS0xWVlZVQ0dIVXlUQVo0c2lRV2VYSkZXWFJXOFZWc0htVnJacExvYXlSbFpQRkxobE15TW12RHdWUXp0b1JUN21OSDNsVldNV2pFejBNNEppQlhCQ2Vkc3lUYXVIVzkxbFEyRWlRR3VGR2gwc0FNTmlndFRrQkN6RFVWR1dROGp4VHZJRlhhcTNXTG1JUElnQUEvd09Zem1CMHgwS0xVL2ZwMTg3MDFrdDFqWURsUXdQemgyTWRsejdRdDBOVjFVUnQxVGVSVnQyUVYvMmJXUFl3aEZjSWdZdjFGMnNjTW4xbGtvNzEySThGMmNPQmk1RjlDQmQ0QVVPUmhhSXFnRDhRQmhDTmpXY3RqMlVwVVgyQmowZlZvd3N4QkVNb2hXb0lnNXhObjUzbFdhN1pXSTc5V2FEVkRHMEJEM1VTV2Yzb2g1eFpCeGtnZ1QxNEFRVklnMGJBS3dGcVZxaHRXWmN0bjFlTldJbmR5d3ZNV3EyMVdSaFlBV2loVGczMEk3TDFtdVZvbGRuNGs3UlZXNERORGpHTml4eEoxSFkxajZxWVZwa1YzSjFjajhMVldnbm8ycSt0azU3Y21qelJrOXV3eEwzSUM4aU5YSXhRVzlxdFhZelFYS245b1VZRjNOYWoyWlFaM2YvQ2ZZVWNrSU5TVVZ6QW1RekI4WkI5YlYxYzNRdXpCWnNSbWQzYWRWYUdGUmt6TlErWS9heVpCZDFJN0J2Z0hWMGlDQUxFelUzZFZGM2tyUXJsWlY3bWRkNkNpZDNJZmQvSXJZMis5ZHVZRFZ6dXZWYWUrTjdSTFFVcjhGcnlMZC9pQ0J6a1RWN2xUUTcxOWRuSGhWNzRoZDI5YU4wZjhWejdsVlg4elYvOUhWMW15SUlaTUlML0JXREFFZUFCWmx6MDFaUGxWVi8yN1JNR0xtR0huYWkvaldBWm5HQ2hrQUFZcnVEZzNZRXV1RmZVRlZ5cjdlQlUrV0RTUXQrL0dPRURQcUlnSnRIT3JWLy9DbDBYQmdvZjhJRlNnR0VKa0dHYnpZRkFzT0d4NUY2K3pPRTdpUXdQL3VBUS91RWgvdUtwcFZwWVpXRWtUdUtnZUFVaVNJWC9KWTVoS0JaZUphRGlLclppRGNIaUhOWmlIdTdoeXZEaUwvNWhSaFhqTVNiak5UVmp4Q0FGS0VCak5XNWlLTmJhVjVBRUlEamRPSlpqZ0tUampOcmk4dzFoUzc1a1A0WUptWjNYd1JYa3hTaUdWaUJrTkY3akowNWtJckFCQjNCa3pJUms3cFhrU2Fia080NWxmZGxrVHFaWFQvNE5BcEFHVXpnRVc2QUZJaUFDSm1aaktQYUJUa0NEOGRWWlZwWmpWeDZ5eUpCbHorVmQrQkRjVzJhUEd4Z0FBcWdGVXlCa1gxWmpZWVppQ1hnRkdGQUNEWjdWWkFiZFpUNW5PcmJpYWJhUUNVaUVKeENBQlFCbFVRYm1KaTdsUkRZRUluZ0FCVGptZFY3U2NzNVdkTVppVnU1bkMyRUZHcGlBYWhZQVhXNkZYdjdsWUxiblJQN21FR2hrdllLV3hIK2VZMG0rNk82dDZOOElBQkM0aFlPdTVtdmU1WWFtNTI1TzVGU1FBQWFRZzNIbWFFblZhSmh1NGI2Qll5VjFTNCsraFhZVzZXTEk1b1krNUpNMlpTc0lBZ05vYVpkKzZaais1MnMxZ0RPQWdYTzRWa3o0QUpzMjZIWitBbXZHNWtPQUFsODJhWWkrWjV1MUFuMElCRlV1YXFNKzZncEphaUNBQVI5SWhWVFlBWnBlejMvQWhLY2VCVlFJQUttK2dYY21nSjBtaFpJbVphNEczbFFvQlJnQUFuNFc2eUVhNkduT2hSVTRnVElnZ2xJbzNMVnU2NzRKQ0FBaCtRUUZCUUQvQUN6ckFNWUE4UUR3QUVBSS93RC9DUnhJc0tEQmd3Z1Q5dGhpd0l2RGh4QWpTcHhJc2VKRVNoZ3phdHpJa2FQRmp5QkRpcHk0NHMwa0dnT0ttVnFReGNqSWx4SVR5cHc1TU4yYmhqQnpSdXpJczJmR1RFQ0RDaDBxMUtkUmp6cVRLbDFLa1daQ1RBSUJyV0NhOU9oUG9rTTdkT0RFdGF2WHIyRERldFhhQVN0UnEyZ3pVbDM3a2lhbUQvOCt3TUhKOW1KYWpXWXpiUVVMcTY4b1VSVUNDeDVNdUxEaHc0VC85dTBybGl2WnNubk4zdTFaZHlUQnR4OUcvZnRETitka2pwSDE3djI2K085aERxZzV4RnF0cXJWcjE4dGlSMWdXb2JidDI3WnB4NDc5dXZmcTFhbFRJMDZzZURIanhsb2pwNjNNM0F2YXlHVEZsZ1o4T3ZYdjNxcGs0eGJCdlRzQ0YzMzBpUDhmVDc1OCtSRXVFS2hmajZDN2V4RzRiKy9HN3ZvMzhPRERpNE5OZnRab2M1MUdZYVVWWDdDWVpsaHcxL1dtM1hidXNhY2VIaEJHaUVjQ1lKaG40WVhteVlCRkFpMTA2R0VMRW9ib0lIdnZkUmZmYk10Z2R4OEhob2x5bkdPUUZjWFRmeUwxUk5Sb25KUldtSFd4S0VqYmJlK05pRUNJZUh6WWdnVklKb2trR3lOZzZPU1Q0d1VRQ2hzSlZHbWxrbGdpbVFBYlRPd1JENVRpeVZKSGV0eko5OXFLaWIwWUkxQ1UwVWdSVDFsNTVSZGhxTEVHRzVBaXRKQkdPMkNTTjhvQmdJU1NnQkJVV3NrR0d5eEEwT2VpakRicXFJVUt0RkJtYlNuV2gxcWFzSFMxWmlZenV2a1FuRUhoV09CZzFyMzJZd1FpSU5ERG82eTI2dXFyam43L3dJSUxFSzVuWW03MXhYS3BZQzVtNnRoUVI3RUZhcWhkelNsWW5hYmF4dDE2ZUxoUUFLelFSaXR0b3hBRWs2U0hFZG82S2FXNTdocFlyMk1CYTlWTE5nbzFXbDkwMnBtZHNzcytDS0dIRmdURHdnZlQxbXR2dEl3RVkyVUNTbUticlhxM2N0dWFyaXdPQnE2bS9iVnAxN0JBaVVwZFlNaTZoaWV6RVhhbzVMNUNoSGZ2azZqc0lRYWgrNFlzc3FGQ1JESkNGQnMvZWNzUE5ZZ1JqQkQ2WHR2aHZ3QnZXNmtxOXhuc1lyamlkZ1NSVDNFVyszQUZkZmJZMnFuZURWbXh4VWxhS1VRVnFLUk1Ycjc2aHB6bDFWaG5LYklRQUVnTkxSb3V3Q2N3emdRVDlpSW5tMUpXTHJGY0dRdXhha2FyTXZHRExsaUFSaE5lUTRuSmxGWmovMm5raDBRVytUZlRXR0xjZGQ2T3lwSUdIcFB5UnJhM2daMmRkbG8zRmdzTG5YQWZEYVFMR3lEdUtBTkM5QzB6NElHWEx2aUhXaHZLZ3VlTnVpRk1lN2crWHJCZ2FrNytYTkE1WGs1cTVwclhsaW9lSkxET0tDcDhYNW5sNE1namYzWElRdXdoUEhrOGJOQ1B0VFMzSi9aczNjNWV3YzRJeStpemN3enJKZWZRUkt0MnA3TGZwVEZDRS9RK0Q2WU1ZaFM2YjliMFg3dzFDMGw0M2tmb3hpUHBMeDdhdXQ3TnltWXdYLzNLZTBqNTFOb2E1akRNcVF0cDdWTGF1d2lucFNvRkF4VGljSitmMU5BQUZ2amhaVUlJb1FnSnBZbFFNQUFDWDlMZ2VOUUFpcXJ4eTM4enExWE5CSmk5QXZLTVRUNnB5RkVxWjdtaEZlMTh2b3VnaFAvZzFUUkRLVXFGU0lRVkE5and2d0RHRG1lUXE0Q2FlcGJBR2xrRmR6a2kzdzk3aDZvSVNoQmU4a3FpR0tkRmdoYk04SWs1NDVVQjBZWkFqVEFuUU9icTRlNGVpS2RVMGUxWlk4d2pyTlloaGJDWmFXQUVWT01OY2JnUlQvMnNJK1k2MTZpT0ZURXVMdXNQVWJ2WExSakJqaVE2b1FhZ2dObklzaFFNS3FYaER6M2dnWlBRRXpEczFUQk5nK1JVcHd4NVNFVEdVWTY3NDExMlR0VkY3cmpnRW96QUVDTVVVS1cvMWErQ0NRZ0dGdmhrcjNWVTRZV2orNStFUnZTZStEZ3VlOXBUNHhyWlNNVXFoa1FIZFZsZ3cvaGlvRmpLTWxrbnFtV0RoT1N1d0JrcEFVZDhGU01zQUtKbE9zZzk0YnpabVZZVVRWNzFhcHBvMnhRaEZRYi9FMFA0c3hUVkNFTm5BQVJISHBMR2JZZ0pEdHdTUko5WjByS09KVnFQbmtSSm5nOGt3UVF5YUFJamVsQ0FEWXdBRG1nQVE2cmc2VXg1a28xZ1VjUVVQbUdrejJybWtDcitqS2xNRFVHRUlFeEZLWGNKVFhRYTB6YmpkSE00NVVNUVF4dnEwTjBZMWFUMHNROStXclNZc1BBbkw1LzUzbjlTNFFNZmxFSUNXSjNwVEYrUmcwRGtZaWxSQlZwb3NqS2d4dmlVZkVCTjYyR0tzOUtuSmd3dHJGVEtBQWdnRFZNY3doYTBJQUlSckpwVnJjN1VCNTFBdzAzajJzcXdYa1duTytXcFlsazYxcnNRbGthakNBQUlia0dEQ2R4Z3JyV3dLMTcxeWxjSitQV3pxWkFBQStUZ2tzZUd4TENvVGExYUh2dlZ1RHJsdFRUWlF4ZEthMXJWLzlyMnBhWWRpUUVjZ0FUYWVncTJNNEZLT2lndzBMaCtacXpJVGU1YlA1UGI1Z0wzTGYvUXhSS0t5MHJLbWFXc0JKck9UNEg2RjdhZWJUOXVoZXB0VjlsY2lDRGtBNW41eHhRSXNaYmI1aVd4UFVRckk0VTZWS0xPOHpjS3JXZGh1bnZQbFg3bE1TMWRMbHhaK1FOV3hHVVVxRUFEZFVFeUdlUmk5NkFGa3UvYkZvcWRCVEdvUkhZY1VvZGN3R0ZKTlRPY0tDS3FmVkFxSExXeVZTd0JWcVYveXZ1bUhWNDNMRDVOS0gwci9GQnhacGhaTGJpRUdWNUZBbllHanB3WXZ0Nko1cU1pL0pZWVUvdkJDbTdMVzlCUTRTaDM4aFVxamVNVFVRZVpFM1ZzMEllOWVGQUZhMTBOZWFhREVJZkQwSWQxaUdjREFOd1dwZVNKSnJQVnp2K2xxNjF0K01RSHkvbXFhMTFBUWtBTHdqTUlSZ0FDREkzZ3NBV1docnJsTWE5em5vdkNCWUlRUDAwZWlnVzVqRlk3d2hBMklROHdrTjlhbyswS1NkandOWENPY2FPbExlR2d4MUszQ2dEcHNSNE5MUVU1N2gwd0tFdXVqQ3ZaQm1WUUE3RTc0REcxcmh2VkRpeXdzNTBBUENNYWo3eTlLYmFSbnpEeHRPVWNDTVF1VWd4Q3dVRENycWR0b1Fid3IxOHhETGF3VFNrN1ZIYnYyTlpzTWNPd3U4aGowVEdJR1Y0YWxvTGhCemRRKzkxTytHRC9mZzFzYlpkeWdNUSsyS3Roald6d2FWT1J6SGFrRUNkNHBDSUdVeE5PWUIwN3BHQ0prYzJQZmc2dmtoRDRFZWs4eWdKUUo5Z0VoNTA0TnBRV1VOTnd4b2dDWjczTm52cFFsblAvaytEcHRoU0pGeENUZFJ2ZzM3ejlscnpCWVMxa0Y4VGJ0SHRRYVRSaVd0L2huWkd5aFdaclIrSkJDZ25YdGJWRmw4eHNoNW5nUkxTZjA2UzlhMUt1R29yUmxGekloOTVUQnhwTjFIZzRRU1JOTFFONXo1emVwSHU2elF1SE1lZnBVUTBLY0lHSHI1N0dUS2RTYlNTbmM5dTBhRDR1b3NvRnBLWTJPNm9nUDJSK3VlWVVUSjNUdEl5NGJuZ01adGdHTnNlNVhmZGkzMzJWMnRSNzdyeCs2NEcvSzVqQjZBY0E5dUNFOXFsd0hVZzRWTVJYUDdKRE1jRE13a09DekEzZnhHMVhxdkt1cGlhL3lUdnlPWCtha2VjVzU3T2pEc3d0cmVyZDA0NUhLTHhNYjVvRkROL1JkUFdtdzcwd3NiNXk3d0Z2VFIyZmZUb2xCU01TTDBjKy83VUxrQUFaMXN6bnJRYjU3cWxQTGhmVEdxRmJ4RE82aHgrTUY0ai8vdVhwZzZUK2lIVnY3NXYzYjhSMThDZExvcllzRm5BQitGY3ZKQUFBRFNBT3B1Y3FqR0FIMXNOL2JVWTc2cmRQbkdaYzR5WW41UlpVZDFaSEVPSjJqOElEZ0JBSmhUY3lMMk1KVllBeUtiTTNoWWMxZjBNa1FwSm04ZUViSHVkbUY0aUJidFJjbVNjcUhUaGhkeVovN0pJbmNrZE9ZWlk4aFpNTU9pZHBkb0IyOVdaK0FWUkthMVprTjdoZjM2Vjc0TGFETDBGVEFMQmd5Wlo1b25GUTJ6VmZDeFUzVXdaaVFXYUVFc0k1cnJJQnFSYUZhamFGTmtoaStkRlVUcFZpNDZJVVdpVUJBZVdGcDNWRjEvVmtsdU1YRW5ZZ0NqVmlEV1ZoYUJoa2NUaGtTUDlsWkNuMUxmZUVZaW0yZm81VkY1NzFXVEhGREZrd0E3NzFoY2VsWEtJaGlObEZpR21WWDBVellxbzRZcWhZaDFlWVQrS1ZXczNWQ3FRQUJhOUFCRlIxVlpvWVU2OGdDVURnaDZBNFhodmhZQTlXaW1mRlg4aG9ITWFCSEpXNEhDeVdGSldWQ0U4Z0FBdFFETFJvaTN0MVZabTRpLzVFQkErZ0FJUDFqSVVWVmFKWWpsdTNZdUxJRnYrQUdhZ1FBS3dRalUrQVdYWUZCWG1WalgzRmpUTDFDbGFnRDRFQWpNOG9qTExZWEFZQUJERGdBNm1RQ2p2UVdvWUVYQXg1WGdXZ0F2N29LUUI1aWVrSUVydDFEZ3NnRFd2d2lUVFNrQTNaQTJRUWtRRTRrU1FwY2hVcGpoNUpFeHZnQ1R4b1dPYW9YQUY1a3E2VmtnSUJGZjl3QVYzL3dHUTVoVmdBdGxnczlSaklGWk15U1JVTkNWMm9BQWZoMkduV0pTQ2t5SUhLK0pSUTZWK2FFbDZTVVpJbU9aUmU4RnJRcFF2NUlKTHR0Wk0zVW95NVk0cHFWWlk2bzR6TVdJa0NabHNzSmhPWThROVNJV3VxOVY2Q09CM0RnWW84b29wNEdZbjcxVjlTK1pQbGFGaVBaUkJ2b1JrTDhBVUs2Um0yQlIxaXFTUFZrWXBtYUYrU1NZWDBwRjk5NlplTFJSYU5SWkVkdVk3b2hRci9NQW5zUlZEa2lGZ3c1cGlHU0dGbkNHS3N5WnBFUnBra3hwY3RncGwzcUJ6QjRpa3JRQUdBa0pPS3VaU0JLQjFrbVpxcWFTbzExaUFuQUFCTDhBY2pzQWQ5QUFFSDRBVHR3QU5qSng2b0FBYVZGbVFnOWt5d0dadVcrWEZ0MVZKNU9KU0EvL2liMlRXRzNsUmZzMFJsNDZRZWdPY3FmVUFyMnNaTUdKYWQyam1Ic1lrWSt2WnRXUmhuNGppZWlWU2VoVGhqUG5JaTY4bDl6YUl4cjNJQXlaQjJJZ0prOHhsUFNIVlNTL1Z4L3pWOTdLZVVZUGhrcUlrNThRY2JOV1pqTjZaeVVJY2tCekF0SmlBR3lKUThZZWFnemJKL3ptU0R4R2FCLzNXT0xHWjl0R1p5TzhJakZhYWVCVnBPUTFSb1dnSitrdFJsaHBjMXlPTUNDWEFDUGZDQTVORUdhWENkdU1GbW1KWnBPYWhpR1NobmVhZDVDQVdFWnFpSUloQ2Y3SEZsUU1wMndTQUdGTFV4c21JSm11UndGckFsbW9BRUp0QXFmU0FNSHNaLzNVYWgrMmFsVjFwZFhGZHJzZlJBQmVnQ2RlQWtTVUFDTDVBR0ZrQWxoc1k4YlA4QUJoV25RWlBFZ3ZjeUFoUFljVk1LZENIM1dBTDRneDBLUVVPQ2dMRHlBVTB3QW1EUUIweWFnSzV5QUxaM0p2bFdwZjAya3NONGZlanlwK0JVRzNvU2ZxZzZiVDFtYnpZelQ5Rm5iSmE0cDhKQ2N1U21POEFYYXNyQ2hya3FmbnNRREpLM2JaUVhSYmxub1ZJRlZzVEtnZGxYZ095Sm9NdXFhMEhBQnMxbmZ2ZkdhdG96cld0NW9ReDJyVVIzckoyWGJuZ1FESURRcmFVV0FGMFdlZTVFVXBSM3FWV3Fwd0JvRVF2MGUrVVRmRW1qTkI0U0REVWdyMkxrQk1FMGI4bzBlV3dtclc5MmpsZXBRLzlhWndIN2RUOHlzSVNXSk1Hd2dnaUxST0xRUWd6cmRKT1hyL1drZFJKTHNadWFyVU00ZkJSa0pjR1FUaXFFQ2VJd0Fpei9FQWtnTkVJaHhHNHMwQUNNTUozdTAyc3VSSFBQZW43b2wzWDdHbXYrbG5jQUczOFE1SzdkWjNCYzR6NGJrRW1zZDdVa1V3Tm5xa0l5VUFCb01EMzZVbThPZTBwVWVublZ1clNnY1gxWlZIVGFvYkVFSjNXREVxK2VVd096OTNDL3RLajd3Z2I4a0VHN2hnbWorcVN3WXh1cytxdXB4SzlYK1c4QU4wZnQ2cklGaHlRdnd3OE5nS3NwRTNNaVV6OUlDSEg3RWd6OElBUHZablhEUnJqNmFiZ2k5Mi9qUTZzQ0I3VXRFQXpKOEFlY3EwR1RjSUl3aUhnMWg3ZkN0R083NWdTdlEzYy9GN0hCT3JwTVc3cUtlN3JOa2dZWGdBbDZCQUd3UzdRTWFqcHJCN2ZCcEFiVEJqYTlPakJSaExLOVN3bG9lMWdsNTZkdmMyN2MwUUxCLzdOclFWQzN5dXQwVHdkMWlkZW1obElodTlZRGRkcHgxV3RBUWVlYlFJR3RiTHM1U3pCdGUwQys1ZnVFUjJna2VEdTF1bVlHUzFDcGw1Wis4aXV4YVNzVTlzdXV2Yk1zalJDbnV5WjdUQWRETVZnNnlxTjR3WVFGdG90RTdmQUMva0FyWTB1OVNCdTZvdXNRV2FwSUo5ZDM4bWRMSWpqQVdPQkNSZHAwc3B1K3hUY29qTWM2U2VBeGlscDdxdmE1ZUlxRm9vdTlLUHk3eTFaMExkd0NZU0Irb0ZQQmQxcy9XL01EbmdNR0RUZXk3dlREOEZ1dXdLcURXa2k2RnV1MExjdWVMckFKSnpBQ2pKQkNlZFFFSDhPbVQ2eStXMU1GcllzNFBPQXlJeXUyV0Z3YlpHdDVvUnRyUFFpOER0ekNuaGUxYmZveXdqUjZraW84dDdBQldQOEFNbGlidHhNM0FsdkxPbW9ndy9ZcXJ0UGJmNE94eFVNOHNiMjN3RGNhWVVqOHRLaExmSm43cUI4clBDWVF3N1JueDVXS3g2eG1RM3Y4cXAzc3lkdkx2UjdZYkc3N3RnWTNLTng2eXNJREFPRDZhMWQ4eWJnbnYydWl0TlUzWjFxNndsMGF4aXBIeWx0eU9MNnNRWURnck01SHpMczdsZnNaakgxOHhIK3NyWXliSkd6d3d0T3NRVDB3YU5wQ2dSQWJ5K2lhcmsybXBSMEl4bUg4b3lSYXpubEVBbWwyZFpnc1NIbmFyMVh4emlvY3lrUG9yaGJBQklkc3owaDBBSTBRdUNhcnhRbWNoVFJpbzNvM3E5KzhmUWhnQVNkd3FnZ3RQSURRYzBmcmYwTHN6M0pKckFIOXpSQVVkbWk4MFJZaURnRHdNbzZjQUtFd0FnY0F0RkQvc25CUUtvY2tUQnl1ZXJhR3RLbk1qS3pzNGdKcGtIVFEwZ1RBVENVdnd3WllVQU45ME1GNWN3RjFXeVZHU2pvV3dHSCtJQVVqUUFKeFNnSy8wTXJjSmpzbk8wM1V5c2w4U3NzK3lIZDNWb0NwNGdJQVVFbGc4Z0VYd0RkWjQzQzFteklGRU15SHQ3eGdxbXFOYUZJVktFMHp1blU2YWNRNCtxZVIrVkRlNFFKTm9nY2ZzSUF0QUo5RWNyazNGd2x4TEMyQWdOZEdJb1B5S1lVaE5vY3hXcmFGdThuLzZIdGltS1BmZERURmlXSGtKS0kvYW5PbkFMM1JvZy9PNnIrYjNZaWRmVjhUcXRQNEZHRG8rQklQTUFPSmlWTTlxS0UvT0dGbFNCK0tlR0ZCTW9PbWt3QzlIQ3NuTUdoN1hTSWxSWVc1YllXdlNKVmNMS3dqNFUrdi94QUNYcW15R1VvZzVtbmNaUmlaeFBtaEF6MndJOUtlajZJR3ZJcXZPSjByZElpZnkxaWJWUm1lU2JGVk1KQ1V2UW1HdGV5VTVjMmhlUm1FNlIxT2pQallIQ1ozMTR5ZEwrclpuMjFQZGxpaGFybkpQTDNmZnNWVmNtQ3Qva2xXVFRtV2hEamdCSDdlaWJnYnJYbmlLQktoa0toZjNmV0tzQmdhcU5VYzNGZ0tWaUJRSEg0N1BQbmhUaGxoaGVoTmtEbVprNmxVRVM2SjJhM2QyODFjcklSVjkvaFpyN0FEWFJEYzNCeUs1UWhmcHhtY3A3aVgrVldXa3doZXNSaFZKMGtMdDBoVlByRGtHWjREU2dEbC96MlJ5aVdXZ3hqaVpybFczb1hmU3VhTVdFa1IwbUNOdFhpTFZVWG1ma1VFTnVBQTRaM200MFdNT3U2VFBtbmsxLzk3NFhWT0VhdHdXUVNRV2JXWVYxVEY1MzRsQWE4QUEwckFrWU5kbW1zT1lKNk82UGxONTRzK0V1NVlXWmNsQUhYVkNwdGxqOXZJalpZZUFyK0lsZTcxa3VmS21hTU9FNThwV2Jjd0FZbmc2Q3BCQ3B1Vmk1U3VpVVJnQlVGZ0FKcWVqbFlwakxsbEFHY0FBK2RBV0RWWm1PMzRqcFkxalFUdzY2dSs1NjJPai82VUNxVUFBMERnMzZPKzdHUnRXcm13QWlkUUJrUlFDakdGa0dqZUhEUTU3K21RRCtTKzZTUjU2eFJoQklHQUJLMHdBSzFRREJzNWsvTU9YSUp3RXpWcTdwT2g3MTVnQkNzUUJFVFFFZ1JmOERQaENFdHc3ejJ0OEtxbDc3bVE3UEpPOFFrUkFDTVE2RitwOFJQSjhBc0o4Z1lCa2g0ZjBhaEY2MTBlVmlqLy8vRWdEeFUwZ0pRdEtlVXdMNG94UHZORVNmRlFvUVpmMFBJdVQ3ODUvdW1menZPQzZmTTVNZTgydVFjc21mTWR6cFJzYnVoVENlcUp2dkJNWHhFcENSY2Y4QUlZTDVFNFR2VldEK0ovQ1Y0VmJ1RTlyKzhNQ1YwZzBKVlMvODVrWlZaUWlZeDJINVU4cFptYmFaVllDVnZReFFwd2o2VlR6MERBYWVWdjNwZG9TWWxwZitSQ1dWNXVZWlNCbi9GZ0daWUEydU9IajU4dDd1S01GWmkzNWZodStRRlFBZmIva1ZwMENhQlhqdVY0cWVXMHFmaUx2NThESnUwSVVaai9zQWRoMzM2a1gvb1ExdVA1dFlxOHY0cXR5RjJybjVhdHIvYUtUdk9Ya1Y1cW9BSlVzWmlNYWZyQ2VkeEFibDk2ZWQxd252aUtwZmQ3Ly9wdVVoQnYvMGtEYjBEMC9ucjd1Si83RWlhZ0pYNVU2UCthRGNXSzFBL253WCtIYW1ucnpERVE3UGdQRzBEeVJSeFdZMVgxR3dvUUZRUUs1RkNRUTZ4WXFoUXVWTGpNWVFTSUVTVk9wQmpSNFRLR0RCRnVORmh3NEVlUUEwV05oRld5SkNlVUtWTjJZSm5KNWN1WGxHVE9wRm5UeTAyY09YWHU1S256Mzc4UEgxRDlJL0NsNTFHY05aVXVwUVRUS1V5V0tsT2FoQ1VxNUVDREd6T3FlbGd4b2dpd1ljV09GZUhWSXNhdENqZkc2bWp3NmxXU0pxV3U3UEEwSmxPYVNQWHFYYkhsQjZ0L2dGYnM1WW1YcVYybkxEdk1SVmx5NU5zS0hSR21YZVlWTEo0V0xqUzdhSUVIajdCTFROS0VBVkRueFlZbExjaUNOWHN4clZxT2JTRi9IQ2xLN3YvY2xuWU55eVRjdTZjQjN6bDMxMFQ4TWlwams0L2ZTcDZjc2F2RXNTMmtmTkJUM2ZwMTdOWVAyTUdEd0R1QzFXVzlPbndOTzNiSDJYRmg0YTc3ZEhodytQRnZEcGRaUE5QeHVjbXRMcy9hbk9IenI4YnlEZzhtb3NqdXdBTjVTS09GN3hyMExyeld5SHR0TGJiUWU4dTJrMVRLemFuZDVQTndML3FLdzA4bC9TQnJTeXZuS3B0SVFBZGQ2QUZCR0xIREJBd1hQTFBSd2U4Z2pCQ3RyZGF5TUNRTWNkUE5zQStMM0drNHhFYWN5akVUbVVzb1JZckljdEJHRjJxSThjcnJhZ2pHUmk1dnhCRThIU3VTTUtQek9JQXJRdzNkSTlKSUk1RjhTa2xPa211eUlCU2RxNGpGQnJ0c3dRNFpzUFJUanorQ2FXSFF6cnJrOHNzSFZ4di9qOGVGemp0enZUUTV4SXZOSW5lelMwazVyM0p5S3dBRERBdEhRekZySVJoQS92eHpCRFlzSUhUVlFVUDFERkV3eHhLVFVWVVFjZ3VrdUNLRmFWSktQVFRzMHZ5cTR1OGcveGJxTkFJcHA5UnoxUVRTV01mVVB6ZEkxUUpxcTJXMVZWZTdjekN6TkFDQmcwSHhKS0xWVm85d1JaT1Q5blpscXRmNGZrMXNNUktGRGFtL0o0MVZFVG84dnpQMDJtcUQ2UU5hVS9lWXRscUNxYjJXMEM0MWs2SUg2cTdyb1JIVldCTlhvd3JOcE8zY2RGM2lsVjNmOEhwVEtpWkJZbzdUS01VQ2RkbFZDN1lnR0JZQWhyWUFOaEtRT1FHVmF5WTBnV0RTNkFPVkswMVF3SVd3Sm1LVVhGeHQwMVhqZFRrbXpPUEVRSmIzby83K3V4ZWlaUFhkLzVmVm1pM0FtUkdYb2UxRGlKbkRsbG5sQk5qQUFoQjJYTjRBM0hBaDRwRmNpd1VLY2lWSmxWSjY2Y09nQW5rL3FPbXNWeUdLRUdna2pFdndjTUdDN2tMbGwreXcyUUNnYTRETjZLTUdMTmdRSWhpeHl3NEdEU2Nndis0QUpvQnVlK2hiUllJVXBZd3pTZnJ1bnBnMkR0NDRuOGFLMlA5V0ZNR0ZFYkpycDQ4NlFzYzg1Wm96VCtEeUpqejNuSjBlOUJHRGpTcjZhTmg0N05hcEEraUpHeTFkSUl6cnRvbjF3cGI2dURIWkNhTGRXSHhka09KWkxGRlJZNFJRTEdBRGM2MHpaNE1OS1VpQS9uNzgvVVNEZXJmZnJ0RGNvNmx1S2R3N2t2ZjBOaFcremM0L0FCSUJIdXd3Qk05OW9BbUFDQVVvaEhEQlVGemdlZm5qWUFldGsvOEVKdUJCWW01cjFQOUVZalM2M1dXQUJKeFAzbHdDdTlnbE1ESUhxVjJBWExBQkQrWlFoenJjZ0FzU1ZiMWFtZEIwS3RIZTlnam93aGVTU0laK0k5OVhYS0FBV2V4UWlsTTBIZytZd0tBZldxU0U1Um9JbWpZa3dOWGREWWt3REI4VEd5SVJCRnlpRFZSa1l4dE5OWUl0TlNob0pJUU5GN0YzdWkrQ01ZeTlNcUJ4bHBUQXJEUVJXUzN3Z0JzTmVjZ0RPV0VUaGRKV3JMUll4N2pKN1hUb0t1SUtLVFZHSllwc2dkREJnN01RK2NsREFrQlFoMHBVdVB4bnh3cWdFSFdWdEdTbGxOSTA4SW1NaGd2Qmx3aGFjSUpSZ0ZLWFUreURvTEQxcWxJK01vaW9WQ1VsMWZXZUQyRVNnWDNiSk5YQTRoMExoQ0lldTZSbUI5a2hCcHIvSWN4TGpxVGpNQ09aeWttbVRvOGJndzhTNzdQTTJjMlNLNTdTbHdYU3dJTnF4aE42U0JpWU5vSEp6VzRLVVpKNFZGT0h5cW5NeGdCeWZPdDBwdFh3WUlGK3RFT2VDd1VZSStCbnJWODJjbzRRMGNqMWlpbk9jYllTUk9hRW5ld0NlVVpuaXNDZ0xiQkFNanJIVUpUR0NCV2hpQm5OQ0JiUkhJMHdBcWVNNU54V3lVb2piclNQNTBTbitKcHpyMDhOeURPRTBwcjlVbnJVN0lDaHBTNkZLQ254T2RNdDFqUjdPTTJMWHR6bHg0QXlzMTVBZmFaUVJVVlM5eFVBcVdPMURnREFOcmFYL2pLbUk2UXBBRk40VEhJV2tLTkxrdVZXMmVsVm9sWkxDTGtqNjFqMWNWYW1Ha3l0YXhWbXJZZ1pUbkd1cVh0ekJaOUE3WHBYRytXVi8xb3lFNEtWR0dvR1J2d0FFRWpRaHo2UUFJZ0NNTUlFbUpBbkVnQWJXSHRLbEsxUmRTdnFFaHZYRnJxT3AxbUZXak9SMVZVRVJCYXNrNTJaRUJpd3l5UVVJQlRCRU1MN01DZThZQVREY3N3RGhCbDJDUWhrWEE2dGdtV2thazM1dHNPR2s2cVVXT3hPWnhzeW53b3lxTGtkNnFBSU5yTmc4TU1FbjFSREtJb3JQUGdpVndoaStKY3VrOENJRWJBZ0dlL0xablVKSzB4OWdsTkRxWVB0VlpQWVdLM1NNa0FqTlcrMXdpYUVQUnh5SFRXUWJud3RIRjhoVk9HazFlUUJCRjZRaHBYVnlMb1NxZWczTDlwUHV5VkZ0ck9OazBEVnlWV1I0clhCdkMxYnk5eTREakNjTm14WjQzSDg1QmNIb3pMMEEwN1lRQmcyd1Jrd0FUakFVLzlWWVlwaiswcW9kQlFXZFJVdmJuVzdXeC9qVEJ4dUJJU09wOXRqTUdkWlpzeGI3MWpqMFlkTGdBZkFGdlVpaXF2cUJRTi8xNlBqZ3pHRFo2dzE0dm9od215TUIwc3pGMlpBbjFkc0VPNHJIRVNYenlWckY2N2JXekVabDJoYjNKTDNxNU5sUXlRYW9GQTNSbUY1WXV2eHdRN0c0MEhyZzZ4N09EU2lUZHptUlZmVm5KbUlsMk9ySEdOSm03ZlNMOEQwSVZlNjFDOUQxTk83eHJLZ2UvdGJwREpDaEtaa3JlbndTT0FCTmpxVENuenNiYTAycWxQVXdRM1VOQzJuVmNacmJOL1p3US8rQVZMTmtPYlZlaE1rWGtTMjNaUWRTMmErR3BvdUFBUFg0aWtEUHh3MzE5UmRWYmEraWpYR3lTd1lXRWpiVWNNUXNVY1M3U05NUnByL3ViM3I2TDY5T0VBdGFBUWcwTGZRUGVqNDJ0ZXk5NVdCNTJ2S2l2V29meWcxVk5XQ1NvSm5sRGVNcGExUG15MVNDQjcxcjlaT2E3MHJibkZ0MDNoNGxrMHBxY050MkcrR2ZGM2VsWE5kSHdzV0Y5UTNwVUdRZU10VCsvSjd4N3h4Tms2cEdvWWQ4RVRUWmJ0UVBtRHNmQTVTcXJuZ0JVaHRRTkYxN1hLa0o3M1hXYVlmVXRzQjd2NUI4bUxIVHJXbHFtNzFCQk9VYWkxUUFGSkpnT3ZBMHZ2bzJWb2N4b2NIN0lWaW9nK2h1N25BOS9uV2d0T25LVzh2eWRYbGppd0M5VHVsZnA3WnhDbGU4VThYVEd4c2NIYzEzVkFId3dYVDFLMDFacFB6c21vcE81Nmd6eFRCR28vcVVKWi8vV0JjNG5Yd2V2dTRYVVpoQkhZWXBXcXIvMmQ0Y1BJVHAzRG11WlFkZS9MYlhXQ3NHL0M2MGJQZGQ0eW50OHlIWk1jR05qMVlmR0xYamlkdU8yK0lUL1VEbDN5R0NuY203c2phNWRnN1A5dFpFMXN3UUZFOE55WmhEMVY0WDFPM0tkTmlILzZtcG44enlWdXNlcUJ5QWR3YnF4N0FPekRiTlREYlBDeHdoRGFDQURHb3NKYTd2OEpqc3dEYUdQOERyL0U3T2NFcGdHa2FxMXRnZ2VZTE5GQWJ0RHh3bzNiZ0IzbUxRQWxVc3UxVE5QN3J2d3RVRHBPcnN0eXFrUk1BaENiWUlIbHFnc29SSGhIVXZNekpNQVowSXdxclBGMXpxb25TdnJWRFBKR2JDZUhnS09OenZLa1pMODl3Z1dCd3B6L29BUU9KSjBjQVFYbnpRZHVMTDB0Z2dWcHJRRnhUd1JFYnZZRmp1Kzd6UHY4Vk83Z29URGVzTXhrWkl5bWNZUU5OQ0lVR0lBRjQwaVVJcUlJS3U3RDRJaTR4VUQ1RVFnWDZNMExxa2tCaSs3Z1dQQnAvZXNMaWE3V0VhelpuTTZoSjJ6YmlRZ2JBKzZRbzJJRGhLcTR2ekJ6bEtxNHFBSVRwK3lSQXNJUWRzNzk3d2orMUd5SW1WQ3hKbk1RL3FrUkJ1aTFZbzcwN2U3QUJwQ1pNTUFFU0tJQVJZSUFnQ0FKOWFJQTlnQUFaeUtXRllvQ3pRc1AvOGppY1c4TDlTendua3l0YlJEQTVmRHdxdkRLTUV3SXc2S3ZsQTV1MFFzSkdGRGRadkVaYTFNWnRqQ0VwckNWTWxDeXlZd0VkSkVkNTZvRXJYTVJYSEIzcmtTcmhlMEUzUEFxM2d5WHhtNkcvcVRNN3d6ZzJDSVZid01lVU9nQk5VQlhzUzhJdEdyZi9nTVRHTjdPcU9BdS8vNHM3dVJ1dldOTTJmY09DVklSSWVXb0hMRWdBLzhxKy9Bcyt4SU10cEhBVHhwc3oyOUxGaFR3dk5oQTZsR1FvZHFnQ3hPbkhkSXk2YTJ6Q2RxRkpqOFJBTS9KR0s5TXRnbkdjbmtRcVZHQ0JHcG5HdGxySDBqTksrUWdSZy94SThWR25rR3pLOHBxc1pKaTJxRVNxbjRrcEZzeTVqTlRLcmVSS3JCSy9qd0tjdXhySlFXR0RVam5Mc1FJQUg3SklSNVFxU05Tb3R5eklwRndpc0ZUSWtVeUFVTGhIdldRb01BQTRVd1BJV2N4R1Z5Sk1GaXNqT3BOSHZFb0FDR2hNc3VvREVTcXNBT00ralJ6SVM0b3poQU5KeEt4Q212Tk1sREtCQlJFWEpiVEdyQlE1N2lITTFHUTJkUnNRZnpCTDEyUW9RN3M1LzV4alM2a1RTQlk2dDRPa2t4ckNTUVRRdXQ5a3FENWdHOUVjVFJjc1RlNWlvZThqanBvRVFIWVNoajU1VG1oaEJBQ3duTXNKQlVBUUI4YjhFd3k0SXBrYUd1cXNRTUc4ellOYk50M0V1a0VLQTlJQ3p5dHBBaTN4TXZTS21UUjRBVWJvd0N2QmhQMlpLR3BVUjJPRFQ4bzh6dm5zcVJtMFQ2QURnQzNzSUFoZ0tUSElneDdvdzBNNlFVc1l4WG16Rmp4TEFDYW9nUUtRZ2Z5MGpnTG9TMytNcWxPcnppYThUdXg4USsyTVM2K01VS2E4blVzSU1zOXBCd2F3SUZLOG9FZ0FnRDV3TGlxcXR2U1R2ZXF5RVF2Z2pFczRBWEJybXdTRkczT0IwUmlkVVoySVFWa2FxQ2w4SnExTFR4aVJoVDNZTkw4THdyemNJU2ZRQkVVc21QL0xjNnExa3FrRTlhWnZna2ttdkZJc3JjVWFEVDhNek1DRXJLWGJPUUhmaEJFU2tJTGZBYlFnNUNzZHFvR0JVYjlRd1JHeEVCTXlBVDY1c1NsMEtiZjRuRkVvakpkNUdTaXU2TkxMOEFlTnV3N3h6QXlZdXpoUUU0SUcwQ0UxUUMxV2FWUTVraFdoR1JjcUJaSnpxVTNybE5FN3BkRThUY3J3UWNpL2VieUNjb0VsMklOLzh5Rk12QnA4cXhrMjZNVDhBWU1yYkZWRGNkUkhwUWhhQ2FLS3VaQmF6YU1ZTmMxYzdVZ3k2dFdva1pxU3laYzg0VHRQcXhZMkNJSU91Z0JmaXFoN2VsTTRuYWxxTFJOc25TVFhjck1HemRYc0JEOWVCVmUvK1ZWZzlSUnlMVmRYdVpaZytFWGpTUUtnakZZSElRdHFuVmQ2ZlJSN3RkVmI1ZGIvM3FnQjREaE4xSE1hR2ZwS1lnSFlZeEhZZ2ZVcXhXbUJCSmlPKzRFak55MmxlSlhYSG9HYk9UMmgyeGl3SVlsRStIaUZFTWpZTnZGV0dJSkhUYUVYZ0cySXFSblhrWlUwTG5HbkpEQ2VKbmhYbHBYU2Jpb2htSVVNOVdBTWJSWEluSUlQUXlpRkI1aUJYR0FUeS9SSWJ2eFpvQzJQaXpDTDhJQ1ZvZXFINzNRWlRHQUJMR3BhS1IwVHFQMFJ1TUNRaWExVWpLcllqWXdQUStqYlZ3aUN3ZGpaRmJOUjhPblZMZjNYWXVHVW9mVlRPdHdXSGpXVjZWRVVvWG5aaW9sWlk2dlY0a1FNeGNOVkQrbmJ2bVVHRkZBQ3dlM0lGK3JaMkttS2p0M1VFNmtUeWxoY2tUVVpBZHlERVlBRE5BQ0RFMGdESm1pRTNNcU16VUF5QkQyTC81ZVZqYnExVzZxdDJqYmNvODcxM0w0bGdob0kzR1Q2MnRkQmpoS1pqWFJ5a3FBVld0Y05xZkRZM3Q4Rm9ybTluaXE5MjBxMUQ2dVZ5ZVJWWGtOSWhTeFFnYTU5WHFSOEY5TmRFc2RJM1dFQjJ1c3RXN1BJM3gyaFhMcWxEZUpsajd3OVhwdWxGUFJWM2xkb0FPY2R6UGQ5ay9pTmwrbWxYbzlGWExLOWlPeDlXTG1OMU1xdFYvRTEzdkpWUE5ZcFlPV1ZnRklBQUowOXlzMGwzOUp0WUFlZVgvbzkzSTlOM1BLSVlRek9ZQTB1WHZ2WTNBRytHeEJHMzFSNGdIY280WC9DNGNWRDRmdUFFK2w5NERteFg5YWRFQXFwWEZSYXU3c040RzNGNFZ5VkFDdmVZYzk5QlJRQUFpTndYeUd1RHlLT01oVXUzUG1GNFBGckN6Uk9ZLy9obGRxWkRhQ3Bvdzk5MVFrZktBVXJ2bUlzZm9VeVVJTDI5WlV2NWxjaVZvd3hwb3JhTUdQVkpXVC9iZVBNeFZjNGptTzlJQUlpU0lVNXR1TTd6Z0U5SHQwK0hsd1JNV0w1UlYxRE5tVDFpT0lBcG1KR2hnOWJnSUpYZU9SSWxnQXM5dHNkNEdJK3VtVEYrMk5OSm1NV2xzSGgvV1R4cGRnTzN0dFJEZzVUYUFWU01HVlVydU5WTm9SWFdJTWZGaU5ZaHN0TUhtTmFwZ3BvcGdyR29ObmkyTnhlTmhJQ2tJWmlBR1poVHVWaXJvWlVzQUlGU0dCTVhlWmRUWkpabm1aMUhqQXBudUtydldiNXVJRUJJSUJhTUlWRHNBVmFRR1U2VnVWaUxvVlVZQUFnWm1SekR1TWlWb3gxWm1mRklHSWhobWRLbVlCVmtHZDZOb1Znem1mL1NKYmtZbjZGYzBobWh0WlZIQ1pvajFib0w5NW9TbUVGR3BnQWVSYUFCZGhtVXFDRlUvWUJIN0RvVlo1amZUQ0FQUmJwZ2Y1b2dsNW1rZTRWVkFnQWtqYnBBUkFBYWZobGZIWmtieTdtTExZQk1DQm5temJuYzY1WnAzYkNuZTZWRHhnRm43NEZoNGJvZWo0RUtLRG9vMFpxUTVDQVY5aUJkMkRxalk1cXRMYm1YRFVBQitBR0xNV0VvT2hwVnNEcVJJRG9ZckRucmpicWZlWm5zQzRGUEM3cnFjN1N0QjdzT000RkExQ0FMRGdFU2FocEF2b0p1QjRGdVM3cEczaUNlYjdyaWRacm1FWnFzVDZITUZnQnhnN3NmUjNzZHRSWEF6QUFOSGlBVitqYlZOaUJ6MmFkbi9nSHVLN3F5RFpweWlZQXl5NXFJbkJwWWdacnp4WHJHZ2NJZ2tBSWFORHVyb1VPYkFNQWdnYm9CQ0xnWWRiRzBvQUFBRHM9XCI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./loaderImage.js\n')}}));